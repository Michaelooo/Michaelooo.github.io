<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>如何将博客升级http2</title>
      <link href="/2018/09/08/"/>
      <url>/2018/09/08/</url>
      
        <content type="html"><![CDATA[<p>最近有在学习 http2 的相关知识，就想着顺便把自己的博客升级一下，其实升级后并不会带来很大的性能提升，不过当做学习用的个人实践也是不错的。</p><h2 id="怎么升级-http2"><a href="#怎么升级-http2" class="headerlink" title="怎么升级 http2 ?"></a>怎么升级 http2 ?</h2><h3 id="升级-https"><a href="#升级-https" class="headerlink" title="升级 https"></a>升级 https</h3><p>升级的过程其实是很简单，但是因为 http2 必须需要 https 的支持，所以要想用到 http2 ，必须要先使用 https， 使用 https 的话就需要生成证书，所以其实这个步骤才是升级过程中略显复杂的一环。</p><h3 id="生成-https-证书"><a href="#生成-https-证书" class="headerlink" title="生成 https 证书"></a>生成 https 证书</h3><p>证书的话，因为只是个简单的个人网站，在安全性上也并没有太大的要求，所以证书的颁发机构采用大家都喜欢用的开源证书颁发机构 <a href="https://letsencrypt.org/">let’s encrypt</a> 就行了， 关于这个证书的生成就使用大家都喜欢的 <a href="https://certbot.eff.org/lets-encrypt/centos6-nginx">cerbot 生成工具</a> 就行了。推荐使用官网推荐的 cerbot-auto 脚本的方式来生成证书，你需要做的就是填写邮箱和你的域名之类的操作。</p><p>这个生成的过程会有一些小坑，我在下面的 <strong>踩坑总结： 使用 cerbot-auto 生成 Let’s Encrypt 证书遇到的问题</strong> 有提及。生成之后，可以使用 <code>./certbot-auto certificates</code> 查看你生成的证书的位置。另外有一点需要注意的是，通过上面的这种方式生成的证书的有效期是 90 天，所以到时间了要记得自己去重新生成。</p><h3 id="配置-nginx"><a href="#配置-nginx" class="headerlink" title="配置 nginx"></a>配置 nginx</h3><p>因为我使用的是 Nginx 服务器，所以只需要简单的配置就可以使用 https ， 配置的内容大致如下：</p><pre><code class="nginx">server &#123;    listen 443 ssl;    listen [::]:443 ssl ipv6only=on;    server_name www.chengpengfei.com;    ssl_certificate /etc/letsencrypt/live/www.chengpengfei.com/fullchain.pem;    ssl_certificate_key /etc/letsencrypt/live/www.chengpengfei.com/privkey.pem;    ssl_trusted_certificate /etc/letsencrypt/live/www.chengpengfei.com/chain.pem;&#125;</code></pre><p>一般情况下，再配置好 web 目录， 重启 Nginx 就可以了就可以看到效果了。但是因为我使用了 docker ，所以还不行，请接着往下看。</p><h3 id="在-docker-中使用-Nginx"><a href="#在-docker-中使用-Nginx" class="headerlink" title="在 docker 中使用 Nginx"></a>在 docker 中使用 Nginx</h3><p>因为我是直接在 docker 中使用的 Nginx，我需要让<strong>我的证书以及我定义的 Nginx 配置</strong>对 docker 容器可见。在这里我一开始的思路有两个，第一是通过 Dockerfile 来指定 volume ，然后生成一个新的镜像，并构建容器，一种是直接使用 docker run -v 的形式去构建容器。</p><p>表面上看起来第一种的方式更为优雅些，但是在我的实践中发现，第一种方式并不可行，无法挂载到指定的文件路径，查阅了相关资料发现，<strong>当你要重新构建一个docker的image时，在Dockerfile 里指定的 volume 是无效的，因为 image 应是纯净的，不包含有指定路径的。</strong> 所以最后我选择了第二种方式，具体的命令大致如下：</p><pre><code class="shell">docker run -d \-p 80:80 \-p 443:443 \--name nginx-blog \-v &quot;$PWD/html&quot;:/usr/share/nginx/html \-v /var/www/blog/:/var/www/blog/ \-v /var/www/my_resume/:/var/www/my_resume/ \-v /home/blog_nginx/:/etc/nginx/ \nginx</code></pre><p>可以看到，直接输入命令的方式可能不是很优雅，但是却有效。不过有一个推荐的做法就是将命令保存到一个脚本文件里面，通过脚本来构建也是一个不错的选择。</p><p>容器构建成功，就可以访问网站来查看效果了。下面是我的网站更换的效果，由 <strong>不安全 变成了 并非完全安全</strong>😂</p><p><img src="https://i.imgur.com/DASIzJQ.jpg" alt="Imgur"></p><h3 id="配置-http2"><a href="#配置-http2" class="headerlink" title="配置 http2"></a>配置 http2</h3><p>配置 http2 的方式更加简单，直接在 Nginx 的配置里更改就可以了（我用的是最新版的 nginx ，所以是支持 http2 的，别用太老的版本都支持的）。</p><pre><code class="nginx">server &#123;    listen 443 http2 ssl;    listen [::]:443 http2 ssl ipv6only=on;    ……&#125;</code></pre><p>之后重新构建一个容器即可，来看个开启了 http2 之后的效果。</p><p>这个是之前的：</p><p><img src="http://ww1.sinaimg.cn/large/86c7c947gy1fv27gvnz6yj22tu0hmgtd.jpg"></p><p>这个是 使用 http2 之后的：</p><p><img src="http://ww1.sinaimg.cn/large/86c7c947gy1fv27gvjv0pj22vo0b2djw.jpg"></p><h2 id="踩坑总结：-使用-cerbot-auto-生成-Let’s-Encrypt-证书遇到的问题"><a href="#踩坑总结：-使用-cerbot-auto-生成-Let’s-Encrypt-证书遇到的问题" class="headerlink" title="踩坑总结： 使用 cerbot-auto 生成 Let’s Encrypt 证书遇到的问题"></a>踩坑总结： 使用 cerbot-auto 生成 Let’s Encrypt 证书遇到的问题</h2><h3 id="1-提示-Problems-with-Python-virtual-environment-？"><a href="#1-提示-Problems-with-Python-virtual-environment-？" class="headerlink" title="1. 提示 Problems with Python virtual environment ？"></a>1. <strong>提示 Problems with Python virtual environment ？</strong></h3><p>官方给出的解释是 <a href="https://certbot.eff.org/docs/install.html#id7">低内存的机器会出现类似的问题</a> ，但是按照官方给出的 <strong>创建一个临时 swap 文件</strong>的方案并没有解决。后来查阅资料确认是国内 Python mirror 的问题，因为我用的是阿里云提供的 vps ，但是阿里的Python mirror 同步不及时，所以造成安装失败。只需要修改 <code>/root/.pip/pip.conf</code> 的配置即可，可以改为其他可用的 mirror (推荐清华大学的 pypi 镜像 — <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a>) ，也可以直接注释掉使用原版的。</p><h3 id="2-生成证书时，使用了-docker-部署-nginx，-但是本机并未安装-nginx"><a href="#2-生成证书时，使用了-docker-部署-nginx，-但是本机并未安装-nginx" class="headerlink" title="2.生成证书时，使用了 docker 部署 nginx， 但是本机并未安装 nginx ?"></a><strong>2.生成证书时，使用了 docker 部署 nginx， 但是本机并未安装 nginx ?</strong></h3><p>cerbot 给出了两种方案来生成证书，一种是 webroot ，这种也是普遍推荐的一种，因为不需要停止你的服务，只需要在 nginx 配置里做些更改即可，生成方式可以看<a href="https://certbot.eff.org/docs/using.html#id12">这里</a>，但是因为我用的是 docker 部署，本机并没有安装 nginx ，所以这种方式对我来说并不适用。另一种是 standalone ，这种方式会在本机临时建立一个服务器，但是会默认占用你的 80 端口或者 443 端口，所以这种方式需要先解除掉 80 或者 443 端口的占用， 使用 docker 的话用这种方式就很方便，直接 <code>docker stop containerId</code> 停止掉容器即可，等到证书生成完成，重新启动即可。</p><p>但这里有一个大坑是：<strong>尽量不要去手动的 kill 掉 80 端口的 pid</strong> ，因为关掉容易，但是不熟悉 Linux 的话，开启就会比较麻烦，我的 阿里云 ECS 是 centos 7 的版本，但是 centos 6 和 7开启端口的方式还是有很大的差异的。</p><p>以上！</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> nginx </tag>
            
            <tag> http2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>换新电脑不用慌-轻松搞定vscode配置</title>
      <link href="/2018/08/27/"/>
      <url>/2018/08/27/</url>
      
        <content type="html"><![CDATA[<h2 id="换新电脑不用慌-轻松搞定-vscode-配置"><a href="#换新电脑不用慌-轻松搞定-vscode-配置" class="headerlink" title="换新电脑不用慌-轻松搞定 vscode 配置"></a>换新电脑不用慌-轻松搞定 vscode 配置</h2><blockquote><p>写这个总结的目的是因为发现很多同学并不是很了解 vscode 的隐藏功能。因为之前自己经常换电脑，换出心得了已经，遂总结下。</p></blockquote><p>相信大家都曾有更换新电脑的经历，换新电脑肯定是件开心的事，但是每次换新电脑后复杂的软件配置和数据同步却是件很令人头痛的事情。</p><p>同样的，作为一名前端工程师，<code>vscode</code> 可能是大部分开发者的灵魂伴侣，但是这个伴侣在有些事情上却并不是那么如意，灵活的配置和丰富的插件生态是 <code>vscode</code> 受到大家喜爱的根本，但是在更换新电脑的时候， <code>vscode</code> 对于插件的管理的备份却有点捉襟见肘（如果 <code>vscode</code> 可以集成微软的账号同步服务那也是个不错的选择，但是作为一个开源软件，微软并不会这么干）。所幸的是 <code>vscode</code> 是基于配置的，所以你可以通过<strong>拷贝你的插件配置文件</strong>来达到新电脑同步的目的，但是这样一样存在配置丢失的风险，并且操作也略显复杂。不过显然会有另外一种比较优雅的方式，那就是使用 <code>Setting Sync</code> 来同步配置。</p><h3 id="Setting-Sync"><a href="#Setting-Sync" class="headerlink" title="Setting Sync"></a>Setting Sync</h3><p><code>Setting Sync</code> 也是 <code>vscode</code> 的一个插件，他利用 <code>github</code> 的 <code>gist</code> 作为你的配置文件的存储载体，所以理论上只要你的 github 账户不丢失，你的配置文件就不会丢失。同时值得一提的就是，你的这些配置文件还具有版本管理的功能，所以你对配置文件所做的变更都一清二楚。</p><p>废话就不多说了，现在来说怎么使用吧。</p><h4 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h4><p>首先，你得有一个 <code>github</code> 的账户（别说你没有），如果你已经有了账户，那么 <code>github</code> 就会自动给你创建 <code>gist</code> 账户，简单的理解就是 <strong>github 之于 项目代码 犹如 gist 之于 代码段</strong>。你可以随意的新建你的代码段，比如这是 <a href="https://gist.github.com/Michaelooo">我的代码段</a> 。</p><h4 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h4><p>因为每个人的使用方式都不一样的，所以下面涉及的操作我尽量不使用 快捷键 来提示。</p><ol><li><p><strong>安装 Setting Sync 插件</strong></p><p>直接在 vscode 插件面板输入 Setting Sync下载安装即可。</p></li><li><p><strong>新建一个 token</strong></p><p>为什么需要 token ，因为你需要 授权 Setting Sync ，这个插件可以访问并创建 gist。 </p><p>安装完成之后，需要<a href="https://github.com/settings/tokens">新建一个 token </a>，然后勾选的权限只给一个 gist 就可以了，<strong>generate token</strong> 之后复制生成的 token。<img src="https://shanalikhan.github.io/img/github2.PNG"></p><p><strong>生成的 token 不用担心丢失，如果不记得了，重新生成一个即可，但是不要把 token 随便给别人。</strong></p></li><li><p><strong>新建或者配置 gist 文件</strong></p><p>你可以调出 vscode 的快捷命令窗口 <code>cmd + shift + P</code>，键入 sync 来进行 <strong>上传设置</strong> 操作。<strong>需要注意与 git 的命令区分</strong>。</p><p><img src="http://ww1.sinaimg.cn/large/86c7c947gy1fumzabi2bej20f708tdir.jpg"></p><p>如果你是第一次使用，那么会提示你输入上个步骤生成的 token ，粘贴回车，第一次上传设置会自动新增一个 gist 的配置，生成成功之后会有成功的提示:</p><p><img src="http://shanalikhan.github.io/img/upload2.png"></p><p><strong>生成的 gistID 一定要记住，最好可以保存下来，如果实在记不住，可以去个人的 gist 列表里开启双目扫描查找</strong>。例如这是 <a href="https://gist.github.com/Michaelooo">我的 gist 列表</a> 。</p></li><li><p><strong>同步&#x2F;下载 配置</strong></p><p>以上的步骤做完，就代表你的 Setting Sync 可以正常使用了，通常，你只需要 调出快捷命令窗口，然后输入 sync 就可以查看并使用 Setting Sync 的同步或者下载配置了（使用快捷键会更方便）。</p><p>即使你更换了新电脑，只要你记得第三个步骤里保存的 token，同步也是非常方便的（不记得也没关系，重新生成一个就好）。你可以通过 <code>cmd + shift + P</code>  –&gt; <code>sync 高级选项</code> –&gt; <code>编辑本地扩展设置</code> ，将你的 token 粘贴在配置文件里，然后再执行同步&#x2F;下载的配置即可，具体如下：</p><pre><code class="json">&#123;  &quot;ignoreUploadFiles&quot;: [&quot;projects.json&quot;, &quot;projects_cache_vscode.json&quot;, &quot;projects_cache_git.json&quot;, &quot;projects_cache_svn.json&quot;, &quot;gpm_projects.json&quot;, &quot;gpm-recentItems.json&quot;],  &quot;ignoreUploadFolders&quot;: [&quot;workspaceStorage&quot;],  &quot;ignoreExtensions&quot;: [],  &quot;replaceCodeSettings&quot;: &#123;&#125;,  &quot;gistDescription&quot;: &quot;Visual Studio Code Settings Sync Gist&quot;,  &quot;version&quot;: 300,  &quot;token&quot;: &quot;put token in there&quot;,  &quot;downloadPublicGist&quot;: true,  &quot;supportedFileExtensions&quot;: [&quot;json&quot;, &quot;code-snippets&quot;],  &quot;openTokenLink&quot;: true&#125;</code></pre></li><li><p><strong>新建用户配置的gist</strong></p><p>因为 Setting Sync 是针对插件的同步，所以你还可以将你的用户配置文件放到 gist 上，等到更换新电脑的时候取回即可。</p></li></ol><h3 id="插个嘴"><a href="#插个嘴" class="headerlink" title="插个嘴"></a>插个嘴</h3><p>其实 vscode 还有一个很好用但是很少人用的功能就是<strong>工作区</strong>啊，感觉我 一、二十个项目代码没有这个会疯掉的。当然这个功能好像所有的 IDE 都有，不过为啥就是很少人用呢。</p><p>以上！</p><h2 id="换新电脑不用慌-轻松搞定-vscode-配置-1"><a href="#换新电脑不用慌-轻松搞定-vscode-配置-1" class="headerlink" title="换新电脑不用慌-轻松搞定 vscode 配置"></a>换新电脑不用慌-轻松搞定 vscode 配置</h2><blockquote><p>写这个总结的目的是因为发现很多同学并不是很了解 vscode 的隐藏功能。因为之前自己经常换电脑，换出心得了已经，遂总结下。</p></blockquote><p>相信大家都曾有更换新电脑的经历，换新电脑肯定是件开心的事，但是每次换新电脑后复杂的软件配置和数据同步却是件很令人头痛的事情。</p><p>同样的，作为一名前端工程师，<code>vscode</code> 可能是大部分开发者的灵魂伴侣，但是这个伴侣在有些事情上却并不是那么如意，灵活的配置和丰富的插件生态是 <code>vscode</code> 受到大家喜爱的根本，但是在更换新电脑的时候， <code>vscode</code> 对于插件的管理的备份却有点捉襟见肘（如果 <code>vscode</code> 可以集成微软的账号同步服务那也是个不错的选择，但是作为一个开源软件，微软并不会这么干）。所幸的是 <code>vscode</code> 是基于配置的，所以你可以通过<strong>拷贝你的插件配置文件</strong>来达到新电脑同步的目的，但是这样一样存在配置丢失的风险，并且操作也略显复杂。不过显然会有另外一种比较优雅的方式，那就是使用 <code>Setting Sync</code> 来同步配置。</p><h3 id="Setting-Sync-1"><a href="#Setting-Sync-1" class="headerlink" title="Setting Sync"></a>Setting Sync</h3><p><code>Setting Sync</code> 也是 <code>vscode</code> 的一个插件，他利用 <code>github</code> 的 <code>gist</code> 作为你的配置文件的存储载体，所以理论上只要你的 github 账户不丢失，你的配置文件就不会丢失。同时值得一提的就是，你的这些配置文件还具有版本管理的功能，所以你对配置文件所做的变更都一清二楚。</p><p>废话就不多说了，现在来说怎么使用吧。</p><h4 id="前置条件-1"><a href="#前置条件-1" class="headerlink" title="前置条件"></a>前置条件</h4><p>首先，你得有一个 <code>github</code> 的账户（别说你没有），如果你已经有了账户，那么 <code>github</code> 就会自动给你创建 <code>gist</code> 账户，简单的理解就是 <strong>github 之于 项目代码 犹如 gist 之于 代码段</strong>。你可以随意的新建你的代码段，比如这是 <a href="https://gist.github.com/Michaelooo">我的代码段</a> 。</p><h4 id="如何使用？-1"><a href="#如何使用？-1" class="headerlink" title="如何使用？"></a>如何使用？</h4><p>因为每个人的使用方式都不一样的，所以下面涉及的操作我尽量不使用 快捷键 来提示。</p><ol><li><p><strong>安装 Setting Sync 插件</strong></p><p>直接在 vscode 插件面板输入 Setting Sync下载安装即可。</p></li><li><p><strong>新建一个 token</strong></p><p>为什么需要 token ，因为你需要 授权 Setting Sync ，这个插件可以访问并创建 gist。 </p><p>安装完成之后，需要<a href="https://github.com/settings/tokens">新建一个 token </a>，然后勾选的权限只给一个 gist 就可以了，<strong>generate token</strong> 之后复制生成的 token。<img src="https://shanalikhan.github.io/img/github2.PNG"></p><p><strong>生成的 token 不用担心丢失，如果不记得了，重新生成一个即可，但是不要把 token 随便给别人。</strong></p></li><li><p><strong>新建或者配置 gist 文件</strong></p><p>你可以调出 vscode 的快捷命令窗口 <code>cmd + shift + P</code>，键入 sync 来进行 <strong>上传设置</strong> 操作。<strong>需要注意与 git 的命令区分</strong>。</p><p><img src="http://ww1.sinaimg.cn/large/86c7c947gy1fumzabi2bej20f708tdir.jpg"></p><p>如果你是第一次使用，那么会提示你输入上个步骤生成的 token ，粘贴回车，第一次上传设置会自动新增一个 gist 的配置，生成成功之后会有成功的提示:</p><p><img src="http://shanalikhan.github.io/img/upload2.png"></p><p><strong>生成的 gistID 一定要记住，最好可以保存下来，如果实在记不住，可以去个人的 gist 列表里开启双目扫描查找</strong>。例如这是 <a href="https://gist.github.com/Michaelooo">我的 gist 列表</a> 。</p></li><li><p><strong>同步&#x2F;下载 配置</strong></p><p>以上的步骤做完，就代表你的 Setting Sync 可以正常使用了，通常，你只需要 调出快捷命令窗口，然后输入 sync 就可以查看并使用 Setting Sync 的同步或者下载配置了（使用快捷键会更方便）。</p><p>即使你更换了新电脑，只要你记得第三个步骤里保存的 token，同步也是非常方便的（不记得也没关系，重新生成一个就好）。你可以通过 <code>cmd + shift + P</code>  –&gt; <code>sync 高级选项</code> –&gt; <code>编辑本地扩展设置</code> ，将你的 token 粘贴在配置文件里，然后再执行同步&#x2F;下载的配置即可，具体如下：</p><pre><code class="json">&#123;  &quot;ignoreUploadFiles&quot;: [&quot;projects.json&quot;, &quot;projects_cache_vscode.json&quot;, &quot;projects_cache_git.json&quot;, &quot;projects_cache_svn.json&quot;, &quot;gpm_projects.json&quot;, &quot;gpm-recentItems.json&quot;],  &quot;ignoreUploadFolders&quot;: [&quot;workspaceStorage&quot;],  &quot;ignoreExtensions&quot;: [],  &quot;replaceCodeSettings&quot;: &#123;&#125;,  &quot;gistDescription&quot;: &quot;Visual Studio Code Settings Sync Gist&quot;,  &quot;version&quot;: 300,  &quot;token&quot;: &quot;put token in there&quot;,  &quot;downloadPublicGist&quot;: true,  &quot;supportedFileExtensions&quot;: [&quot;json&quot;, &quot;code-snippets&quot;],  &quot;openTokenLink&quot;: true&#125;</code></pre></li><li><p><strong>新建用户配置的gist</strong></p><p>因为 Setting Sync 是针对插件的同步，所以你还可以将你的用户配置文件放到 gist 上，等到更换新电脑的时候取回即可。</p></li></ol><h3 id="插个嘴-1"><a href="#插个嘴-1" class="headerlink" title="插个嘴"></a>插个嘴</h3><p>其实 vscode 还有一个很好用但是很少人用的功能就是<strong>工作区</strong>啊，感觉我 一、二十个项目代码没有这个会疯掉的。当然这个功能好像所有的 IDE 都有，不过为啥就是很少人用呢。</p><p>以上！</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git开发规范</title>
      <link href="/2018/08/15/"/>
      <url>/2018/08/15/</url>
      
        <content type="html"><![CDATA[<p>在团队开发中，团队协作是比埋头编程更值得去深入的东西。一套好的开发流程（规范）可以避免很多不必要的麻烦，现在大部分的公司都使用 git 来进行代码管理，这里结合个人工作中的所得以及个人使用中经常遇到的坑，做个简单的总结。</p><p>对于 git 的编程规范来说，其实 <strong><a href="https://www.git-tower.com/learn/git/ebook/cn/command-line/advanced-topics/git-flow">git-flow</a></strong>  就是一套好的编程规范，它对工作中的 git 事务性的操作做了一个封装，在团队还不具有一定的规模化的情况下，使用 <strong>git-flow</strong> 是一个不错的选择。如关于常用分支的定义，就可以参考 <strong>git-flow</strong> 的思想：</p><blockquote><p> <strong>master</strong> 只能用来包括产品代码。你不能直接工作在这个 master 分支上，而是在其他指定的，独立的特性分支中（这方面我们会马上谈到）。不直接提交改动到 master 分支上也是很多工作流程的一个共同的规则。</p></blockquote><blockquote><p><strong>develop</strong> 是你进行任何新的开发的基础分支。当你开始一个新的功能分支时，它将是 开发 的基础。另外，该分支也汇集所有已经完成的功能，并等待被整合到 master 分支中。</p></blockquote><p>但是当团队有了一定的规模化的时候，要求所有成员再去学习 git-flow 的使用，这样的成本也是很高的，所以这时候我们倾向于使用原生的命令来操作。</p><p>下面是我总结的在工作常用的场景下，对 git 的一些操作。</p><h2 id="开发一个新的功能时"><a href="#开发一个新的功能时" class="headerlink" title="开发一个新的功能时"></a>开发一个新的功能时</h2><p>比较好的开发规范就是，当你开发一个新的需求时，应该按照下面的流程进行开发：</p><p><strong>第一步：基于 develop 新建一个人分支</strong> </p><pre><code class="shell">git checkout -b &quot;new-branch&quot;</code></pre><p><strong>第二步：同步个人分支至远程仓库</strong></p><pre><code class="shell">git push --set-upstream origin &quot;new-branch&quot;</code></pre><p>使用 <code>--set-upstream</code> 的目的是跟踪远程分支。后面执行命令时可以省掉指定源的操作，如：</p><pre><code class="shell">git pull origin test =&gt; git pull git push origin test =&gt; git push</code></pre><p><strong>第三步：功能开发完成后，发送 merge 请求</strong></p><p><code>master</code> 分支和 <code>develop</code> 分支应该被保护，只有稳定的版本才可以允许合并操作。合并的方式因团队而异，常规的流程是找到具有<code>develop</code> 分支开发权限的成员，执行：</p><pre><code class="shell">git checkout developgit merge &quot;new-branch&quot;</code></pre><p>如果你的团队使用 gitlab 进行管理，就可以发送一个由 <code>new-branch</code> 到 <code>develop</code> 分支的 <strong>merge request</strong> 。</p><h2 id="如何写好一个-git-comment"><a href="#如何写好一个-git-comment" class="headerlink" title="如何写好一个 git comment"></a>如何写好一个 git comment</h2><p>不应当出现语义模糊或毫无意义的 comment 描述。每个团队都要有自己的 comment 规范，当然也可以直接用大家都已经接受了的</p><pre><code class="shell">feat：新功能（feature）fix：修补bugdocs：文档（documentation）style： 格式（不影响代码运行的变动）rebuild：重构（即不是新增功能，也不是修改bug的代码变动）test：增加测试chore：构建过程或辅助工具的变动config: 配置example: git commit -m &quot;[feat] 新功能&quot;</code></pre><p>以上总结自： <a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html">阮一峰： Commit message 和 Change log 编写指南</a>]</p><p>如果你很皮，想加个开源库那样 comment 的表情，你可以执行：</p><pre><code class="shell">git commit -m &#39;:apple: i have a apple&#39;</code></pre><p>苹果就出来了，更多表情代码可以点 <a href="https://github.com/Michaelooo/just_write/blob/master/archived/%E5%85%B3%E4%BA%8Egit%2C%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E6%93%8D%E4%BD%9C.md#git-comment-%E6%B7%BB%E5%8A%A0%E8%A1%A8%E6%83%85">这里</a>。</p><h2 id="做一个-hotfix-时"><a href="#做一个-hotfix-时" class="headerlink" title="做一个 hotfix 时"></a>做一个 hotfix 时</h2><p><strong>Hotfix</strong> 是为了应对已上线的产品代码出现的问题出现的紧急修复，所以和开发新功能的流程略有不同。 <strong>Hotfix</strong> 显而易见是基于 <strong>master</strong> 分支的。但实际的操作步骤和上面是一样的，这里不再赘述。</p><h2 id="分支切换遇到问题时"><a href="#分支切换遇到问题时" class="headerlink" title="分支切换遇到问题时"></a>分支切换遇到问题时</h2><p>这里的问题往往是：<strong>使用 checkout 切换分支时遇到的冲突</strong>，或者是 <strong>分支切换的时候遇到尚未添加至暂存区的代码</strong>。对于这两个问题，前者往往很容易解决，解决掉冲突，重新 checkout 就好。后者的话就有些头疼，假如你的源分支已经有了自己大量的神仙逻辑代码，所以你不想使用 <code>git add</code> 将这些文件添加到暂存区，你也不想用 <code>git reset</code> 的方式去处理，这时相对比较好的方式就是使用下面的方式:</p><pre><code class="shell">git stash -u暂存，区分与 git add 的暂存git stash list列出暂存内容git stash pop 取回暂存</code></pre><p>这样就可以畅快自如的切换分支了。很显然，使用 <code>git satge</code> 的方式条理也会更加清晰些。</p><h2 id="怎么去处理构建任务时"><a href="#怎么去处理构建任务时" class="headerlink" title="怎么去处理构建任务时"></a>怎么去处理构建任务时</h2><p>这个场景可能与这篇文章不是那么符合。</p><p>如上所说，如果使用了 <a href="https://about.gitlab.com/">gitlab</a> 来管理团队代码，gitlab 所集成的 CI&#x2F;CD 也是很不错的 devops 的选择，目前的项目团队也在使用，使用工程化的 gitlab.ci 配置文件，来自动化执行测试、编译、构建、部署等一系列的工作，原来部署过程中繁杂的工作变成了 **<a href="https://docs.gitlab.com/ee/ci/quick_start/">如何去写好一个 gitlab.ci 文件？</a>**。</p><p>如果没有使用 gitlab， 同样的，使用 github + <a href="https://travis-ci.org/">travis.ci</a> 也是比较流行的开源库的实现方案。</p><p>另外，在之前的工作中，也有使用过 <a href="https://visualstudio.microsoft.com/zh-hans/tfs/?rr=https://www.google.com.hk/">TFS</a> 的方式，这个是微软提供的服务，国内用的比较少（收费，价格还挺贵），国外很流行。这个的构建配置比起上面两个要复杂些，但是使用过程还是很舒畅的。</p><p><strong>以上。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go入门踩坑及环境配置问题相关</title>
      <link href="/2018/08/09/"/>
      <url>/2018/08/09/</url>
      
        <content type="html"><![CDATA[<h1 id="go-入门踩坑及环境配置问题相关"><a href="#go-入门踩坑及环境配置问题相关" class="headerlink" title="go 入门踩坑及环境配置问题相关"></a>go 入门踩坑及环境配置问题相关</h1><h2 id="学习网站"><a href="#学习网站" class="headerlink" title="学习网站"></a>学习网站</h2><ul><li><a href="https://www.kancloud.cn/kancloud/the-way-to-go/72675"><strong>Go 入门指南</strong></a></li><li><a href="https://www.kancloud.cn/kancloud/web-application-with-golang/44105"><strong>Go web 编程</strong></a></li><li><a href="https://golang.org/doc/"><strong>官网</strong></a></li><li><a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/04.0.html"><strong>深入解析 Go</strong></a></li><li><a href="https://gowalker.org/search?q=gorepos"><strong>Go 仓库大全</strong></a></li><li><a href="http://cngolib.com/"><strong>Go 标准库指南（中文）</strong></a></li><li><a href="https://github.com/avelino/awesome-go"><strong>awesome go</strong></a></li></ul><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><p>直接去官网下载 <a href="https://golang.org/dl/">go的包</a>，下载后解压安装。</p><h3 id="配置-gopath"><a href="#配置-gopath" class="headerlink" title="配置 gopath"></a>配置 gopath</h3><p>gopath 可以简单理解为你的工作目录，可以自己定义位置。</p><pre><code>echo &#39;export GOPATH=$HOME/goPATH=$PATH:$HOME/.local/bin:$HOME/bin:$GOPATH/bin&#39; &gt;&gt; ~/.zshrc</code></pre><p>使配置生效</p><pre><code>source ~/.zshrc</code></pre><h3 id="使用-go-env-查看配置是否生效"><a href="#使用-go-env-查看配置是否生效" class="headerlink" title="使用 go env 查看配置是否生效"></a>使用 <code>go env</code> 查看配置是否生效</h3><p>一般目录是下面的这个样子就是对的，<code>GOPATH=&quot;/Users/xxx/go&quot;</code>，xxx 是当前用户名称。</p><h2 id="2-配置-vscode-开发环境"><a href="#2-配置-vscode-开发环境" class="headerlink" title="2.配置 vscode 开发环境"></a>2.配置 vscode 开发环境</h2><h3 id="配置-debug-环境"><a href="#配置-debug-环境" class="headerlink" title="配置 debug 环境"></a><strong>配置 debug 环境</strong></h3><p>使用 vscode 调试 go 的话，需要安装一个go的第三方依赖：<a href="https://github.com/derekparker/delve">delve</a>，可以使用下面的命令安装：</p><pre><code>go get github.com/derekparker/delve/cmd/dlv</code></pre><p>安装后就可以在 debug 面板添加 debug 配置文件调试了，示例如下：</p><pre><code>&#123;  &quot;version&quot;: &quot;0.2.0&quot;,  &quot;configurations&quot;: [    &#123;      &quot;name&quot;: &quot;Launch&quot;,      &quot;type&quot;: &quot;go&quot;,      &quot;request&quot;: &quot;launch&quot;,      &quot;mode&quot;: &quot;debug&quot;,      &quot;remotePath&quot;: &quot;&quot;,      &quot;port&quot;: 7000,      &quot;host&quot;: &quot;0.0.0.0&quot;,      &quot;program&quot;: &quot;$&#123;workspaceRoot&#125;&quot;,      &quot;env&quot;: &#123;        &quot;GOPATH&quot;: &quot;/Users/michael/Documents/go&quot;      &#125;,      &quot;args&quot;: [],      &quot;showLog&quot;: true    &#125;  ]&#125;</code></pre><p>如果启动后报下面的错误：</p><pre><code>lldb-server needs to be installed in $PATH</code></pre><p>可以采用下面的方法解决：</p><p>执行 <code>xcode-select --install</code> 解决，<a href="https://github.com/derekparker/delve/issues/986">原因未知</a>。</p><h3 id="配置开发语法提示"><a href="#配置开发语法提示" class="headerlink" title="配置开发语法提示"></a><strong>配置开发语法提示</strong></h3><p>随便建一个 <code>.go</code> 的文件用 vscode 打开，会自动提示安装 go 的相关插件，但是一般会有一些插件安装失败，一般都是下面的几个：</p><pre><code>Installing github.com/nsf/gocode SUCCEEDEDInstalling github.com/uudashr/gopkgs/cmd/gopkgs SUCCEEDEDInstalling github.com/ramya-rao-a/go-outline FAILEDInstalling github.com/acroca/go-symbols FAILEDInstalling golang.org/x/tools/cmd/guru FAILEDInstalling golang.org/x/tools/cmd/gorename FAILEDInstalling github.com/rogpeppe/godef SUCCEEDEDInstalling github.com/sqs/goreturns FAILEDInstalling github.com/golang/lint/golint FAILED</code></pre><p>可以参考这个<a href="https://cloud.tencent.com/developer/article/1013066">修改办法: 让你成功安装vscode中go的相关插件</a> 修改。</p><h3 id="注意-如果没遇到就忽略"><a href="#注意-如果没遇到就忽略" class="headerlink" title="注意(如果没遇到就忽略)"></a><strong>注意(如果没遇到就忽略)</strong></h3><p>但是在最近的测试过程中，发现 golint 依然会报安装失败，原因是 <a href="https://github.com/golang/tools.git">https://github.com/golang/tools.git</a> 这个仓库里不包含这个 lint 的工具了，所以我们需要单独的安装这个工具包。</p><p>通过查询此 <a href="https://github.com/golang/lint/issues/397">issue: Where did golint go?</a> 解决</p><pre><code>mkdir -p $GOPATH/src/golang.org/x \  &amp;&amp; git clone https://github.com/golang/lint.git $GOPATH/src/golang.org/x/lint \  &amp;&amp; go get -u golang.org/x/lint/golint</code></pre><p>上述命令可能会遇到文件夹已存在的问题，可以直接跳过第一步文件夹创建的操作就可以。</p><h2 id="3-使用一些包管理工具来管理第三方包"><a href="#3-使用一些包管理工具来管理第三方包" class="headerlink" title="3.使用一些包管理工具来管理第三方包"></a>3.使用一些包管理工具来管理第三方包</h2><p>因为 go 官方没有提供自己的包管理机制，所以包的管理是个坑。市面上各家提供的包管理都是各玩各的，但也有大家用的多的，关于 go 比较常用的包管理工具，有以下几个推荐的:</p><ul><li>godep : <a href="https://www.jianshu.com/p/db59b10c8c51">golang 包依赖管理 godep 使用</a></li><li>govendor : <a href="https://studygolang.com/articles/9785">go 依赖管理-govendor</a></li><li><strong>glide</strong> : <a href="https://github.com/Masterminds/glide">glide 包依赖管理</a></li></ul><p>目前项目中正在使用 glide， 使用 glide 管理包的话，会生成一个 venndor 的目录，可以理解为一个跟随项目的局部 gopath， 这样子在引入第三方包的时候，实际的读取顺序就是： 局部 vendor -&gt; 全局 gopath 。</p><p>另外，在使用第三方包的时候，有些第三方包会托管在 google 的服务上，因为墙的原因，我们没法方便的拿下来，甚至你搭了梯子还是很蛋疼。所以我们只能自己配置镜像源了，因为我们用的是 glide ，所以就拿 glide 的来做例子。</p><p>我们只需要使用 <code>glide mirror set</code> 命令来设置镜像配置（<a href="https://github.com/xkeyideal/glide/blob/master/README_CN.md">参考</a>）： </p><pre><code>glide mirror set https://golang.org/x/sys https://github.com/golang/sys</code></pre><h2 id="后续待补……"><a href="#后续待补……" class="headerlink" title="后续待补……"></a>后续待补……</h2>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何用node去搭建一个项目发布系统</title>
      <link href="/2018/07/18/"/>
      <url>/2018/07/18/</url>
      
        <content type="html"><![CDATA[<h1 id="如何用-node-去搭建一个项目发布系统"><a href="#如何用-node-去搭建一个项目发布系统" class="headerlink" title="如何用 node 去搭建一个项目发布系统"></a>如何用 node 去搭建一个项目发布系统</h1><blockquote><p>最近在处理一个静态资源系统的发布平台，大概意思就是对于多环境的静态项目，希望可以通过系统控制来改变过去繁琐的项目的部署方式，同时对于静态页面引入的一些接口请求则通过全局的网关来控制来处理跨域。权衡利弊之后，采用最熟悉的 node 来实现这么一个功能，后端框架选用 koa@2 ，前端使用 react 来做管理界面。</p></blockquote><p>项目的部署作为软件开发过程中的最后一环，往往也是最容易出问题的地方。所以，一套优雅的部署方式以及一套完善的部署监管对于项目的稳定运行也有着至关重要的作用。关于部署，有很多已经有一定规模的第三方管理平台，比如 jerkins、travis，以及微软的 TFS 等，都已经是有一套完善的机制，同时也有庞大的用户群。不过另一方面，技术服务于业务需求，所以各家公司因为需求的不一致，对以上产品的使用难以做到合适的定制化，也会选择自研一些项目发布系统。轮子该造还是得造的嘛！</p><p>有关项目发布系统，本质上是设计大于实现的，但关于系统的设计我也并不能聊什么，基本大同小异，我就聊下实现的过程的遇到的一些问题好了。项目最重要的有两个部分，一个就是全局的网关控制，另一个就是项目的部署。我就从这两个入手好了。</p><h2 id="网关控制"><a href="#网关控制" class="headerlink" title="网关控制"></a>网关控制</h2><p>在过去的一些部署方案里，对于一些轻量的静态页面，如果涉及到一些页面的跨域请求，我们通常的做法是做一层 Nginx 代理，这样做的后果是，当项目的发布一旦达到一定数量级，那么就要不停的去更新 Nginx 的配置，同时还要重启，这样的方式的确太不优雅了。</p><p>所以为了更方便的管理，我们使用一个开源的 API gateway 工具来控制。如果不了解 kong 是什么，可以先来看一下这篇文章： <a href="http://www.chengpengfei.com/2018/06/29/">微服务 api GateWay 工具： kong</a>。</p><p>kong 的使用很简单，没有什么特别大的问题，但有两点需要注意，一个是 kong 的迭代目前有些快，我使用的时候是 0.13，但是现在看已经是 0.14 了，所以可能会有更新的变化需要做兼容处理，另一个就是，kong 提供的 admin 接口在于 koa 实践的过程中，并不是那么契合，特别是在异常捕捉这里，你需要对 kong 的异常行为在 koa 里面单独处理。</p><h2 id="项目的部署"><a href="#项目的部署" class="headerlink" title="项目的部署"></a>项目的部署</h2><h3 id="文件的解压"><a href="#文件的解压" class="headerlink" title="文件的解压"></a>文件的解压</h3><p>对于上传的部署文件都是以压缩包的形式存在的，所以我们需要对项目文件进行解压，这里在我的实践我调研了三个库</p><ul><li><a href="https://github.com/EvanOxfeld/node-unzip">node-unzip</a> ：支持 stream 的方式读文件，但文件过大，会导致报错 <a href="https://github.com/EvanOxfeld/node-unzip/issues/110">Error: invalid signature: 0x6064b50</a></li><li><a href="https://github.com/kevva/decompress">decompress</a>：不支持 stream 的方式读文件，提取文件的过程无法捕捉</li><li><a href="https://github.com/node-modules/compressing">compressing</a>：支持 stream 的方式读文件，提取文件过程操作方便</li></ul><p>最后我选择使用了第三种方案，过程中遇到最大的问题是，如果你要使用以 stream 的方式解压文件，这种效率最快，但当你使用 fs.createReadStream 去创建一个只读流，然后又使用 fs.createWriteStream 创建了多个写入流，这时候你无法无获取最后一个写入流结束时的状态，这个问题还是困扰了我，最后我只能用这种方式，使用 setTimeout() 函数来“保证”在写入完成之后才可以进行接下来的操作，大致的代码如下：</p><pre><code>const compressingStream = async (ctx, source, target, options) =&gt; &#123;  return new Promise((resolve, reject) =&gt; &#123;    let isExist = fs.existsSync(source);    if (!isExist) &#123;      reject(new Error(&#39;file not exist&#39;))      return;    &#125;    let targetExist = fs.existsSync(target);    if (!targetExist) &#123;      mkdirp.sync(target);    &#125;    fs.createReadStream(source)      .on(&#39;error&#39;, function (error) &#123;        reject(error)      &#125;)      .pipe(new compressing.zip.UncompressStream())      .on(&#39;error&#39;, function (error) &#123;        reject(error)      &#125;)      .on(&quot;finish&quot;, function() &#123;        resolve(&quot;ok&quot;);      &#125;)      .on(&quot;entry&quot;, function(header, stream, next) &#123;        stream.on(&quot;end&quot;,next);        &lt;!--不是一个好的解决方案，设置延时函数--&gt;        setTimeout(() =&gt; &#123;          resolve(&#39;ok&#39;);        &#125;, 2000);                let fileName = header.name;        let type = header.type;        if(options &amp;&amp; !/^__MACOSX\//.test(fileName))&#123;          fileName = path.join(options.prefix, fileName);        &#125;        let reg = /^\d|\s/;        if (reg.test(fileName)) &#123;          reject(new Error(fileName + &quot;文件名称不合法,不允许空格或者数字开头&quot;));        &#125;        if (!/^__MACOSX\//.test(fileName) &amp;&amp; type === &quot;file&quot;) &#123;          stream.pipe(fs.createWriteStream(path.join(target, fileName)));        &#125; else if (!/^__MACOSX\//.test(fileName) &amp;&amp; type === &quot;directory&quot;) &#123;          // directory          mkdirp(path.join(target, fileName), err =&gt; &#123;            if (err) return reject(err);            stream.resume();          &#125;);        &#125;      &#125;);  &#125;);&#125;;</code></pre><h3 id="CDN-的处理"><a href="#CDN-的处理" class="headerlink" title="CDN 的处理"></a>CDN 的处理</h3><p>有关于项目的部署，其实初期设想，大部分的资源都是静态资源，对于一些需要体积偏大需要缓存的文件，我们需要上传这些文件去到我们的 CDN 服务。而对于一些不需要做缓存的文件，比如项目的入口文件，我们就可以同步到我们的资源机里面。</p><p>对于第一点，我使用的是开源的 <a href="https://github.com/noodny/node-ftp-client">node-ftp-client</a>，这个并没有什么操作难度，唯一需要注意的就是 node-ftp-client 的方法是异步的，所以为了兼容 koa@2 的 async&#x2F;await 写法以及保证程序的执行顺序，需要对 node-ftp-client 的方法进行一次 promise 化。代码如下：</p><pre><code>const test = async (ctx, source, target) =&gt; &#123;    let ftpConfig = &#123; &#125;;  let options = &#123;    logging: &#39;basic&#39;  &#125;;  let upOption = &#123;    baseDir: source,    overwrite: &#39;none&#39;  &#125;  let fct = new FtpClient(ftpConfig, options);  return new Promise((resolve, reject)=&gt; &#123;    fct.connect(()=&gt;&#123;      fct.upload(source, target, upOption, (r) =&gt; &#123;        console.log(source,target,r);        resolve(r);      &#125;)    &#125;)  &#125;)&#125;</code></pre><h3 id="在docker-中使用-rsync-来进行项目发布"><a href="#在docker-中使用-rsync-来进行项目发布" class="headerlink" title="在docker 中使用 rsync 来进行项目发布"></a>在docker 中使用 rsync 来进行项目发布</h3><p>这个大概是耽误时间最多的一个操作。</p><p>有关于发布系统最重要的一环——发布源码到目标主机，我使用的是开源的 <a href="https://github.com/mattijs/node-rsync">node-rsync</a>。其实这个库只是对于 linux rsync 命令的一次封装，<strong>底层需要操作主机支持 rsync 命令</strong>。</p><p>听起来并不是什么复杂的操作，但是在真正的执行的时候，问题还是挺多的，因为要发布的目标主机是在 docker 内部，当然这不是最大的痛点，最大的痛点是我要操作的服务机器没有外网访问权限。下面就几个遇到的问题做一些分析总结：</p><p><strong>1. docker 中不存在 rsync 的命令？</strong></p><p>看到这个，你可能会觉得很简单，没有 rsync 的命令，使用 linux 的 apt-get 或者类似的工具安装一下就好了啊。但是如上所说，测试主机是没有外网访问权限的，所以直接安装这种方法是不可行的。</p><p>当然，即使没有外网访问权限，对于一些常用的包，我们也有一些类似的镜像源，我们只需要在安装的时候修改一下这个源就可以了，这个应该大部分公司都是一样的。这个方法当然是可行的，但是我还是放弃了。因为项目的迭代性比较高的话，我认为每次都在打包镜像的时候，去修改 docker 内部 apt-get 的源再安装，不是很优雅的方式。所以为了以后更好的执行类似的操作，我采用构建一个 node+rsync 精简的基础镜像，构建方法如下：</p><p>第一步，新建 Dockerfile, 这里我用的基础 node 镜像是 node:8-alpine，Dockerfile 内容如下</p><pre><code>FROM node:8-alpineRUN apk add --no-cache rsync</code></pre><p>第二步，进入到 Dockerfile 文件目录，本地构建镜像</p><pre><code>docker build -t xxxx.com/node-rsync .</code></pre><p>第三步，或者部署到内部 docker 镜像服务</p><pre><code>部署到内部镜像服务,也可以指定版本，默认为 latestdocker push xxxx.com/node-rsync</code></pre><p>第四步，无推送权限的情况下，推送到目标主机（非必需）</p><pre><code>docker save -o node-rsync.docker xxx.com/node-rsync   //打包离线docker文件：node-rsync.dockerrsync -cavzP ./xxxx.docker root@host:/path    //使用 rsync 推送到目标主机docker load -i xxxx.docker   //本地离线安装镜像</code></pre><p><strong>2. 在 docker 中使用 rsync 传输公钥密钥的问题</strong></p><p>因为使用 rsync 传输需要一次密码认证，所以我们需要对 rsync 做一次免密认证。解决思路就是在构建的镜像里生成本机的公钥，然后将公钥添加到部署主机的 <code>~/.ssh/authorized_keys</code> 中来实现免密登陆。当然更进一步，如果每次构建镜像的时候都生成一次公钥再添加这样的操作是很冗余的。所以我们可以生成一个通用的公钥密钥，在每次构建的时候只需要复制到镜像内部即可以解决。</p><p>以下是详细的构建脚本：</p><pre><code>BUILD_TIME=`date &quot;+%Y%m%d%H%M&quot;`SERVER_HOST=&quot;&quot;SERVER_PATH=&quot;/home/web&quot;CONTAIN_NAME=&#39;web&#39;IMAGE_NAME=&quot;xxx.com/web:$BUILD_TIME&quot;rsync -cavzP --delete-after ./ --exclude-from=&#39;.rsync-exclude&#39; $SERVER_HOST:$SERVER_PATHssh $SERVER_HOST &quot;\  cd $SERVER_PATH; \  echo &quot;删除旧容器&quot;;\  docker stop web;\  docker rm web; \  echo &quot;清理过时的测试镜像&quot;; \  docker images | awk &#39;/^xxx.com\/web[ ]+/ &#123; print $3 &#125;&#39; | xargs docker rmi -f; \    echo &quot;构建docker镜像 $IMAGE_NAME&quot;; \  docker build -t $IMAGE_NAME . ;\  echo &quot;发布docker镜像&quot;; \  docker push $IMAGE_NAME ;\  echo &quot;docker start&quot;; \  docker run -d -p 7777:3000 -e NODE_ENV=test \  --hostname ubuntu-14 \  -v /data/package/:/data/package/ \  -v /home/:/home/ \  --name=$CONTAIN_NAME $IMAGE_NAME ; \  echo &quot;生成 .ssh 目录&quot;; \  docker exec -i $CONTAIN_NAME \  mkdir -p  ~/.ssh/ ;\  echo &quot;ok&quot;; \  echo &quot;复制公钥,为了ssh登陆&quot;; \  docker exec -i $CONTAIN_NAME \  cp -rf ./auth/test/* ~/.ssh/ ;\  echo &quot;ok&quot;; \  echo &quot;修改权限&quot;; \  docker exec -i $CONTAIN_NAME \  chmod 0600 ~/.ssh/id_rsa ;\  echo &quot;ok&quot;; \  echo &quot;模拟登陆主机：首次使用rsync登陆主机存在验证合法性的问题&quot;; \  /usr/bin/expect &lt;&lt; EOF        set timeout -1    spawn docker exec -it $CONTAIN_NAME ssh $SERVER_HOST ; \    expect &#123;       &quot;*yes/no&quot; &#123; send &quot;yes\\r&quot;; exp_continue&#125;      &quot;*\#&quot; &#123;exit &#125; ;\    &#125;  EOF ;\  exit; \  &quot;echo &quot;\033[40;32m\n&quot;echo &quot;Sync to Server: $SERVER_HOST&quot;echo &quot;Build source code path: $SERVER_PATH&quot;echo &quot;Image: $IMAGE_NAME&quot;echo &quot;Image deploy success.&quot;echo &quot;\033[0m&quot;</code></pre><p>以上</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
            <tag> kong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次狗血的修bug经历</title>
      <link href="/2018/07/11/"/>
      <url>/2018/07/11/</url>
      
        <content type="html"><![CDATA[<h1 id="记一次狗血的修-bug-经历"><a href="#记一次狗血的修-bug-经历" class="headerlink" title="记一次狗血的修 bug 经历"></a>记一次狗血的修 bug 经历</h1><blockquote><p>没什么别的目的，写这篇就是为了提醒自己是个傻子</p></blockquote><p>起因是这样的，在一个风和日丽的一天，测试给我出了这么一个 bug ：</p><blockquote><p>hello 啊，这个页面啊，打不开啊，我的 iPad 啊，就是点了不会动了啊，其他的都可以的啊，赶紧看一下啦</p></blockquote><p>在经过漫长的沟通后，我得到了以下信息：</p><ul><li>ios10 的设备下某页面的登陆点击之后无法跳转。</li><li>安卓和 iOS11 的设备是正常的。</li><li><strong>没有足够的设备的调试。</strong></li></ul><p>其实看到这儿，我的内心还是有点窃喜的。自上次自己解决 <code>ios9浏览器无痕模式下浏览器 localStroage 存储失效</code> 的问题后，我发现找这种类似的兼容性问题的过程还是挺爽的，我其实对我自己发现问题和解决问题的能力是很自信的，所以我想，我又可以秀操作了。</p><p><img src="http://t1.baidu.com/it/u=695851676,4175920205&fm=20"></p><p>现在我来聊一下我的心路历程：</p><p><strong>Q: 首先呢，我以为是前端页面报错！</strong></p><p>因为正常的页面无法跳转，我怀疑大概率是 js 的某些逻辑出错，这在兼容性的问题上是经常出现的。但，ios 的设备调试是挺坑爹的，况且还是 ipad ，通过数据线来进行 safari 调试是行不通的，于是只能通过无线代理的方式来调试了。一顿操作，装证书、设代理，发请求，但是页面控制台真的是 空 空 空空如也</p><p>并没有 js 报错，看来并不是某些方法兼容性的问题。</p><p>又检查了一下请求，看出了一些端倪，竟然请求没有返回值。</p><p><strong>Q: 那我觉得，应该是后端接口的问题了！</strong></p><p>后端是用 node + koa 写的，我们的接口是这样的，前端发一个登陆请求，然后我们会去验证登陆，如果登陆成功，会在客户端写入唯一登陆的 accesstoken 到cookie中，后续的请求都需要用到这个登陆的 accesstoken。经过我一顿查找，发现了可能是cookie的写入出现了问题：使用 <code>ctx.cookies.set(&#39;ss&#39;,&#39;bb&#39;)</code> 并没有生效。</p><p><strong>Q: 那么是所有的设备都没有生效吗？</strong></p><p>为了不影响测试，我本地起了个服务，然后借用同事的 iOS10 的设备进行测试发现了同样不行（<strong>最后证明就是这一环节出了问题，是网络堵塞引起的不行</strong>）。当然安卓都是正常的。</p><p>于是我自以为是的得出了一个结论：<strong>这应该是 ios10 设备独有的一个 cookie 的 bug。</strong></p><p>我疯狂的在 github issue 和 Stack Overflow 寻找相关的答案，有提到 <code>写入 cookie 时使用中文字符造成写入失败的</code>、也有说 <code>iOS10 的隐私策略的问题</code>。不过好像都与我的关系不大。</p><p><strong>Q: 难道并不是兼容性问题？</strong></p><p>我又重新检查了代码，最后经过一段手动测试，发现是 cookie 过期时间设置的问题。问题描述如下： 当我设置过期时间为几个小时的时间时，就不能正常写入 cookie。如果时间大于一天，就可以正常写入，也算勉强解决了。</p><p>我下意识的瞄了一下手里的iPad，时间显示是正常的（坑在此，时间是正常，但是日期不是）。我又开始怀疑是时区设置的问题，但是也是不求甚解。</p><p><strong>Q: 好吧，估计只能抽空看下源码了……</strong></p><p>折腾了这么个半天时间，发现了确实是 cookie 设置的问题，于是通过重新设置cookie的有效时间解决了。虽然算是勉强解决了，但是这个解决办法很让人不爽，因为我还是在迷惑的状态。就在我心如死灰的时候，我无意中打开了 ipad 的日历，发现竟然比实际多一天，但是时间却是一分一秒不差。</p><p>WTF!!!难道是日期设置的问题？</p><p>最后，测试了几次，果然是日期设置的问题。</p><p><img src="http://ws3.sinaimg.cn/large/9150e4e5ly1ffxpkw13rlj20hn0jfab8.jpg"></p><p><strong>最后，bug 终于解决了</strong></p><p>其实问题出现的原因很简单，和什么兼容性一点关系都没有，纯粹是自己的意淫。其实就是当我设置 cookie 为一天之内的过期时间的情况，因为设备的日期时间刚好大于实际的一天，那造成的情况就是 cookie 刚写入了就因为过期被浏览器清除掉了。</p><p><img src="http://ws1.sinaimg.cn/large/9150e4e5ly1fjh9dobqr2j20hs0h140f.jpg"></p><p>真是一次令人捉急的经历！</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ios bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务 api GateWay 工具： kong</title>
      <link href="/2018/06/28/"/>
      <url>/2018/06/28/</url>
      
        <content type="html"><![CDATA[<h1 id="API-Gateway-工具-kong"><a href="#API-Gateway-工具-kong" class="headerlink" title="API Gateway 工具 kong"></a>API Gateway 工具 kong</h1><p><img src="http://ww1.sinaimg.cn/large/86c7c947gy1fsqtxszp0wj21h80j6772.jpg"></p><blockquote><p>项目需要，需要对微服务化下的 API 做统一管理，查阅相关资料，给出 kong + cassandra 的实现方案，中间也涉及到微服务以及 API Gateway 的相关知识。以下是关于研究过程中以及实施步骤中的总结笔记。</p></blockquote><h2 id="什么是-kong"><a href="#什么是-kong" class="headerlink" title="什么是 kong ?"></a>什么是 kong ?</h2><p>首先呢，kong 是一个基于 Nginx_Lua 模块写的高可用，易扩展由 Mashape 公司开源的 API Gateway 项目，如果你对 API Gateway 有什么误解，可以先来了解下 <a href="https://www.kancloud.cn/good-rain/micro-services/248957">什么是 API Gateway </a>，API Gateway 是服务于微服务架构的一种API解决方案。好像有点绕，举个例子简单来理解一下： </p><p>比如，我们的一个简单来自的购物操作，中间可能涉及到 购物车、下单、评论、快递服务等操作。在一个非微服务的架构里面，客户端想要完成整个购物流程，就需要常见的 REST 请求来获取数据，我们可能在服务层用了一些负载均衡，那么这些请求就会分发到多个应用实例中并作出响应。</p><p>但是在一个微服务的体系中，购物车、下单、评论等，这样都可以独立成一个服务出来，也就是我们说的微服务。客户端想要完成整个购物流程，可以去单独的请求某个服务来获取数据。听起来可能有点怪怪的，我为了完成一个购物操作，从之前的一次请求变成了n次请求，毕竟我们知道，客户端频繁的请求的成本是不低的。所以，直接由客户端发n次请求这种事，一般来说是没人会这么干的，那么怎么干呢，就是 API Gateway 来处理了。API Gateway 其实也是一个服务器，所有的请求首先会经过这个网关。这里做 权限控制，安全，负载均衡，请求分发，监控等操作。这里也许放个官网的图会容易解释些：</p><p><img src="http://ww1.sinaimg.cn/large/86c7c947gy1fsqtusglhvj21s40iojub.jpg"></p><p>我们不去讨论微服务和 API Gateway 的好坏，但是 kong 确实就是为微服务而生，并且做着这么一件事情的。相关的 API Gateway 方案还有 <a href="https://www.nginx.com/solutions/api-gateway/">nginx 自家的 API Gateway 工具：nginx plus</a>。</p><h2 id="kong-的安装-？"><a href="#kong-的安装-？" class="headerlink" title="kong 的安装 ？"></a>kong 的安装 ？</h2><p>现在 kong 的版本已经迭代到 0.13.x 了，推荐使用新版来实践。</p><p>关于 kong 的安装，官网给出了基于多种平台的安装方案，可以在 <a href="https://konghq.com/install/">这里</a> 查看。比如我个人的平台是 macOS ，就可以按照官方给出的方案，很方便的使用 brew 来安装 kong 。不过需要注意的是，kong 是不支持 Windows平台 的安装的，不接受提问（因为我也不知道为啥没有）。但是没有不代表不可以用，因为 kong 是支持 docker 部署的，而 docker 是支持 Windows 的，所以你可以安装 docker 来部署 kong，并且，从我个人实践的过程中来看，使用 docker 是最方便的部署方式。下面就介绍使用 docker 的部署方式：</p><p>对了，首先，你得安装个 <a href="https://www.docker.com/">docker</a>。</p><p><strong>第一步：创建一个 docker 私有网络</strong></p><p>kong-net 是网络标识名字，最好个性一些。</p><pre><code>docker network create kong-net</code></pre><p><strong>第二步：启动或配置一个 cassandra (or PostgreSQL) 服务器</strong></p><p>如果你还没有 cassandra 服务，那么你可以启动一个,比如下面就是启动了一个 cassandra v3 的docker container，并且映射了9042端口，那么你最后暴露出来的 cassandra 服务就是 <code>localhost:9042</code>，记下这个地址，后面会用到。</p><pre><code>docker run -d --name kong-database \              --network=kong-net \              -p 9042:9042 \              cassandra:3</code></pre><p>当然，如果你已经有了现成的 Cassandra 服务了，那么就不用这一步了，记下服务地址，后面会用到。</p><p><strong>第三步：kong 启动准备，数据库准备</strong></p><p>官方把这一步叫做 migrations，你可以把这一步理解为修改 kong 配置。</p><pre><code>docker run --rm \    --network=kong-net \    -e &quot;KONG_DATABASE=cassandra&quot; \    -e &quot;KONG_CASSANDRA_CONTACT_POINTS=xxx&quot; \    -e &quot;KONG_CASSANDRA_PORT=9042&quot;\    -e &quot;KONG_CASSANDRA_KEYSPACE=kong&quot;\    -e &quot;KONG_DB_UPDATE_PROPAGATION=10&quot;\    kong:latest kong migrations up</code></pre><p>这一步的动作其实就是创建一个临时用来写配置的容器来进行写配置。其中 xxx 就是第二步中的 Cassandra 地址。如果你需要使用 PostgreSQL 服务，只需要设置相应的参数就可以了,具体可以参考<a href="https://docs.konghq.com/0.13.x/configuration/">kong configuration</a>，官方 github 也给出了一个模板配置文件供参考：<a href="https://github.com/Kong/kong/blob/master/kong.conf.default">kong.conf.default</a>。 需要注意的就是，如果使用上面参数的形式来配置，那么大概就是这么的对比关系： <code>db_update_propagation =&gt; KONG_DB_UPDATE_PROPAGATION</code>。</p><p><strong>第四步：启动 kong</strong></p><p>启动 kong ，并对外暴露 8001 端口，最终的 <code>host:8001</code> 即 kong 对外暴露的网关 url 。</p><pre><code>docker run -d --name kong \    --network=kong-net \    -e &quot;KONG_DATABASE=cassandra&quot; \    -e &quot;KONG_CASSANDRA_CONTACT_POINTS=xxx&quot; \    -e &quot;KONG_CASSANDRA_PORT=9042&quot;\    -e &quot;KONG_CASSANDRA_KEYSPACE=kong&quot;\    -e &quot;KONG_DB_UPDATE_PROPAGATION=10&quot;\    -e &quot;KONG_PROXY_ACCESS_LOG=/dev/stdout&quot; \    -e &quot;KONG_ADMIN_ACCESS_LOG=/dev/stdout&quot; \    -e &quot;KONG_PROXY_ERROR_LOG=/dev/stderr&quot; \    -e &quot;KONG_ADMIN_ERROR_LOG=/dev/stderr&quot; \    -e &quot;KONG_ADMIN_LISTEN=0.0.0.0:8001, 0.0.0.0:8444 ssl&quot; \    -p 8000:8000 \    -p 8443:8443 \    -p 8001:8001 \    -p 8444:8444 \    kong:latest</code></pre><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>当然，上面的 kong 只是部署在了一个结点，如果是一个集群，需要部署在多个结点的话，可以参考<a href="https://docs.konghq.com/0.13.x/clustering/#multiple-nodes-kong-clusters">这里</a>。</p><h2 id="kong-可视化界面"><a href="#kong-可视化界面" class="headerlink" title="kong 可视化界面"></a>kong 可视化界面</h2><p>当成功部署了 kong 之后，我们可以使用 curl 来测试是否生效，比如我的 kong 是部署在本机，那么执行：</p><pre><code>curl http://localhost:8001</code></pre><p>那么就会得到当前 kong 结点的配置信息。更多操作可以可以参考<a href="https://docs.konghq.com/0.13.x/admin-api/">这里</a>。</p><p>但是我们有一种更好的办法是，替换终端操作使用 kong 的可视化界面来管理 kong 。目前关于 kong 使用比较多的开源可视化工程模板有两个，一个是 <a href="https://github.com/PGBI/kong-dashboard">koa-dashboard</a>，使用 angular 和 koa ,一个是 <a href="https://github.com/pantsel/konga">konga</a>，使用 sails 和 angular ，推荐使用前者。使用方法如下：</p><p><strong>1. 下载</strong></p><p>下载源代码: <code>git clone https://github.com/PGBI/kong-dashboard.git</code></p><p><strong>2. 安装</strong></p><p>安装方式有两种，一种是使用 npm ，但是需要全局安装 kong-dashboard，这样对于测试生产主机不友好，所以选择第二种，打包 docker 来安装。如果我们想要直接使用，并且部署的主机可以访问 docker 官方镜像仓库，那么执行：</p><pre><code>docker run --rm -p 8080:8080 pgbi/kong-dashboard start \  --kong-url http://locahost:8001\  --basic-auth admin=123456</code></pre><p><a href="http://locahost:8001/">http://locahost:8001</a> 可以换成自己的 kong 对外暴露的 url。</p><p>但是，如果说要部署的主机存在某些限制或者我们想自己定制 dashboard 的源代码，我们可以自己打包镜像的方式来操作。在源代码工程目录下执行 </p><p><code>docker build -t xxxx.com/kong-dashboard .</code></p><p>（这样做的原因是，一般各家公司都有自己的 docker registry，我们可以更改 Dockerfile 来定制我们自己的镜像），然后执行</p><pre><code>docker push xxxx.com/kong-dashboard</code></pre><p>这样我们部署的时候，就可以直接执行：</p><pre><code>docker run --rm -p 8080:8080 xxxx.com/kong-dashboard start \  --kong-url http://locahost:8001\  --basic-auth admin=123456</code></pre><p>最后打开浏览器打开 <code>xxx:8080 </code>,看到的效果大概是这个样子的：</p><p><img src="http://ww1.sinaimg.cn/large/86c7c947gy1fsquhlol2dj22wi1o2qdu.jpg"></p><p><strong>大功告成！</strong></p><h2 id="遇到的问题？"><a href="#遇到的问题？" class="headerlink" title="遇到的问题？"></a>遇到的问题？</h2><p>kong 的整体部署过程还是很和谐，并没有什么大问题，倒是在 docker 的使用出现了一些小问题。</p><p><strong>1. kong-dashboard 版本问题</strong></p><p>kong-dashboard docker镜像的版本并不是最新的，最新的已经支持到了 V3.3， 而 <code>pgbi/kong-dashboard</code> 是 V3.0 ，功能上还是差了一些的。</p><p>在部署主机没有外网访问权限的情况下，最后我使用了离线打包 docker 的方式来获取最新版，详细操作如下：</p><ol><li>本地打包： <code>docker save -o xxxx.docker image(镜像名称)</code> ， xxxx.docker 是输出的离线文件，</li><li>传输至远程主机： 使用 rsync 传输至远程主机： <code>rsync -cavzP ./xxxx.docker root@host:/path</code>，</li><li>装再: 进入到 xxxx.docker 路径并执行： <code>docker save -i xxxx.docker</code></li></ol><p>之后本机就成功装在最新版本的 kong-dashboard 镜像了。 </p><p><strong>2. cassandra 可视化管理工具</strong></p><p>在此之前，其实对 cassandra 并未耳闻，简单了解后知道是一套开源分布式 NoSQL 数据库系统。习惯了 mongo 的 studio 3T ，redis 的 RDM 的数据可视化，关于 cassandra 的可视化管理工具貌似并不多，特别是针对 macos 系统的。</p><p>查阅相关资料后，最后选择了 <a href="https://tableplus.io/">tableplus</a>， 免费版虽有限制，但也够用。</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> kong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次有关于逼格的折腾笔记</title>
      <link href="/2018/03/22/"/>
      <url>/2018/03/22/</url>
      
        <content type="html"><![CDATA[<h1 id="iterm2-折腾笔记"><a href="#iterm2-折腾笔记" class="headerlink" title="iterm2 折腾笔记"></a>iterm2 折腾笔记</h1><h2 id="以下是废话"><a href="#以下是废话" class="headerlink" title="以下是废话"></a>以下是废话</h2><blockquote><p>emmm……，这其实不是一篇技术文，因为没有代码、没有逻辑、没有人气，纯粹是小部分人基于逼格的一些尝试（当然具体有没有还要另说），所以就当我胡说八道，值不值得看自己心里琢磨。</p></blockquote><p>起因是这样的，浏览 v2ex 时看到一篇帖子：<a href="https://www.v2ex.com/t/439713?p=2">看看你们炫酷的命令行界面</a>，回复不多，但是看得我春心荡漾。回复大概是这样子的，</p><p><img src="http://wx1.sinaimg.cn/mw690/8849a1a4gy1fpk9383mylj20sl0ixq3r.jpg"></p><p>或者是这个样子的，</p><p><img src="https://ws2.sinaimg.cn/large/bb4bb99egy1fpku9yt9f8j211x0lbgms.jpg"></p><p>再或者是这个样子的，</p><p><img src="https://camo.githubusercontent.com/b5d7eb49a30bfe6bdb5706fa3c9be95fe8e5956e/687474703a2f2f67696679752e636f6d2f696d616765732f70396b6e65772e676966"></p><p>总之，看的我是蠢蠢欲动。在此之前，我的 terminal 的配色就是简单的 iterm2 + zsh + oh-my-zsh ，设置了简单的颜色主题，其实已经很漂亮了，大致效果是下面这个样子的：</p><p><img src="http://img.blog.csdn.net/20170725190119447?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzcwNzI0OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p><p>然而，对比之下，就发现了：我为毛没有图标，简直就是高富帅和穷屌的对比啊！！ 加上之前的配色方案已经用了半年之久（相当的审美疲劳），于是决定果断换掉。</p><h2 id="划重点（以上是废话）"><a href="#划重点（以上是废话）" class="headerlink" title="划重点（以上是废话）"></a>划重点（以上是废话）</h2><p>我喜欢对做每一件事情之前进行调研，研究其充分的可能，然后再做行动。同时，加上我实践之后得出的真知，在这里先画个重点：</p><ol><li>只适用于 MacOS。首先 Windows 没有 iterm2(当然也不仅仅是用在 iterm2上面)，其次是因为 macOS 所搭载的平台（MacBook，iMac）都是对高分辨率有强迫症的，所以才会有好的视觉效果，Windows 就暂时先放一放。</li><li>好看确实好看，不一定好用。 不好用体现在两个方面，布局和性能。在布局上，或许只有在全屏下才能看到最佳的视觉效果，因为行内有大量的内容区域被占用，大大压榨了可输入区域的大小，虽然有些主题可以设置另起一行来选择输入，但是体验是相当差的。在性能上，对于一些特殊的主题，因为会实时的显示本地的内存占用、时间时期等信息，每次执行命令都会执行一遍，不卡才怪（反正我在使用过程中发现了绝对能够影响我感官的卡顿感）。</li></ol><p>如果你觉得以上的问题还 OK，那就继续看下去。现在开始折腾……</p><h2 id="开始折腾"><a href="#开始折腾" class="headerlink" title="开始折腾"></a>开始折腾</h2><p>其实配置的方法很简单，比较纠结的地方在于怎么去找适合的主题，于是我开始 深入浅出 GitHub……</p><h3 id="关于主题选择"><a href="#关于主题选择" class="headerlink" title="关于主题选择"></a>关于主题选择</h3><p>其实 iterm 的<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Themes">主题</a>有很多，我们可以随便选择一种。默认的主题是 robbyrussell ，我们可以通过 <code>vi ~/.zshrc</code> 命令然后找出 ZSH_THEME&#x3D;”xxx” 的语句，xxx 就是默认主题的配置。</p><p>在官方给出的<a href="https://github.com/agnoster/agnoster-zsh-theme">主题列表</a>里，有一款主题其实很不错（其他都丑）：agnoster，效果如下：</p><p><img src="https://cloud.githubusercontent.com/assets/2618447/6316862/70f58fb6-ba03-11e4-82c9-c083bf9a6574.png"></p><p>配置官方的主题方案很简单，可以参考此篇<a href="https://www.jianshu.com/p/e42c7e7a4253">博客</a>。</p><p>emmm…… 这看起来和开篇的效果图还不太一样啊。当然，除了官方的主题，还有一些第三方的主题，比如我今天要用的 powerlevel9k，在搭配效果上还会有更多的方案。</p><h3 id="powerlevel9k"><a href="#powerlevel9k" class="headerlink" title="powerlevel9k"></a>powerlevel9k</h3><p>对于 powerlevel9k，其实已经有了一个还不错的生态圈了，毕竟GitHub也是有 4k+ 的存在。在官方的说明中已经有了一份很详细的安装文档。可以戳<a href="https://github.com/bhilburn/powerlevel9k">这里</a>查看。</p><p>这里就不赘述安装细节做无用功了。文档是英文的，但是也很容易可以看懂，大致意思就是 powerlevel9k 提供了针对不同平台的主题安装方案，对于一些特殊的主题效果，还需要安装一些特殊的字体用作图标展示，在这里都可以选择安装，比如我选择的就是 zsh 的主题安装 和 Nerd-Fonts 的字体安装方案。同时，powerlevel9k 也提供了社区分享的一些不错的<a href="https://github.com/bhilburn/powerlevel9k/wiki/Show-Off-Your-Config">配色方案</a>，我们可以直接拿来用,嘿嘿……</p><p><img src="http://ww1.sinaimg.cn/large/86c7c947gy1fplepu0f5dj20hs0cmdho.jpg"></p><p>自己可以选择自己喜欢的主题和字体。安装完成之后，只需要在 zsh 的配置文件中配置一下即可：</p><p>&#96;&#96;&#96;</p><ol><li>打开 zsh 配置文件</li></ol><p>vi ~&#x2F;.zshrc</p><ol start="2"><li>写入配置方案， 主题选择你安装的主题，配色方案可以去上面社区分享的列表去找，比如我的</li></ol><p>ZSH_THEME&#x3D;”powerlevel9k&#x2F;powerlevel9k”</p><h1 id="ZSH-THEME-x3D-”agnoster”"><a href="#ZSH-THEME-x3D-”agnoster”" class="headerlink" title="ZSH_THEME&#x3D;”agnoster”"></a>ZSH_THEME&#x3D;”agnoster”</h1><p>POWERLEVEL9K_MODE&#x3D;’nerdfont-complete’</p><p>POWERLEVEL9K_SHORTEN_DIR_LENGTH&#x3D;2<br>POWERLEVEL9K_SHORTEN_STRATEGY&#x3D;”truncate_middle”<br>POWERLEVEL9K_CONTEXT_DEFAULT_BACKGROUND&#x3D;”000”<br>POWERLEVEL9K_CONTEXT_DEFAULT_FOREGROUND&#x3D;”007”<br>POWERLEVEL9K_DIR_HOME_BACKGROUND&#x3D;”001”<br>POWERLEVEL9K_DIR_HOME_FOREGROUND&#x3D;”000”<br>POWERLEVEL9K_DIR_HOME_SUBFOLDER_BACKGROUND&#x3D;”001”<br>POWERLEVEL9K_DIR_HOME_SUBFOLDER_FOREGROUND&#x3D;”000”<br>POWERLEVEL9K_NODE_VERSION_BACKGROUND&#x3D;”black”<br>POWERLEVEL9K_NODE_VERSION_FOREGROUND&#x3D;”007”<br>POWERLEVEL9K_NODE_VERSION_VISUAL_IDENTIFIER_COLOR&#x3D;”002”<br>POWERLEVEL9K_LOAD_CRITICAL_BACKGROUND&#x3D;”black”<br>POWERLEVEL9K_LOAD_WARNING_BACKGROUND&#x3D;”black”<br>POWERLEVEL9K_LOAD_NORMAL_BACKGROUND&#x3D;”black”<br>POWERLEVEL9K_LOAD_CRITICAL_FOREGROUND&#x3D;”007”<br>POWERLEVEL9K_LOAD_WARNING_FOREGROUND&#x3D;”007”<br>POWERLEVEL9K_LOAD_NORMAL_FOREGROUND&#x3D;”007”<br>POWERLEVEL9K_LOAD_CRITICAL_VISUAL_IDENTIFIER_COLOR&#x3D;”red”<br>POWERLEVEL9K_LOAD_WARNING_VISUAL_IDENTIFIER_COLOR&#x3D;”yellow”<br>POWERLEVEL9K_LOAD_NORMAL_VISUAL_IDENTIFIER_COLOR&#x3D;”green”<br>POWERLEVEL9K_RAM_BACKGROUND&#x3D;”black”<br>POWERLEVEL9K_RAM_FOREGROUND&#x3D;”007”<br>POWERLEVEL9K_RAM_VISUAL_IDENTIFIER_COLOR&#x3D;”001”<br>POWERLEVEL9K_RAM_ELEMENTS&#x3D;(ram_free)<br>POWERLEVEL9K_TIME_BACKGROUND&#x3D;”black”<br>POWERLEVEL9K_TIME_FOREGROUND&#x3D;”007”<br>POWERLEVEL9K_TIME_FORMAT&#x3D;”%D</p>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iterm2 </tag>
            
            <tag> 为逼格而生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tcp三次握手与四次分手</title>
      <link href="/2018/02/28/"/>
      <url>/2018/02/28/</url>
      
        <content type="html"><![CDATA[<h1 id="理解-HTTP-协议以及-TCP-三次握手与四次分手的过程"><a href="#理解-HTTP-协议以及-TCP-三次握手与四次分手的过程" class="headerlink" title="理解 HTTP 协议以及 TCP 三次握手与四次分手的过程"></a>理解 HTTP 协议以及 TCP 三次握手与四次分手的过程</h1><h2 id="理解-HTTP-协议"><a href="#理解-HTTP-协议" class="headerlink" title="理解 HTTP 协议"></a>理解 HTTP 协议</h2><p>超文本传输 ​​ 协议（HTTP）是用于传输诸如 HTML 的超媒体文档的应用层协议，最顶层的协议。<strong>HTTP 是无状态协议</strong>，意味着服务器不会在两个请求之间保留任何数据（状态）。</p><p><strong>关于无状态的理解</strong></p><p>可以理解为 HTTP 是没有上下文的，HTTP 无法保存连接双方的状态信息。基于此，知乎上有看到一个很直观的白话例子：</p><p>参考：<a href="https://www.zhihu.com/question/23202402/answer/300614865">HTTP 是一个无状态的协议。这句话里的无状态是什么意思？</a></p><table><thead><tr><th align="left">有状态</th><th align="left">无状态</th><th align="left">使用 cookie</th></tr></thead><tbody><tr><td align="left">A：你今天中午吃的啥？</td><td align="left">A：你今天中午吃的啥</td><td align="left">A：你今天中午吃的啥</td></tr><tr><td align="left">B：吃的大盘鸡</td><td align="left">B：吃的大盘鸡。</td><td align="left">B：吃的大盘鸡。</td></tr><tr><td align="left">A：味道怎么样呀？</td><td align="left">A：味道怎么样呀？</td><td align="left">A：味道怎么样呀？</td></tr><tr><td align="left">B：还不错，挺好吃的。</td><td align="left">B：？？？啊？啥？啥味道怎么样？</td><td align="left">B：还不错，挺好吃的</td></tr></tbody></table><h2 id="TCP-三次握手与四次分手"><a href="#TCP-三次握手与四次分手" class="headerlink" title="TCP 三次握手与四次分手"></a>TCP 三次握手与四次分手</h2><p>TCP 建立连接的时候需要三次握手，断开连接需要四次分手，这个过程是比较抽象的。</p><p>整个过程简单白话一下就是：</p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a><strong>三次握手</strong></h3><ol><li>客户端写了一封情书： 我中意你啊（建立连接的请求）</li><li>服务端收到了这封情书的回复：哇，我也中意你啊，mua</li><li>客户端收到了服务端的 mua ：好啊，那我们就在一起吧（真正建立连接）</li></ol><p>当然上面这是正常的情况，如果遇到情书发错人（连接出错）的情况，服务端就懒得理了，然后双发就不可能在一起（建立连接）。</p><p><strong>为什么 TCP 连接需要三次握手</strong></p><p>当然其实会有更多的人疑问，为什么 TCP 连接需要三次握手而不是两次，因为按照上面的意思，客户端来一句：在一起， 服务端回一个：好， 就可以了啊，为什么客户端还要多此一举回复一个“我也好”呢。其实原因很简单，跟 TCP 的特性有关，TCP 通道是不可靠的，而三次握手是满足通道安全的最小握手次数。继续用上面的例子来分析下：</p><p>先假设只有两次握手的情况：</p><ol><li>客户端写了一封情书： 我中意你啊（建立连接的请求），但是因为某些原因，邮局放假啦，你的情书被搁置在路上了</li><li>客户端没有收到回复，于是又写了一封情书：我真的好中意你啊（建立连接的请求）</li><li>服务端收到了这封情书的回复：哇，我也中意你啊，mua（建立连接）</li><li>到这时，客户端和服务端已经可以愉快的玩耍了。但是忽然，客户端写的第一封情书也到了，服务端看到了，依然回复了句： 死鬼，我知道了</li><li><strong>因为 HTTP 是无状态的，客户端不知道服务端回复的是啥，就没理。</strong></li><li><strong>服务端就在一直等待中：这个死鬼的情书到底是写给谁，怎么不回复我。于是服务端憔悴至死（资源浪费）</strong></li></ol><p>然后是三次握手的情况：</p><ol><li>客户端写了一封情书： 我中意你啊（建立连接的请求），但是因为某些原因，有句放假啦，你的情书被搁置在路上了</li><li>客户端没有收到回复，于是又写了一封情书：我真的好中意你啊（建立连接的请求）</li><li>服务端收到了这封情书的回复：哇，我也中意你啊，mua</li><li><strong>客户端收到了服务端的 mua ：好啊，那我们就在一起吧（真正建立连接）</strong></li><li>到这时，客户端和服务端已经可以愉快的玩耍了。但是忽然，客户端写的第一封情书也到了，服务端看到了，依然回复了句： 死鬼，我知道了</li><li><strong>客户端一看，这是错了： 这是情书发错了，别再等了</strong></li></ol><p>三次握手的基本情况都老实交代了了，就那样。</p><h3 id="四次分手"><a href="#四次分手" class="headerlink" title="四次分手"></a><strong>四次分手</strong></h3><p>然后是四次分手，这个就简单的多：</p><ol><li>客户端和服务端腻歪了，就说要分手，客户端：分手吧 （关闭连接的请求）</li><li>服务端：分就分，但是还有你的一些破东西，还给你（传递向客户端待发送的数据）</li><li>客户端收到回复了，就原地待命</li><li>服务端数据发送完了：好了，都扔了（数据发送完毕）</li><li>客户端接收到数据，然后给个回复：好的，我知道了，拜拜。</li></ol><p>以上都是抖机灵的理解。其实 TCP 的三次连接和四次分手要复杂的多，可以参考以下正经的博客：</p><ul><li><a href="https://github.com/jawil/blog/issues/14#issuecomment-369106942">通俗大白话来理解 TCP 协议的三次握手和四次分手</a></li><li><a href="http://www.cnblogs.com/lamian/p/3983497.html">关于 TCP 的三次握手和四次分手（整理）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ng2体验报告</title>
      <link href="/2018/02/05/"/>
      <url>/2018/02/05/</url>
      
        <content type="html"><![CDATA[<h1 id="ng2-体验报告、总结"><a href="#ng2-体验报告、总结" class="headerlink" title="ng2 体验报告、总结"></a><strong>ng2 体验报告、总结</strong></h1><blockquote><p>当然，现在 angular 最新的版本已经出到 5.0 了，现在才来说 ng2 有点老套了，只是最近忽然的从 react 的项目组转到了做 angular v2 (ng2) 的项目组，同时对谷歌和微软的”孩子”也比较感兴趣，所以还是有必要好好学习一下的。</p><p>上手了一阵子，大概摸清了 ng2 的套路，其实在此之前，对于习惯了 React、 Vue 开发模式的我来说，对于 ng2 是有一定的误解的。过去的我一直以为 ng2 只是简单的视图框架，就是一个简单的模板系统，现在看来我是错了，较之于 React、 Vue 复杂的项目构建来说， ng2 才是真正的框架啊，如果你有一定的后端基础，你一定能很快的理解 ng2 知识体系， 而且你也会明白 ng2 作为一个框架对于开发效率的提升。</p></blockquote><h2 id="关于学习网站"><a href="#关于学习网站" class="headerlink" title="关于学习网站"></a><strong>关于学习网站</strong></h2><p>学习 ng2 最好的就是看官网了，当然所有的语言都是一样的，以下是几个可能需要经常去逛的网站。</p><ol><li><a href="https://github.com/angular/angular-cli/blob/master/README.md">angular-cli 脚手架工具，快速构建项目；</a></li><li><a href="https://v2.angular.cn/docs/ts/latest/quickstart.html">angular 官网，最新的已经是 V5 版本了，可以继续深入学习；</a></li><li><a href="http://cn.rx.js.org/">Rx.js 中文速查手册；</a></li><li><a href="https://www.tslang.cn/docs/home.html">javascript 的超集 typescript；</a></li><li><a href="">待补……</a></li></ol><h2 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a><strong>重要概念</strong></h2><p>有关于 ng2 几个重要的概念如下：</p><ul><li>脚手架 （ scaffold ）</li><li>指令（ directive ）</li><li>管道 （ pipe ）</li><li>路由 （ router ）</li><li>父子组件通信 （ @input &amp; @output ）</li><li>模块 （ model ）</li><li>服务 （ service ）</li><li>Rxjs （ Oberverable ）</li><li>依赖注入 （ injectable ）</li></ul><p>当然，赘述官方的文档不是我想要的，我更希望通过我个人的理解来介绍这几个知识点（或许有错误）</p><h3 id="脚手架-（-scaffold-）"><a href="#脚手架-（-scaffold-）" class="headerlink" title="脚手架 （ scaffold ）"></a><strong>脚手架 （ scaffold ）</strong></h3><p>唠叨一句：一般来说，脚手架这个东西，只有新手小白或者大牛会喜欢用，往往处于中间层的大佬们是比较鄙视的，因为这让程序变得没有技术含量，或者，被一些低级的脚手架给坑到。不过话说回来，使用好的脚手架的确能让让你的开发更加幸福，与其打开另一个文件复制代码，为何不让脚手架来给你生成呢。</p><p>ng2 (angular) 使用的脚手架是官方提供的 angular-cli ，常用的几个操作如下：</p><table><thead><tr><th align="left">生成对象</th><th align="left">命令</th><th align="left">注意事项</th></tr></thead><tbody><tr><td align="left">project</td><td align="left">ng new PROJECT-NAME</td><td align="left">生成新项目</td></tr><tr><td align="left">debug</td><td align="left">ng serve –host 0.0.0.0 –port 4201</td><td align="left">启动本地服务</td></tr><tr><td align="left">Component</td><td align="left">ng g component my-new-component</td><td align="left">生成 component</td></tr><tr><td align="left">Directive</td><td align="left">ng g directive my-new-directive</td><td align="left">生成<a href="https://angular.cn/guide/attribute-directives">自定义指令</a></td></tr><tr><td align="left">Pipe</td><td align="left">ng g pipe my-new-pipe</td><td align="left">生成<a href="https://angular.cn/guide/pipes#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E9%81%93">自定义管道</a></td></tr><tr><td align="left">Service</td><td align="left">ng g service my-new-service</td><td align="left">生成服务</td></tr><tr><td align="left">Class</td><td align="left">ng g class my-new-class</td><td align="left">生成类，几乎不用</td></tr><tr><td align="left">Guard</td><td align="left">ng g guard my-new-guard</td><td align="left">生成自定义路由向导，通用拦截等</td></tr><tr><td align="left">Interface</td><td align="left">ng g interface my-new-interface</td><td align="left">生成接口</td></tr><tr><td align="left">Enum</td><td align="left">ng g enum my-new-enum</td><td align="left">生成自定义枚举文件</td></tr><tr><td align="left">Module</td><td align="left">ng g module my-module</td><td align="left">生成自定义 module</td></tr></tbody></table><p>以上常用的几个命令参数同样的路径模式，意思就是你使用 <code>ng new ./test</code> 这样的格式也是可以的。</p><h3 id="指令（-directive-）"><a href="#指令（-directive-）" class="headerlink" title="指令（ directive ）"></a><strong>指令（ directive ）</strong></h3><p>指令系统是 angular 的一大特色，当你写 react 你一定特别希望也有自己的指令系统（当然这是玩笑话，因为 angular 是没有用 vdom 的）。 在开发过程中，你一定与遇到过如下的指令：</p><p><strong>常见结构性指令 <code>*ngIf *ngFor *ngSwitch</code> 的用法：</strong></p><pre><code>&lt;!-- 来自官网的英雄榜例子 --&gt;&lt;div *ngIf=&quot;hero&quot; &gt;xxx&lt;/div&gt;&lt;ul&gt;  &lt;li *ngFor=&quot;let hero of heroes&quot;&gt;xxx&lt;/li&gt;&lt;/ul&gt;&lt;div [ngSwitch]=&quot;hero?.emotion&quot;&gt;  &lt;app-happy-hero    *ngSwitchCase=&quot;&#39;happy&#39;&quot;    [hero]=&quot;hero&quot;&gt;&lt;/app-happy-hero&gt;  &lt;app-sad-hero      *ngSwitchCase=&quot;&#39;sad&#39;&quot;      [hero]=&quot;hero&quot;&gt;&lt;/app-sad-hero&gt;  &lt;app-confused-hero *ngSwitchCase=&quot;&#39;app-confused&#39;&quot; [hero]=&quot;hero&quot;&gt;&lt;/app-confused-hero&gt;  &lt;app-unknown-hero  *ngSwitchDefault           [hero]=&quot;hero&quot;&gt;&lt;/app-unknown-hero&gt;&lt;/div&gt;</code></pre><p><strong>ng-template ng-container</strong></p><p>还有一些常用来和结构性指令结合使用的语法，类似 <code>ng-template ng-container</code> 这些。 关于这两个模板语法，其实并不是有必须要使用的必要，但在很多时候，合理的使用可以让你的代码更加语义化，或者说更加优美。关于这两个，我怕我解释不当，官网给了两个比较好的例子：</p><ul><li><a href="https://angular.cn/guide/structural-directives#ng-template%E6%8C%87%E4%BB%A4">ng-template</a></li><li><a href="https://angular.cn/guide/structural-directives#%E4%BD%BF%E7%94%A8ng-container%E6%8A%8A%E4%B8%80%E4%BA%9B%E5%85%84%E5%BC%9F%E5%85%83%E7%B4%A0%E5%BD%92%E4%B8%BA%E4%B8%80%E7%BB%84">ng-container，消除 div 带来的副作用。</a></li></ul><p>当然，ng-template 另外的一个用途是 <a href="https://angular.cn/guide/dynamic-component-loader">作为动态组件加载器</a>。</p><p><strong>自定义指令</strong></p><p>用上面的脚手架生成最方便，也不容易出错。如下，生成一个 名为 check 的指令：</p><pre><code>&lt;!-- 执行 ng g directive --&gt;ng g directive&lt;!-- 自定义生成示例,并已在 当前 model 声明 --&gt;import &#123; Directive &#125; from &#39;@angular/core&#39;;@Directive(&#123;  selector: &#39;[check]&#39;&#125;)export class CheckDirective &#123;  constructor() &#123; &#125;&#125;&lt;!--在html模板中使用--&gt;&lt;input check=&quot;xxx&quot; &gt;</code></pre><p><strong>问题： 官文文档会看到一种 属性型指令 和 结构性指令 ，两者有什么区别？</strong></p><p>答： 结构型指令 — 通过添加和移除 DOM 元素改变 DOM 布局的指令，专注于布局，ngIf 这种。属性型指令 — 改变元素、组件或其它指令的外观和行为的指令，专注于内部属性，ngClass 这种。两种都可以自定义。</p><h3 id="管道-（-pipe-）"><a href="#管道-（-pipe-）" class="headerlink" title="管道 （ pipe ）"></a><strong>管道 （ pipe ）</strong></h3><p>如果习惯了 bash 命令的童鞋，一定对 管道 很熟悉， 你可能经常会见到 <code>ls xxx | grep xxx</code> 这种的写法，其实 ng 中的 管道 和这个其实是一个意思，写法都是一样的，通过 “|” 来分割，不过 ng 的明显要弱一些，ng 中管道的常见用法都是用来格式化钱币、数值精度、日期格式化这些操作。</p><p><strong>内置管道</strong></p><p>ng 内置了一些管道，比如 DatePipe、UpperCasePipe、LowerCasePipe、CurrencyPipe 和 PercentPipe。 它们全都可以直接用在任何模板中。</p><p>常见的<a href="https://angular.cn/api?type=pipe">内置管道</a>。<br><img src="http://ww1.sinaimg.cn/large/86c7c947gy1fo5d5hqq4fj21ic0hstar.jpg"></p><p><strong>自定义管道</strong></p><p>当内置的管道不能满足需求的时候，往往我们需要自定义自己的管道。我们可以使用 <code>ng g pipe my-new-pipe</code> 来生成自定义管道，如下是一个简单的 money 格式化的例子,对属于任意的数值，进行金额的精度控制，当然底层其实还是使用了内置的 DecimalPipe 。</p><pre><code>import &#123; Pipe &#125; from &#39;@angular/core&#39;;import &#123; DecimalPipe &#125; from &#39;@angular/common&#39;;@Pipe(&#123;  name: &#39;money&#39;&#125;)export class MoneyPipe &#123;  constructor(protected decimalPipe: DecimalPipe) &#123;  &#125;  public transform(value: any, digits?: string): string | null &#123;    value = parseFloat(value) || 0;    return this.decimalPipe.transform(value, digits);  &#125;&#125;</code></pre><p>在需要格式化金额的地方，比如我们要保留两位小数，我们可以这么用，<code>10.2222 | money:&#39;1.2-2&#39;</code>，具体第二个精度的使用方法可以<a href="https://angular.cn/api/common/DecimalPipe">参考</a>。</p><h3 id="路由-（-router-）"><a href="#路由-（-router-）" class="headerlink" title="路由 （ router ）"></a><strong>路由 （ router ）</strong></h3><p><strong>路由重定向</strong></p><p>可以这么写：</p><pre><code>export const routes: Routes = [  &#123; path: &#39;&#39;, redirectTo: &#39;A&#39;, pathMatch: &#39;full&#39; &#125;,  &#123; path: &#39;a&#39;, component: A &#125;,  &#123; path: &#39;b&#39;, component: B, child:&#123;      [      &#123; path: &#39;&#39;, redirectTo: &#39;b-a&#39;, pathMatch: &#39;full&#39; &#125;,      &#123; path: &#39;b-a&#39;, component: ba &#125;,      &#123; path: &#39;b-b&#39;, component: bb &#125;    ]  &#125; &#125;];</code></pre><p><strong>路由跳转</strong></p><p>可以这么写：</p><pre><code>&lt;a [routerLink]=&quot;[&#39;/a&#39;]&quot;&gt;a&lt;/a&gt;</code></pre><p>也可以这么写：</p><pre><code>this.router.navigate([&#39;/a&#39;]);</code></pre><p><strong>路由参数</strong></p><p>比如一个通知列表，点击不同的通知可以链接到不同的通知内容。</p><p>路由配置：</p><pre><code>export const routes: Routes = [  &#123; path: &#39;&#39;, redirectTo: &#39;A&#39;, pathMatch: &#39;full&#39; &#125;,  &#123; path: &#39;notice-list&#39;, component: A &#125;,  &#123; path: &#39;notice-content/:id&#39;, component: B &#125;];</code></pre><p>在 notice-list 设置路由跳转：</p><pre><code>this.router.navigate([&#39;/notice-content&#39; ，id]);this.router.navigate([&#39;/notice-content&#39;]，params);</code></pre><p>读取路由参数</p><pre><code>this.route.params.subscribe(params =&gt; &#123;   console.log(params[&#39;id&#39;]);&#125;);this.route.queryParams.subscribe(params =&gt; &#123;   console.log(params);&#125;);</code></pre><p><strong>路由拦截</strong></p><p>使用 <code>ng g guard login</code> 来快速生成。</p><pre><code>import &#123; CanActivate &#125; from &#39;@angular/router&#39;;import &#123; Injectable &#125; from &#39;@angular/core&#39;;import &#123; LoginService &#125; from &#39;./login-service&#39;;@Injectable()export class LoginRouteGuard implements CanActivate &#123;  constructor(private loginService: LoginService) &#123;&#125;  canActivate() &#123;    return this.loginService.isLoggedIn();  &#125;&#125;</code></pre><h3 id="父子组件通信-（-input-amp-output-）"><a href="#父子组件通信-（-input-amp-output-）" class="headerlink" title="父子组件通信 （ @input &amp; @output ）"></a><strong>父子组件通信 （ @input &amp; @output ）</strong></h3><p><strong>父组件向子组件传值</strong></p><p>父组件使用 <code>[data]=&#39;&#123;&#125;&#39;</code> 向子组件接收值，子组件通过 <code>@input() data</code> 来接收。</p><p><strong>子组件向父组件传值</strong></p><p>一般用于封装的组件。</p><p>在子组件中，使用</p><pre><code>@Output() outData = new EventEmitter&lt;string&gt;();……this.outData.emit(data);</code></pre><p>在父组件中获取,定义一个 getData 事件</p><pre><code>&lt;a (outData)=&#39;getData()&#39;&gt;&lt;/a&gt;</code></pre><h3 id="模块-model"><a href="#模块-model" class="headerlink" title="模块 ( model )"></a><strong>模块 ( model )</strong></h3><p>其实模块这个东西现在一点都不陌生，主流的编程框架都使用了模块化的编程方式。官方的文档是这么介绍的：</p><blockquote><p>Angular 模块是带有 @NgModule 装饰器函数的类。 @NgModule 接收一个元数据对象，该对象告诉 Angular 如何编译和运行模块代码。 它标记出该模块拥有的组件、指令和管道， 并把它们的一部分公开出去，以便外部组件使用它们。 它可以向应用的依赖注入器中添加服务提供商。</p></blockquote><p>我们理解起来就是，<strong>一个 Angular 模块 &#x3D; 接收元数据对象（metadata）+ 暴露部分便于外部组件访问。</strong> 如果不清楚什么是 <strong>元数据</strong> 的，可以看下官方的<a href="https://angular.cn/guide/metadata">介绍</a>。</p><h3 id="服务-service"><a href="#服务-service" class="headerlink" title="服务 ( service )"></a><strong>服务 ( service )</strong></h3><p>在后端编程中经常会用到 服务 ( service ), 我个人的理解是，服务就是可高度抽象且与业务逻辑耦合低的一系列操作。比如所有应用场景下的登录都需要一个公用的验证码，那么生成验证码的这个功能就可以抽象成为一个服务，服务不是必须的，但是适当写服务会让代码耦合度降低，是一种好的编程习惯。</p><p>截止到目前，我用的 ng 中的服务一般是用作某一个模块的请求封装，或者是日期的一些特殊操作，就像是一个工厂方法库一样。</p><h3 id="Rxjs-Oberverable"><a href="#Rxjs-Oberverable" class="headerlink" title="Rxjs ( Oberverable )"></a><strong>Rxjs ( Oberverable )</strong></h3><p>关于异步请求，ng2 自带的 http 模块返回的就是一个 Oberverable ，所以在项目中引入 Rx.js 自然无可厚非。官方评价为 promise 的超集，使用起来的确和 promise 很像，应该说是更加强大。但是正因为强大，导致要记的方法确实不少，直接戳一个<a href="http://cn.rx.js.org/">中文 api</a>。</p><h3 id="依赖注入-（-injectable-）"><a href="#依赖注入-（-injectable-）" class="headerlink" title="依赖注入 （ injectable ）"></a><strong>依赖注入 （ injectable ）</strong></h3><p>依赖注入其实之前也接触过一些， 依赖注入的目的在我看来有两个，一个是降低程序间的耦合性和复杂度，一个是减少复杂对象实例化带来的扩展问题。</p><p>关于依赖注入，这里有两篇不错的可以用来理解的文章（都是基于 java ）：</p><ul><li><a href="https://www.cnblogs.com/xxzhuang/p/5948902.html">spring 中的控制反转和依赖注入</a></li><li><a href="http://blog.csdn.net/bestone0213/article/details/47424255">依赖注入和控制反转</a></li></ul><p>当然 ng 中的依赖出入也差不多，而且实现方式也更优雅，东西挺多，可以看<a href="https://angular.cn/guide/dependency-injection#%E9%85%8D%E7%BD%AE%E6%B3%A8%E5%85%A5%E5%99%A8">官方文档</a>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>其实也是刚接触 angularv2 不久，自己也只是结合过去的知识对自己认为的 ng2 做了一个总结，认识还是比较粗鄙的，行文也比较乱。</p><p>写博客总结的这个习惯，希望自己可以继续坚持下去，即使只有自己看，hahah……</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于git：你应该知道的操作</title>
      <link href="/2018/01/23/"/>
      <url>/2018/01/23/</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/86c7c947gy1fnqmycqqxhj20xc0hi0tb.jpg"></p><h1 id="关于-git-你应该知道的操作"><a href="#关于-git-你应该知道的操作" class="headerlink" title="关于 git 你应该知道的操作"></a><strong>关于 git 你应该知道的操作</strong></h1><h2 id="git-的使用工具"><a href="#git-的使用工具" class="headerlink" title="git 的使用工具"></a><strong>git 的使用工具</strong></h2><p>首先有两个 可视化工具推荐 ：</p><ul><li><a href="https://www.gitkraken.com/features">gitkraken</a><br>一个新出的广受好评的git 可视化工具。有付费。</li><li><a href="https://www.sourcetreeapp.com/">sourcetree</a><br>一直在用，就是注册麻烦，需要翻墙。免费。</li></ul><p>个人在用第二个，sourcetree 日常使用可以说是hin方便了。当然，不想额外下软件的还可以使用 vscode 内置的 git 管理工具，同样的也是棒棒的。</p><h3 id="vscode-的git插件"><a href="#vscode-的git插件" class="headerlink" title="vscode 的git插件"></a>v<strong>scode 的git插件</strong></h3><p>当然我也在使用 vscode ，除了 vscode 自带的 git 支持，还可以安装以下的插件来更好的使用git：</p><ul><li><strong>Git Lens</strong> 官推的 git 插件，几乎该有的都有了，最强大的就是可以查看具体代码的具体变更,就像下面的这样：<br><img src="http://ww1.sinaimg.cn/large/86c7c947gy1fnqmw9ig2vj210u062jsa.jpg"><br>上一个让我感觉这么厉害的还是 visual studio 的内部集成的版本控制功能，但是 visual studio 实在是太大了。不过这个插件美中不足的就是查看历史实在是太丑了，所以有了下面的这个插件。</li><li><strong>git history</strong> 没毛病，这个插件就是让你的 提交历史 可以很直观的展示出来。</li></ul><p>不过，无论怎么说，git 原生命令还是要了解的，对学习和理解 git 的工作机制会很有帮助，当然对提升逼格也有成效。so,下面的部分主要是针对于 git 命令行的一些快捷操作。</p><h3 id="Mac下不可以使用的问题"><a href="#Mac下不可以使用的问题" class="headerlink" title="Mac下不可以使用的问题"></a><strong>Mac下不可以使用的问题</strong></h3><p><code>error: xcrun:error invalid actiive ... missing xcrun at ...</code></p><p>出现的原因是 git 依赖这个 xcode 的这个工具，所以要更新，一般会在更新系统之后出现。<br>解决办法就是：</p><pre><code>sudo xcode-select --install</code></pre><p>等待安装完成之后就可以了。</p><h2 id="git-命令行的一些骚操作"><a href="#git-命令行的一些骚操作" class="headerlink" title="git 命令行的一些骚操作"></a><strong>git 命令行的一些骚操作</strong></h2><p>下面总结一些 git 命令中可以快速提高效率和提升幸福度的操作。</p><h3 id="git配置别名"><a href="#git配置别名" class="headerlink" title="git配置别名"></a><strong>git配置别名</strong></h3><p>可以直接使用命令行修改全局配置，</p><pre><code>git config --global alias.st statusgit config --global alias.co checkoutgit config --global alias.ci commitgit config --global alias.br branchgit config --global alias.unstage &#39;reset HEAD&#39;git config --global alias.last &#39;log -1&#39;git config --global alias.lg &quot;log --color --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot;</code></pre><p>也可以通过 vim 更改配置文件来操作。</p><pre><code>vi ~/.gitconfigsource ~/.gitconfig</code></pre><p>两者的效果是一致的，可以通过 <code>git config --list</code> 查看添加的配置是否存在。 </p><p>该部分总结自 <a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375234012342f90be1fc4d81446c967bbdc19e7c03d3000">廖雪峰：git——配置别名</a>。</p><h3 id="（踩坑）常用的回退（救命）操作"><a href="#（踩坑）常用的回退（救命）操作" class="headerlink" title="（踩坑）常用的回退（救命）操作"></a><strong>（踩坑）常用的回退（救命）操作</strong></h3><p>如果你已经提交到暂存区了，你可以：</p><ul><li>撤销上次提交<br><code>git reset --hard &#39;指定的记录&#39;</code></li></ul><p>如果你想放弃本地修改，你可以：</p><ul><li>检出本地<br><code>git checkout &#39;branch&#39;</code></li></ul><p>如果你想修改上一次的提交信息，你可以：</p><ul><li>修改最后的一次提交<br><code>git commit --amend</code></li></ul><p>如果你在排查问题的时候，你可以</p><ul><li>使用 <code>git fetch</code> 替换 <code>git pull</code>, 因为<code>git pull = git fetch + merge local</code></li></ul><h3 id="（踩坑）git-上传文件忽略大小写"><a href="#（踩坑）git-上传文件忽略大小写" class="headerlink" title="（踩坑）git 上传文件忽略大小写"></a><strong>（踩坑）git 上传文件忽略大小写</strong></h3><p>好的约定其实比技术本身更重要，所以尽可能统一规范大小写，从而避免修改默认的配置。</p><pre><code>git config core.ignorecase falsegit config --global core.ignorecase false // 全局设置</code></pre><h3 id="git-comment-添加规范"><a href="#git-comment-添加规范" class="headerlink" title="git comment 添加规范"></a><strong>git comment 添加规范</strong></h3><pre><code>feat：新功能（feature）fix：修补bugdocs：文档（documentation）style： 格式（不影响代码运行的变动）rebuild：重构（即不是新增功能，也不是修改bug的代码变动）test：增加测试chore：构建过程或辅助工具的变动config: 配置example: git commit -m &quot;[feat] 新功能&quot;</code></pre><p>总结自 <a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html">阮一峰： Commit message 和 Change log 编写指南</a>。</p><h3 id="git-comment-添加表情"><a href="#git-comment-添加表情" class="headerlink" title="git comment 添加表情"></a><strong>git comment 添加表情</strong></h3><p>看到别人的comment history有那么多的卡哇伊的表情，是不是很羡慕，现在自己也可以做到。只需要在comment加入<code>:apple:</code>这样的代码，测试<code>GitHub</code>和<code>Gitlab</code>是可用的</p><pre><code>git commit -m &#39;:apple: i have a apple&#39;</code></pre><p><strong>表情列表如下：</strong></p><table><thead><tr><th align="left">emoji</th><th align="left">emoji 代码</th><th align="left">commit 说明</th></tr></thead><tbody><tr><td align="left">:art: (调色板)</td><td align="left"><code>:art:</code></td><td align="left">改进代码结构&#x2F;代码格式</td></tr><tr><td align="left">:zap: (闪电)<br>:racehorse: (赛马)</td><td align="left"><code>:zap:</code><br><code>:racehorse:</code></td><td align="left">提升性能</td></tr><tr><td align="left">:fire: (火焰)</td><td align="left"><code>:fire:</code></td><td align="left">移除代码或文件</td></tr><tr><td align="left">:bug: (bug)</td><td align="left"><code>:bug:</code></td><td align="left">修复 bug</td></tr><tr><td align="left">:ambulance: (急救车)</td><td align="left"><code>:ambulance:</code></td><td align="left">重要补丁</td></tr><tr><td align="left">:sparkles: (火花)</td><td align="left"><code>:sparkles:</code></td><td align="left">引入新功能</td></tr><tr><td align="left">:memo: (备忘录)</td><td align="left"><code>:memo:</code></td><td align="left">撰写文档</td></tr><tr><td align="left">:rocket: (火箭)</td><td align="left"><code>:rocket:</code></td><td align="left">部署功能</td></tr><tr><td align="left">:lipstick: (口红)</td><td align="left"><code>:lipstick:</code></td><td align="left">更新 UI 和样式文件</td></tr><tr><td align="left">:tada: (庆祝)</td><td align="left"><code>:tada:</code></td><td align="left">初次提交</td></tr><tr><td align="left">:white_check_mark: (白色复选框)</td><td align="left"><code>:white_check_mark:</code></td><td align="left">增加测试</td></tr><tr><td align="left">:lock: (锁)</td><td align="left"><code>:lock:</code></td><td align="left">修复安全问题</td></tr><tr><td align="left">:apple: (苹果)</td><td align="left"><code>:apple:</code></td><td align="left">修复 macOS 下的问题</td></tr><tr><td align="left">:penguin: (企鹅)</td><td align="left"><code>:penguin:</code></td><td align="left">修复 Linux 下的问题</td></tr><tr><td align="left">:checkered_flag: (旗帜)</td><td align="left"><code>:checked_flag:</code></td><td align="left">修复 Windows 下的问题</td></tr><tr><td align="left">:bookmark: (书签)</td><td align="left"><code>:bookmark:</code></td><td align="left">发行&#x2F;版本标签</td></tr><tr><td align="left">:rotating_light: (警车灯)</td><td align="left"><code>:rotating_light:</code></td><td align="left">移除 linter 警告</td></tr><tr><td align="left">:construction: (施工)</td><td align="left"><code>:construction:</code></td><td align="left">工作进行中</td></tr><tr><td align="left">:green_heart: (绿心)</td><td align="left"><code>:green_heart:</code></td><td align="left">修复 CI 构建问题</td></tr><tr><td align="left">:arrow_down: (下降箭头)</td><td align="left"><code>:arrow_down:</code></td><td align="left">降级依赖</td></tr><tr><td align="left">:arrow_up: (上升箭头)</td><td align="left"><code>:arrow_up:</code></td><td align="left">升级依赖</td></tr><tr><td align="left">:construction_worker: (工人)</td><td align="left"><code>:construction_worker:</code></td><td align="left">添加 CI 构建系统</td></tr><tr><td align="left">:chart_with_upwards_trend: (上升趋势图)</td><td align="left"><code>:chart_with_upwards_trend:</code></td><td align="left">添加分析或跟踪代码</td></tr><tr><td align="left">:hammer: (锤子)</td><td align="left"><code>:hammer:</code></td><td align="left">重大重构</td></tr><tr><td align="left">:heavy_minus_sign: (减号)</td><td align="left"><code>:heavy_minus_sign:</code></td><td align="left">减少一个依赖</td></tr><tr><td align="left">:whale: (鲸鱼)</td><td align="left"><code>:whale:</code></td><td align="left">Docker 相关工作</td></tr><tr><td align="left">:heavy_plus_sign: (加号)</td><td align="left"><code>:heavy_plus_sign:</code></td><td align="left">增加一个依赖</td></tr><tr><td align="left">:wrench: (扳手)</td><td align="left"><code>:wrench:</code></td><td align="left">修改配置文件</td></tr><tr><td align="left">:globe_with_meridians: (地球)</td><td align="left"><code>:globe_with_meridians:</code></td><td align="left">国际化与本地化</td></tr><tr><td align="left">:pencil2: (铅笔)</td><td align="left"><code>:pencil2:</code></td><td align="left">修复 typo</td></tr></tbody></table><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a><strong>写在最后</strong></h2><p>骚操作那么多，肯定不止上面那些，所以本文还是会持续更新的。</p><p>最后，希望你和 git 过的幸福。</p>]]></content>
      
      
      <categories>
          
          <category> Github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 大小写问题踩坑笔记</title>
      <link href="/2018/01/23/"/>
      <url>/2018/01/23/</url>
      
        <content type="html"><![CDATA[<h2 id="关于-git-大小写问题的解决办法"><a href="#关于-git-大小写问题的解决办法" class="headerlink" title="关于 git 大小写问题的解决办法"></a><strong>关于 git 大小写问题的解决办法</strong></h2><h3 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a><strong>写在前面：</strong></h3><p>最近，在项目部署的时候，总是遇到一些很灵异的问题，比如在 merge 没有报错的情况下，文件没有更新， 特殊的文件突然被还原至之前的某个版本……最后发现问题所在，是之前的一次 <strong>文件名大小写</strong> 引起的问题。解决过程其实还是挺糟心的（自己埋的坑要自己填……），深刻体会到好的规范比好的技术其实更重要。同时也觉得，有必要记录一下，谨防下次掉进去。</p><h3 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现:"></a><strong>问题复现:</strong></h3><p><img src="http://ww1.sinaimg.cn/large/86c7c947gy1fnq9h4oitzj21si0rswmo.jpg"></p><ol><li>新建一个 <strong>a.js</strong> 文件(大小写不敏感的状态下)，并提交</li><li>修改本地 <strong>a.js</strong> 变为 <strong>A.js</strong>，文件内容无变更，无法提交</li><li>执行<code>git config core.ignorecase false</code>，修改 大小写敏感 规则，然后提交，查看结果，此时会存在 大小写 同时存在的文件</li><li>此时某种机缘下，再次执行 <code>git config core.ignorecase true</code>，大小写不敏感，</li><li>此时执行 <code>git push</code> ， 即把最新的更新都更新到了 <strong>a.js</strong> 中</li><li>此时再修改 大小写敏感规则为敏感， 执行 <code>git pull</code> ，并不会拿到最新的更新。比如自己想要的是第一次修改后的 A.js ，但是服务器有一个没有更新的 <strong>A.js</strong> 和 有更新的 <strong>a.js</strong>,而你只能拿到前者，所以就会遇到各种各样的坑……</li></ol><h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a><strong>解决办法：</strong></h3><p>执行<code>git config --global core.ignorecase false</code>，全局设置 <strong>大小写敏感</strong> 。</p><h4 id="1-文件变更比较少的情况"><a href="#1-文件变更比较少的情况" class="headerlink" title="1. 文件变更比较少的情况"></a><strong>1. 文件变更比较少的情况</strong></h4><p>直接使用以下命令重命名文件，在 git 中不要直接修改文件名，最好的办法是使用下面的方式，</p><pre><code>git mv -f [你想要删掉的文件] [你想要留下的文件]git mv -f a.js A.js等同于：git rm a.jsgit add A.js</code></pre><p>这个命令的目的就是删除不需要的大小写同名文件，修改后 <code>git push</code> 提交变更即可。</p><p><strong>tips:</strong> </p><p>因为 git 默认大小写不敏感，所以最好添加项目配置文件,设置 <strong>大小写敏感</strong>。</p><pre><code>touch .gitconfiggit config core.ignorecase false</code></pre><h4 id="2-变更比较多，并且拥有分支较高权限"><a href="#2-变更比较多，并且拥有分支较高权限" class="headerlink" title="2. 变更比较多，并且拥有分支较高权限"></a><strong>2. 变更比较多，并且拥有分支较高权限</strong></h4><ul><li>在 github 删除该分支</li><li>本地执行 <code>git rm -r --cached</code> . (注意后面‘点号’)</li><li>然后重新 <code>git push</code>，就ok了</li></ul><p>此法不太好，有点暴力，容易出问题，但适用于 变更发生于近期的情况。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h3><p>其实看解决办法的话，只是一个很小的问题，但是出现的 bug 确实是让人很头疼的，因为 mac windows 在不设置大小写敏感规则的时候默认大小写是不敏感，项目部署的机器是 Linux 的，而 Linux 是大小写敏感的。所以这样的问题平时不易发现，本地调试的时候大部分时候并不会出错误，只有在项目部署的时候问题才会显示出来。</p><p>至此，终于填了一个不该踩的坑。</p>]]></content>
      
      
      <categories>
          
          <category> Github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> 踩坑笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我生病的一次经历</title>
      <link href="/2018/01/18/"/>
      <url>/2018/01/18/</url>
      
        <content type="html"><![CDATA[<p>中午刷知乎不经意看到两个推送的问题？</p><ul><li><a href="https://www.zhihu.com/question/22213153">年轻时得了绝症或者大病是种怎样的体验？</a></li><li><a href="https://www.zhihu.com/question/264229537">有哪些让你感觉很痛的句子？</a></li></ul><p>事实上，我只看了几个回答，就不敢再看下去了……</p><p>我也正在年轻时，不过我不是得的大病（已痊愈），或者说现在看来根本不算是什么大病，但是答主所经历的种种，我或许也是可以感同身受。</p><p>2016年7月，是我毕业后的第一个暑假。我在深圳的一家公司做着一名程序员小白的工作，对那个时候的唯一印象大概就是：深圳的夏天比我待过的地方都热许多。进入公司会需要一些材料，比如说入职体检。而我的噩梦就是从入职体检开始的。</p><p>我来到了住所附近的一家医院，天气很热，因为是周末，来做体检的人也很多。因为想到做完这个体检就可以成为正式的社会人了，其实心里自然会有点小期许。</p><p>排队，缴费，抽血，测血压一系列流程下来，剩下的就是去做胸透了。</p><p>我像之前一样平静的站到机器旁，当我听到医生指示准备走的时候，医生示意我不要走，让我脱掉衣服再检测一次。</p><p>好呗，脱就脱嘛，反正也是夏天。我这么安慰自己，并没有觉得十分不妥。</p><p>当我再次听到医生示意走出胸透室，医生拦住我：小伙子，你这个我看不清，这个机器不清晰，我给你开张单子，你再去做个CT给我来看看吧。</p><p>我胸这里有什么问题吗？我有些不安的情绪。</p><p>没什么问题，有些小阴影，机器看不清，所以叫你做个清晰的，快去吧。医生叮嘱我。</p><p>其实到这时，虽然我有点不安，但我还是乐观的。我也就屁颠屁颠的去了。做CT不似做胸透，1分钟1个下饺子一样，做CT的话要等待很久，半个小时到1个小时之间。因为是中午，我也顾不上吃饭，就在等待室等待结果。</p><p>程鹏飞，程鹏飞在吗，过来填张单子。一个护士扯着嗓子喊。</p><p>这儿，我回应着跑过去。</p><p>因为之前也有病人拿到自己的检查报告，但是并没有见需要写什么单子。但我看到单子的抬头的时候，脑袋哄的一下。</p><p>肺结核确认单</p><p>我在脑袋里飞速的搜索着这个字眼，但每个回忆都告诉我这个病不简单，甚至，会失去生命。</p><p>医生还在旁边催促着我填单子，随便填写了自己的住址，电话，接过护士递来的转院证明什么的，静静的找到一个椅子坐下。</p><p>我想，那大概是我所经历过的最难熬的时刻。我依旧可以回想起来当时的感受。我记得，我首先想到的是死亡，我没有去百度这个病，但是我先想到了一个人离开。我想到了，如果这个病严重我就自杀，绝对不做别人的累赘。我想到了，这个病是传染病，以后还会与人愿意和我做朋友吗。我想到了，还在异地的女友（现在已经不是了），是时候离开她了。</p><p>当我把所有的可能都想了一遍的时候，我已经坐了半个小时左右了，微信的消息还在提示，我把结果告诉了女友。</p><p>女友的电话打了过来。已经哽咽的我再也忍不住，是的，我想不够坚强，即使再来一次，我应该还是不够坚强。女友告诉我她搜索的答案，不会死的，可以治愈的种种。</p><p>我想，当时的我，大概用了一个小时才让自己接受现实。</p><p>后来的事情就很简单了，转了医院在进行了半个月的炎症治疗发现没有作用的时候，确诊是肺结核。</p><p>的确如女友所说，并不会死，可以治愈，另外，我不具有传染性。</p><p>然后就是长时间的服药治疗了，每天要像为垂暮的老人一样吃各种增强免疫力的药。每个月回医院接受医生的复查。</p><p>幸好，都挺过来了。</p><p>这是我最深刻的一次“大病”，当然后来也有生病，甚至肺结核康复的第二年还去医院住了半个月，但都没有这次的印象深刻。</p><p>我所学习到，或者说是体会到的是生命，健康这东西，我们无法掌握，我们也无法保证坚强。但还好，生命一直继续，无论多苦多难，我们也一直学着坚强。你若对生命保留着敬畏之心，生命自然也会善待你。</p><p>最后</p><p>希望未来没有疾病，希望大家足够坚强。</p><p>–写自 2017年12月25日 ，一个脖子很疼的正午</p>]]></content>
      
      
      <categories>
          
          <category> 日常小感 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JS 参数校验: Joi 四问</title>
      <link href="/2018/01/11/"/>
      <url>/2018/01/11/</url>
      
        <content type="html"><![CDATA[<h2 id="JS-参数验证：-Joi-四问"><a href="#JS-参数验证：-Joi-四问" class="headerlink" title="**JS 参数验证： Joi 四问 **"></a>**JS 参数验证： Joi 四问 **</h2><p>以下内容均可在<a href="https://github.com/hapijs/joi/blob/v13.1.0/README.md">Joi官方地址</a>参考（文档略长，英文），本文仅为个人总结的几个小疑问。</p><h3 id="1-定义-schema-时-Joi-object-keys-和-Joi-object-有什么区别？"><a href="#1-定义-schema-时-Joi-object-keys-和-Joi-object-有什么区别？" class="headerlink" title="1. 定义 schema 时 Joi.object.keys() 和 Joi.object() 有什么区别？"></a>1. 定义 <strong>schema</strong> 时 <strong>Joi.object.keys()</strong> 和 <strong>Joi.object()</strong> 有什么区别？</h3><p>答： 并没有什么区别，官方给了三种定义 <code>schema</code> 的方式。如下：</p><pre><code>// 使用 &#123; &#125; 来定义const schema = &#123;    a: Joi.string(),    b: Joi.number()&#125;;// 使用 Joi.object()const schema = Joi.object(&#123;    a: Joi.string(),    b: Joi.number()&#125;);// 使用 Joi.object.keys()const schema = Joi.object().keys(&#123;    a: Joi.string(),    b: Joi.number()&#125;);</code></pre><p>三种方式实现的效果其实都是一样的，但是在使用的时候会有一些略微不同，具体如下：</p><ul><li>当使用 {} 时，只是定义了一个普通的js对象，它不是一个完整的 schema 对象。你可以将它传递给验证方法，但不能调用对象的validate（）方法，即类似这种 <code>object.validate()</code>的操作是不可以的，因为它只是一个普通的js对象。此外，每次将{}对象传递给validate（）方法，都将对每个验证执行一个昂贵的模式编译操作。</li><li>当使用 Joi.object() 时，相对于使用 {} ，这是正经的schema 对象，它会在第一次编译，所以你可以多次将它传递给validate（）方法，不会增加开销。另外，你还可以设置 options 来验证。</li><li>当使用 Joi.object.keys() 时，其实和使用 Joi.object() 是类似的，但是当你想添加更多的键（例如多次调用keys（））时，使用joi.object（）.keys（[schema]）会更有用。如果只添加一组键，则可以跳过keys（）方法，直接使用object（）。有些人喜欢用keys（）来使代码看起来更加精确（其实这只是一种编程风格）。</li></ul><h3 id="2-Joi-validate-value-schema-options-callback-中的-options-取值有哪些？"><a href="#2-Joi-validate-value-schema-options-callback-中的-options-取值有哪些？" class="headerlink" title="2. Joi.validate(value, schema, [options], [callback])中的 options 取值有哪些？"></a>2. Joi.validate(value, schema, [options], [callback])中的 options 取值有哪些？</h3><p>答：options可用的值有如下：</p><ul><li><strong>abortEarly：</strong> 设置true，可以在检测到第一个错误时立即返回，默认false（检查全部）。推荐设置true</li><li><strong>convert：</strong>设置true，可以尝试将值转换为所需的类型（例如，将字符串转换为数字）。默认为true。推荐采用默认</li><li><strong>allowunknown：</strong> 设置true，则允许对象包含被忽略的未知键。默认为false。推荐设置true</li><li><strong>skipfunctions：</strong>如果为true，则忽略具有函数值的未知键。默认为false。推荐采用默认</li><li><strong>stripunknown：</strong> 如果为true,从对象和数组中删除未知的元素。默认为false。也可以特殊的设置成 <code>&#123; objects: true , arrays: true &#125;</code>的形式，可以对象和数组分别处理。推荐采用默认</li><li><strong>presence：</strong> 设置默认的可选需求。支持的模式：’optional’,’required’,和’forbidden’。默认为’optional’。推荐采用默认</li><li><strong>escapehtml：</strong> 当为true时，出于安全目的，错误消息模板将特殊字符转义为html实体。默认为false。推荐采用默认</li><li><strong>nodefaults：</strong>如果为true，则不应用默认值。默认为false。推荐采用默认</li><li><strong>context：</strong> 提供一个外部数据集用于引用。只能设置为外部选项来验证（）而不使用any.options（）。使用方法：</li></ul><pre><code>const schema = Joi.object().keys(&#123;    a: Joi.ref(&#39;b.c&#39;),    b: &#123;        c: Joi.any()    &#125;,    c: Joi.ref(&#39;$x&#39;)&#125;);Joi.validate(&#123; a: 5, b: &#123; c: 5 &#125; &#125;, schema, &#123; context: &#123; x: 5 &#125; &#125;, (err, value) =&gt; &#123;&#125;);</code></pre><ul><li>language: 设置默认的错误提示。修改可参考：<a href="https://github.com/hapijs/joi/blob/v13.1.0/lib/language.js">默认</a></li></ul><h3 id="3-我需要-promisify-Joi-validate-方法吗？"><a href="#3-我需要-promisify-Joi-validate-方法吗？" class="headerlink" title="3. 我需要 promisify Joi.validate 方法吗？"></a><strong>3. 我需要 promisify Joi.validate 方法吗？</strong></h3><p>答： 其实只是两种写法，promise和非promise的写法。首先，Joi.validate() 的写法很像promise，但是还真不是promise实现的，所以你不用promise的写法就像这种（官网的这种）：</p><pre><code>// 场景： 在一个CGI的入口请求参数验证const data = &#123; a : &#39;123&#39; &#125;;let schema = Joi.object().keys(&#123;    a: Joi.string().required()&#125;);const &#123;error, value&#125; = Joi.validate(data, schema);if (error) &#123;    // 需要人工处理异常    console.log(error);&#125;</code></pre><p>使用promise的写法，就是下面这种，必须要使用 promisify 的，而且强制建议必须要使用 try-catch。</p><pre><code>// 场景： 在一个CGI的入口请求参数验证const Promise = require(&#39;bluebird&#39;);const JoiValidatePromise = Promise.promisify(Joi.validate);try &#123;    const data = &#123; a : &#39;123&#39; &#125;;    let schema = Joi.object().keys(&#123;        a: Joi.string().required()    &#125;);        const query = await JoiValidatePromise(data, schema);         &#125; catch (error) &#123;    // 使用 catch 捕获错误    console.log(error);&#125;</code></pre><p>两种写法都可以，没有孰好孰坏，不过更推荐第二种写法，利用try-catch全局捕获错误，另外 Joi 的维护者 <a href="https://github.com/hapijs/joi/issues/1194">目前在实现 async 的写法</a>， 到时候应该就是直接支持promise了，那就不用promisify了，妙哉。</p><h3 id="4-希望可以有一个包罗万象的例子？"><a href="#4-希望可以有一个包罗万象的例子？" class="headerlink" title="4. 希望可以有一个包罗万象的例子？"></a><strong>4. 希望可以有一个包罗万象的例子？</strong></h3><p>答：如下：</p><pre><code>let testData = &#123; xxx &#125;;let paramSchema = Joi.object().keys(&#123;    username: Joi.string().alphanum().min(3).max(30).required(),    password: Joi.string().regex(/^[a-zA-Z0-9]&#123;3,30&#125;$/),    access_token: [Joi.string(), Joi.number()],    birthyear: Joi.number().integer().min(1900).max(2013),    email: Joi.string().email(),    website: Joi.string().uri(&#123;        scheme: [            &#39;git&#39;,            /git\+https?/        ]    &#125;),    search: Joi.string().allow(&#39;&#39;),    type: Joi.string().valid(&#39;disabled&#39;, &#39;normal&#39;, &#39;all&#39;).default(&#39;all&#39;),    startTime: Joi.date().min(&#39;1-1-1974&#39;).max(&#39;now&#39;),    endTime: Joi.when( Joi.ref(&#39;startTime&#39;), &#123; is: Joi.date().required(), then: Joi.date().max(&#39;1-1-2100&#39;) &#125; ),    page: Joi.number().integer().min(1).default(1),    pageSize: Joi.number().integer().default(8),    deleteWhenLtTen: Joi.number().integer().max(10).strip(),    arraySelect: Joi.array().items(Joi.string().label(&#39;My string&#39;).required(), Joi.number().required()),&#125;);let &#123; error, value &#125; = Joi.validate(testData, paramSchema, &#123; allowUnknown: true, abortEarly: true &#125;);if (error) &#123;    throw error;&#125;query = value;</code></pre><p>简单的使用可以看上面，详细的使用直接看 <a href="https://github.com/hapijs/joi/blob/v13.1.0/API.md">API</a></p><p>喏，这就是一篇总结文，可能还会继续增加内容，笑纳。</p>]]></content>
      
      
      <categories>
          
          <category> nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hyperapp.js 一个轻量级的 react 实现</title>
      <link href="/2018/01/05/"/>
      <url>/2018/01/05/</url>
      
        <content type="html"><![CDATA[<h2 id="hyperapp-是什么鬼？"><a href="#hyperapp-是什么鬼？" class="headerlink" title="hyperapp 是什么鬼？"></a><strong>hyperapp 是什么鬼？</strong></h2><p>hyperapp 是一个前端的应用构建库。初见写法，很有一种写react的亲切的感觉（其实就是一个套路），不过这肯定不能成为吸引广发gay友从而在短短两个月拿到 8K star的理由。更重要的一个原因是 官方宣称的1kb。是的， hyperapp 的核心代码只有1kb，这对早已习惯react全家桶，同时对当今web应用一个页面动辄3、4M毒害的gay友来说，的确是一个福音。基于此，官方给自己的定位是：</p><ul><li>更小：只要1kb，做到其他框架应该做的；</li><li>更实用：主流的前端应用思想，不会对学习带来额外负担；</li><li>开箱即用：完善的虚拟Dom、key更新、应用生命周期。</li><li>以上个人翻译，有吹嘘成分</li></ul><p>既然听起来这么厉害，今天就来一探究竟了……</p><h2 id="简单的使用"><a href="#简单的使用" class="headerlink" title="简单的使用"></a><strong>简单的使用</strong></h2><p>最简单的使用方法就是看官网给的 <strong>计数器</strong> 示例，可以在 <a href="">这里</a> 查看最终效果：</p><pre><code>&lt;body&gt;&lt;script src=&quot;https://unpkg.com/hyperapp&quot;&gt;&lt;/script&gt;&lt;script&gt;// ******划重点const &#123; h, app &#125; = hyperappconst state = &#123;  count: 0&#125;const actions = &#123;  down: value =&gt; state =&gt; (&#123; count: state.count - value &#125;),  up: value =&gt; state =&gt; (&#123; count: state.count + value &#125;)&#125;const view = (state, actions) =&gt;  h(&quot;div&quot;, &#123;&#125;, [    h(&quot;h1&quot;, &#123;&#125;, state.count),    h(&quot;button&quot;, &#123; onclick: () =&gt; actions.down(1) &#125;, &quot;–&quot;),    h(&quot;button&quot;, &#123; onclick: () =&gt; actions.up(1) &#125;, &quot;+&quot;)  ])window.main = app(state, actions, view, document.body)// *****划重点&lt;/script&gt;&lt;/body&gt;</code></pre><p>显而易见，state 定义了应用的状态， view 定义了应用的视图，通过 h 方法生成一个虚拟Dom,也就是可以被浏览器解释的结点树，action 则定义了应用的一些行为逻辑，最后在通过 app 方法挂载到真实的Dom元素结点上。</p><p>当然这只是很简单的使用。对于已经习惯了react写法的我们来说，我们可能在 view 的部分更习惯写纯函数，或者说一些牵扯到生命周期的操作，当然这些在 hyperapp 中也是可以的。</p><p>具体的操作可以参考 <a href="https://github.com/hyperapp/hyperapp/blob/master/docs/concepts/"><strong>官方文档</strong></a>。</p><h2 id="看源码吧还是"><a href="#看源码吧还是" class="headerlink" title="看源码吧还是"></a><strong>看源码吧还是</strong></h2><p>当然学习使用不是我们的目的，这些操作其他库中都有实现，真正感兴趣的是他说的1kb，所以还是来看源码吧（讲真，源码写的有点绕）。</p><p>核心的方法只有两个，h 函数 和 app 函数，h函数很简单，只是用来构建 dom 结点的。源码如下：</p><pre><code>/** * 先来看h的用法，作用是生成一个虚拟dom节点 * name 可以是 一个标签名字符串，如‘div’, 也可以是一个已经被渲染的component，如‘h(div,&#39;&#39;,)’ * props 标签的属性定义，如‘class’，事件等 * 不定参数，都会当做当前节点的子节点计算 */export function h(name, props) &#123;  var node  var stack = []  var children = []  for (var i = arguments.length; i-- &gt; 2; ) &#123;    stack.push(arguments[i])  &#125;  while (stack.length) &#123;    if (Array.isArray((node = stack.pop()))) &#123;      for (i = node.length; i--; ) &#123;        stack.push(node[i])      &#125;    &#125; else if (null == node || true === node || false === node) &#123;    &#125; else &#123;      children.push(typeof node === &quot;number&quot; ? node + &quot;&quot; : node)    &#125;  &#125;  return typeof name === &quot;string&quot;    ? &#123;        name: name,        props: props || &#123;&#125;,        children: children      &#125;    : name(props || &#123;&#125;, children)&#125;</code></pre><p>app 方法则是项目的入口，整个构建的操作其实在这里执行。在app函数里又定义了许多常用的工具方法，比如 createElement（创建元素），getKey（获取元素结点的key），removeElement（移除元素）等等。又很多，这里不在一一分析，重点方法只有两个 init 方法和 patch方法。</p><h4 id="init"><a href="#init" class="headerlink" title="init()"></a><strong>init()</strong></h4><p>init的方法的调用还是挺有意思的，如下：</p><pre><code>repaint(init([], (state = copy(state)), (actions = copy(actions))))</code></pre><p>可理解成：</p><pre><code>function a() &#123; console.log(&#39;a&#39;); setTimeout(b); &#125;function b() &#123; console.log(&#39;b&#39;) &#125;function c() &#123; console.log(&#39;c&#39;) &#125;;a(c());</code></pre><p>其实就是确保在入口的 repaint 方法每次被调用的时候先执行 init 方法。</p><p>我们来看 init 方法的主体部分：</p><pre><code>// actions 有两种情况，一种是参数只存在state的情况，一种是参数存在state和action的情况,又是讨厌的递归  function init(path, slice, actions) &#123;    for (var key in actions) &#123;      typeof actions[key] === &quot;function&quot;        ? (function(key, action) &#123;            actions[key] = function(data) &#123;              // 第一次初始化的时候，path为[]，所以得到的还是初始传入的state              slice = get(path, state)                // actions参数中存在action的情况，同时执行重新渲染一次              if (typeof (data = action(data)) === &quot;function&quot;) &#123;                data = data(slice, actions)              &#125;              if (data &amp;&amp; data !== slice &amp;&amp; !data.then) &#123;                repaint((state = set(path, copy(slice, data), state, &#123;&#125;)))              &#125;              return data            &#125;          &#125;)(key, actions[key])        : init(            path.concat(key),            (slice[key] = slice[key] || &#123;&#125;),            (actions[key] = copy(actions[key]))          )    &#125;  &#125;</code></pre><p>其实 init 方法的目的就是确保了两种执行 repaint 方法的不同情况（有个看源码的小技巧就是去看官方提供的单元测试，来反推某个方法的用法）。init 方法的目的是执行 repaint 方法（真实渲染的方法入口，最终会执行 patch 方法）。</p><h4 id="patch"><a href="#patch" class="headerlink" title="patch()"></a><strong>patch()</strong></h4><pre><code>function patch(parent, element, oldNode, node, isSVG, nextSibling) &#123;    if (node === oldNode) &#123;    &#125; else if (null == oldNode) &#123;      element = parent.insertBefore(createElement(node, isSVG), element)    &#125; else if (node.name &amp;&amp; node.name === oldNode.name) &#123;      updateElement(element, oldNode.props, node.props)      var oldElements = []      var oldKeyed = &#123;&#125;      var newKeyed = &#123;&#125;      for (var i = 0; i &lt; oldNode.children.length; i++) &#123;        oldElements[i] = element.childNodes[i]        var oldChild = oldNode.children[i]        var oldKey = getKey(oldChild)        if (null != oldKey) &#123;          oldKeyed[oldKey] = [oldElements[i], oldChild]        &#125;      &#125;      var i = 0      var j = 0      while (j &lt; node.children.length) &#123;        var oldChild = oldNode.children[i]        var newChild = node.children[j]        var oldKey = getKey(oldChild)        var newKey = getKey(newChild)        if (newKeyed[oldKey]) &#123;          i++          continue        &#125;        if (null == newKey) &#123;          if (null == oldKey) &#123;            patch(element, oldElements[i], oldChild, newChild, isSVG)            j++          &#125;          i++        &#125; else &#123;          var recyledNode = oldKeyed[newKey] || []          if (oldKey === newKey) &#123;            patch(element, recyledNode[0], recyledNode[1], newChild, isSVG)            i++          &#125; else if (recyledNode[0]) &#123;            patch(              element,              element.insertBefore(recyledNode[0], oldElements[i]),              recyledNode[1],              newChild,              isSVG            )          &#125; else &#123;            patch(element, oldElements[i], null, newChild, isSVG)          &#125;          j++          newKeyed[newKey] = newChild        &#125;      &#125;      while (i &lt; oldNode.children.length) &#123;        var oldChild = oldNode.children[i]        if (null == getKey(oldChild)) &#123;          removeElement(element, oldElements[i], oldChild)        &#125;        i++      &#125;      for (var i in oldKeyed) &#123;        if (!newKeyed[oldKeyed[i][1].props.key]) &#123;          removeElement(element, oldKeyed[i][0], oldKeyed[i][1])        &#125;      &#125;    &#125; else if (node.name === oldNode.name) &#123;      element.nodeValue = node    &#125; else &#123;      element = parent.insertBefore(        createElement(node, isSVG),        (nextSibling = element)      )      removeElement(parent, nextSibling, oldNode)    &#125;    return element  &#125;</code></pre><p>具体的方法什么意思就不一一解释了，有一点要注意的是，这个库用了很多小套路，如果想要理解的话，最好先去好好理解下 <a href="http://weizhifeng.net/immediately-invoked-function-expression.html">JS 中的()是什么意思？</a></p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a><strong>源码</strong></h3><p>太长就不放了，放个链接吧。<a href="https://github.com/hyperapp/hyperapp/blob/master/src/index.js">戳</a>。</p><h2 id="其他类似的"><a href="#其他类似的" class="headerlink" title="其他类似的"></a><strong>其他类似的</strong></h2><p>其实类似的实现还有 <a href="https://github.com/developit/preact">preact</a> ，不过 preact 大了一丢丢，但是在知名度和可靠性上肯定是 preact<br>遥遥领先的，本文只是用来学习，真正项目使用的话还是要慎重考虑的，优先考虑 react 和 preact 这些。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>写到这里感觉自己也是似懂非懂的了，一定是源码看的太少了……</p><p>以后继续加油，拜拜</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> hyperappjs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS: 一个小例子引发的思考</title>
      <link href="/2018/01/03/"/>
      <url>/2018/01/03/</url>
      
        <content type="html"><![CDATA[<h2 id="一个小例子引发的思考"><a href="#一个小例子引发的思考" class="headerlink" title="一个小例子引发的思考"></a><strong>一个小例子引发的思考</strong></h2><p>emmmm……</p><p>最近在看一个开源库，看其中的栗子中发现了一段很有意思的代码。栗子简化一下是下面的这个样子的:</p><pre><code>function a() &#123; console.log(&#39;a&#39;); setTimeout(b); &#125;function b() &#123; console.log(&#39;b&#39;) &#125;function c() &#123; console.log(&#39;c&#39;) &#125;;a(c());</code></pre><p>可能你觉得这没什么，不就几个简单的方法调用么，有什么复杂的？那么我们先来看一下在Chrome的控制台里面会输出什么？</p><p><img src="http://ww1.sinaimg.cn/large/86c7c947gy1fn3en7cjl6j219m04qjrp.jpg"></p><p>可能的确如你所料，控制台依次输出了c、a、b（虽然有个不知道什么鬼的undefined，这个等下再说），那说明你对JS中函数的执行顺序有一定的了解。的确，前面声明了三个方法，a,b,c,然后加上括号使a成为语句执行。但是a(c())这种写法怪怪的，内部怎么执行的？还有这个输出怎么会有一个undefined（面试题埋坑啊）？</p><p>我同样也有这样的疑问，那么深究之前，先整理一下我们的疑问。</p><p><strong>这段代码的输出是什么？a(c())这种写法是什么鬼？undefined是什么鬼？setTimeout不写时间参数会咋样？会有浏览器差异么？</strong></p><p>那么我们一个个的来为我们疑问来寻找答案……</p><h3 id="这段代码的输出是什么？为什么会有这样子的输出？"><a href="#这段代码的输出是什么？为什么会有这样子的输出？" class="headerlink" title="这段代码的输出是什么？为什么会有这样子的输出？"></a><strong>这段代码的输出是什么？为什么会有这样子的输出？</strong></h3><p>其实答案已经看到了，就是c、a、b。因为JS是单线程执行的，所以在执行a方法的过程中，先执行了（）中的语句，也就是c（）方法，所以顺序执行也就是c、a、b。</p><p>emmm……说了和没说一样，没关系往下看。</p><h3 id="a-c-这种写法是什么鬼？"><a href="#a-c-这种写法是什么鬼？" class="headerlink" title="a(c())这种写法是什么鬼？"></a><strong>a(c())这种写法是什么鬼？</strong></h3><p>接着上个答案的来说。要明白a(c())这种写法是什么鬼？我们得先了解在JS中（）是个什么作用？对于普通的语句，（）直接执行。对于函数来说，JavaScript解释器会在默认的情况下把遇到的function关键字当作是函数声明语句(statement)来进行解释的。先来看下面的这几个栗子：</p><pre><code>(111)   // 常量，当做语句处理。打印 111(var a)  // 变量声明。 报错(a = 1)  // 赋值语句,不要写&#39;;&#39;。打印 1function()&#123;console.log(&#39;aa&#39;)&#125;()  // 匿名函数，不是标准的函数声明语句。报错(function()&#123;console.log(&#39;aa&#39;)&#125;())  // 立即执行函数。打印 aa(function()&#123;console.log(&#39;aa&#39;)&#125;)()  // 立即执行函数。打印 aa</code></pre><p>所以其实大致的意思已经很明了。 通俗的来讲就是 因为c首先是一个很标准的函数语句，然后（）又可以执行语句，所以a(c())的执行顺序就是先执行了c方法，然后继续执行a方法。如果换成下面的这种方式c就不会执行了：</p><pre><code>a(c());   // c、a、ba(c);// a、ba(function()&#123;console.log(&#39;nini&#39;)&#125;);// a、b</code></pre><p>好像也没有那么绕……</p><h3 id="undefined是什么鬼？"><a href="#undefined是什么鬼？" class="headerlink" title="undefined是什么鬼？"></a><strong>undefined是什么鬼？</strong></h3><p>基本路子搞明白了，那么这个undefined是什么鬼？其实很简单，这是Chrome控制台的一种默认机制，对于执行语句来说，控制台会默认去拿上一行语句的输出。</p><pre><code>a = 1;// 打印 1var a = 1; // 打印 undefined, 因为这是两行语句(function()&#123;return 1;&#125;)() // 打印 1function a() &#123;&#125; a(); // 打印 undefinedfunction a() &#123; return 11; &#125; a(); // 打印 1</code></pre><p>所以打印undefined的问题找到了，那么问题来了，node中会不会打印呢？尝试了一波儿发现，node中并不会打印，所以同样是V8引擎，但是控制台这一块儿还是有差距的。</p><h3 id="setTimeout不写时间参数会咋样？"><a href="#setTimeout不写时间参数会咋样？" class="headerlink" title="setTimeout不写时间参数会咋样？"></a><strong>setTimeout不写时间参数会咋样？</strong></h3><p>终于碰到了最喜欢的setTimeout方法。查阅一堆乱七八糟资料后，setTimeout不写时间参数的话，会由浏览器默认给加上延迟参数，具体多少各家浏览器都不一样。</p><p>emmm……无所谓了，那么 setTimeout(func,0) 和 setTimeout(func) 有什么区别么？</p><p>下面两张图是在控制台进行了4次的对比试验。</p><p><strong>没有时间参数</strong></p><p><img src="http://ww1.sinaimg.cn/large/86c7c947gy1fn3en77tpyj20ky0d20u9.jpg"></p><p><strong>时间参数为0</strong></p><p><img src="http://ww1.sinaimg.cn/large/86c7c947gy1fn3en7dhw1j20n60cs0u7.jpg"></p><p>好像加上0的确会快一些。不过我们也知道，即使是0，setTimeout 的作用也只是加到当前执行的事件队列当中，而且在浏览器端每次执行也会有4ms的延迟。具体的可以看一看我的另一篇： <a href="http://blog.csdn.net/u013707249/article/details/78731356"><strong>看了这么久JS，事件队列你真的懂吗？</strong></a>。</p><p>关于浏览器的4ms的差异延迟，我们暂时不用在意。当我们需要遇到性能瓶颈时可以去研究一下，具体的方案的实现还都挺有意思的。</p><h3 id="会有浏览器差异么？"><a href="#会有浏览器差异么？" class="headerlink" title="会有浏览器差异么？"></a><strong>会有浏览器差异么？</strong></h3><p>有，不过控制台的输出影响不大。不必在意。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a><strong>结尾</strong></h2><p>以上，基本上该思考的都思考了，不知道你看到这里，还有什么在思考的，倘若有的话，不妨说来听听。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6黑科技实践--proxy,reflect</title>
      <link href="/2017/12/19/"/>
      <url>/2017/12/19/</url>
      
        <content type="html"><![CDATA[<h1 id="ES6黑科技实践–proxy-reflect"><a href="#ES6黑科技实践–proxy-reflect" class="headerlink" title="ES6黑科技实践–proxy,reflect"></a><strong>ES6黑科技实践–proxy,reflect</strong></h1><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a><strong>开始之前</strong></h2><p><a href="https://kangax.github.io/compat-table/es6/#test-Reflect">** reflect兼容性**</a></p><p><img src="http://ww1.sinaimg.cn/large/86c7c947gy1fmm18swndlj220c0ttauh.jpg"></p><p><a href="https://caniuse.com/#search=proxy"><strong>proxy兼容性</strong></a></p><p><img src="http://ww1.sinaimg.cn/large/86c7c947gy1fmltxsptfxj21yq11710d.jpg"></p><p>上面两图分别是截止当前，proxy和reflect的浏览器支持程度。可以看出proxy和reflect的支持已经相当好了，新一点的主流浏览器都支持了（除了IE）。</p><p>所以还是相当有必要玩耍一下的。</p><h2 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a><strong>proxy</strong></h2><h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a><strong>简单介绍</strong></h3><p>其实es6出来了这么久了，在实际的项目中也都使用es6编程。对于某些特殊的属性，如proxy，虽然用的不多，但我们或多或少也了解到proxy的用法。详细的介绍这里不赘述，可以移步<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy"><strong>MDN</strong></a>查看es6介绍，当然这里也有一篇大神的<a href="http://pinggod.com/2016/%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90-ES6-Proxy-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"><strong>es6使用大全</strong></a>，值得深究。</p><p>总之，用一句话总结就是：改变了过去对象监听的复杂操作，使用proxy可以用一种更优雅的方式实现外部对对象的访问。</p><h3 id="es5的实现"><a href="#es5的实现" class="headerlink" title="es5的实现"></a><strong>es5的实现</strong></h3><p>那么或许问题来了，在没有proxy之前，我们是怎么样实现对对象的监听呢？</p><p>其实在es5中，我们可以使用 <code>Object.defineProperty</code>和<code>Object.defineProperty</code>来实现对对象的监听。利用es5对象的getter 和 setter方法，可以实现简单的文件监听，使用方法如下：</p><pre><code>// 如何实现一个自存档对象。 当设置temperature 属性时，archive 数组会获取日志条目。function Archiver() &#123;  var temperature = null;  var archive = [];  Object.defineProperty(this, &#39;temperature&#39;, &#123;    get: function() &#123;      console.log(&#39;get!&#39;);      return temperature;    &#125;,    set: function(value) &#123;      temperature = value;      archive.push(&#123; val: temperature &#125;);    &#125;  &#125;);  this.getArchive = function() &#123; return archive; &#125;;&#125;var arc = new Archiver();arc.temperature; // &#39;get!&#39;arc.temperature = 11;arc.temperature = 13;arc.getArchive(); // [&#123; val: 11 &#125;, &#123; val: 13 &#125;]</code></pre><p>目前支持双向绑定的Vue中的实现就是这种方法。但是这种方法不太好的地方就是对于数组之类的对象，类似修改数组的length，直接用索引设置元素如items[0] &#x3D; {}，以及数组的push，pop等变异方法是无法触发setter的。针对这些，vue中的实现是在Object和Array的原型添加了定制方法来处理这些特殊操作，可以实现上述要求。</p><h3 id="第三方库的实现"><a href="#第三方库的实现" class="headerlink" title="第三方库的实现"></a><strong>第三方库的实现</strong></h3><p>请移步：</p><ul><li><a href="https://github.com/vuejs/vue">Vue.js</a></li><li><a href="https://github.com/melanke/Watch.JS/blob/master/src/watch.js">Watch.js</a></li><li><a href="https://github.com/angular/angular">Angularjs</a></li><li><a href="https://github.com/knockout/knockout">Knockout.js</a></li></ul><h2 id="reflect"><a href="#reflect" class="headerlink" title="reflect"></a><strong>reflect</strong></h2><h3 id="怎么理解reflect"><a href="#怎么理解reflect" class="headerlink" title="怎么理解reflect"></a><strong>怎么理解reflect</strong></h3><p>reflect 是es6新增的一个全局对象。顾名思义，<strong>反射</strong>，类似于Java里面的反射机制。在Java里面，反射是个很头疼的概念。简单理解为：<strong>通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。对于Java来说，程序中一般的对象的类型都是在编译期就确定下来的，而Java反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。</strong></p><p>而对于js来说自然是有些不同了。毕竟<strong>js不需要编译</strong>，同时<strong>万物皆对象</strong>的特性，这些都让理解js的reflect起来相当简单。</p><p>对于JS中的reflect，我们就可以理解为：<strong>有这么一个全局对象，上面直接挂载了对象的某些特殊方法，这些方法可以通过<code>Reflect.apply</code>这种形式来使用，当然所有方法都是可以在 Object 的原型链中找到的。</strong>是不是相当简单。</p><h3 id="使用reflect的好处"><a href="#使用reflect的好处" class="headerlink" title="使用reflect的好处"></a><strong>使用reflect的好处</strong></h3><p>引自<a href="https://zhuanlan.zhihu.com/p/24778807">知乎专栏：ES6 Reflect</a></p><ol><li>Reflect上面的一些方法并不是专门为对象设计的，比如Reflect.apply方法，它的参数是一个函数，如果使用Object.apply(func)会让人感觉很奇怪。</li><li>用一个单一的全局对象去存储这些方法，能够保持其它的JavaScript代码的整洁、干净。不然的话，这些方法可能是全局的，或者要通过原型来调用。</li><li>将一些命令式的操作如delete，in等使用函数来替代，这样做的目的是为了让代码更加好维护，更容易向下兼容；也避免出现更多的保留字。</li></ol><h3 id="常见的方法"><a href="#常见的方法" class="headerlink" title="常见的方法"></a><strong>常见的方法</strong></h3><pre><code>Reflect.applyReflect.constructReflect.definePropertyReflect.deletePropertyReflect.enumerate // 废弃的Reflect.getReflect.getOwnPropertyDescriptorReflect.getPrototypeOfReflect.hasReflect.isExtensibleReflect.ownKeysReflect.preventExtensionsReflect.setReflect.setPrototypeOf</code></pre><p>具体用法当然是看：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">MDN: reflect介绍</a></p><h2 id="一个使用proxy和reflect实现监听对象的小例子"><a href="#一个使用proxy和reflect实现监听对象的小例子" class="headerlink" title="一个使用proxy和reflect实现监听对象的小例子"></a><strong>一个使用proxy和reflect实现监听对象的小例子</strong></h2><p>栗子来源(非本人):<a href="https://github.com/sindresorhus/on-change">https://github.com/sindresorhus/on-change</a></p><p>on-change是一个可以监听对象或者<strong>数组</strong>内部变化的小工具，主要使用proxy来实现。以下是核心代码：</p><pre><code>// onChange 即要进行的监听操作module.exports = (object, onChange) =&gt; &#123;    const handler = &#123;        get(target, property, receiver) &#123;            try &#123;                return new Proxy(target[property], handler);            &#125; catch (err) &#123;                return Reflect.get(target, property, receiver);            &#125;        &#125;,        defineProperty(target, property, descriptor) &#123;            onChange();            return Reflect.defineProperty(target, property, descriptor);        &#125;,        deleteProperty(target, property) &#123;            onChange();            return Reflect.deleteProperty(target, property);        &#125;    &#125;;    return new Proxy(object, handler);&#125;;</code></pre><p>代码很精简，但是也是有必要研究下，是一位大大牛 <strong><a href="https://sindresorhus.com/">sindresorhus</a></strong> 的作品。</p><p>其实一共有三个方法，<code>get</code> <code>defineProperty</code> <a href="">defineProperty</a>,上面代码可以对数组进行操作就是因为用了proxy，具体的实现在<code>get</code>方法，每一层返回一个proxy，需要注意的是在监听操作这里依然使用的是 es5的 defineProperty 方法。具体的可以自己研究下，还是很有可玩性的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h2><ul><li><a href="https://segmentfault.com/a/1190000010471230">《深入理解ES6》笔记——代理（Proxy）和反射（Reflection）API</a></li><li><a href="http://www.jianshu.com/p/34f0e6abe312">ES6 之 Proxy 介绍</a></li><li><a href="http://pinggod.com/2016/%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90-ES6-Proxy-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/">实例解析 ES6 Proxy 使用场景</a></li><li><a href="https://www.zhihu.com/question/44724640?sort=created">知乎回答：如何监听 js 中变量的变化?</a></li><li><a href="https://zhuanlan.zhihu.com/p/24778807">知乎专栏：ES6 Reflect</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> proxy </tag>
            
            <tag> reflect </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker实践，利用DaoCloud来部署应用</title>
      <link href="/2017/12/14/"/>
      <url>/2017/12/14/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker实践，利用DaoCloud来部署应用"><a href="#Docker实践，利用DaoCloud来部署应用" class="headerlink" title="Docker实践，利用DaoCloud来部署应用"></a><strong>Docker实践，利用DaoCloud来部署应用</strong></h1><h2 id="准备工作要做好"><a href="#准备工作要做好" class="headerlink" title="准备工作要做好"></a><strong>准备工作要做好</strong></h2><p>在学习了<strong>Docker</strong>的基操之后，一定很想找台机子练练手，本机其实也可以，但是如果有一台服务器并且还是线上的当然最好啦。</p><p>这里推荐两个福利，之所以说是福利，是因为这简直是科技大老板给我们这些穷逼开发的学习福利啊，话不多说。</p><p><strong>腾讯开发者实验室</strong></p><p><img src="http://ww1.sinaimg.cn/large/86c7c947gy1fmg43jt7bqj227s14gk0t.jpg"></p><p><a href="https://cloud.tencent.com/developer/labs/gallery"><strong>腾讯开发者实验室</strong></a>是腾讯提供的开发者专属在线实验平台。在这里，你可以像大学里计算机上机课程一样，跟着教程来体验服务器运维的快乐，体验时长可以说是相当长了。</p><p><strong>Daocloud</strong></p><p><img src="http://ww1.sinaimg.cn/large/86c7c947gy1fmg43jz19ij227013iqe1.jpg"></p><p><a href="http://www.daocloud.io/"><strong>Daocloud</strong></a>是国内的一个企业级容器云平台。虽说是企业的，但是注册了之后可以有很多的免费体验。特别是每次可以免费试用两小时的胶囊主机，更重要的是使用完了还可以续杯重新使用。对于我们学习来说绝对够用了。</p><p>本文基于Daocloud来做这一次实践，想使用腾讯开发实验室的可以自己去体验哈。</p><h2 id="开始上手"><a href="#开始上手" class="headerlink" title="开始上手"></a><strong>开始上手</strong></h2><h3 id="找一个可以上手的玩儿的项目"><a href="#找一个可以上手的玩儿的项目" class="headerlink" title="找一个可以上手的玩儿的项目"></a><strong>找一个可以上手的玩儿的项目</strong></h3><p>这点，任何一个需要部署且确保编译成功的项目都可以。因为是简单实践，我们就直接使用<strong>Daocloud</strong>镜像仓库里面别人提供的一个镜像<strong>WordPress</strong>。</p><p>可以在 <code>发现镜像</code> –&gt; <code>精选镜像</code> –&gt; <code>内容管理系统</code> –&gt; <code>WordPress</code> 找到</p><p><img src="http://ww1.sinaimg.cn/large/86c7c947gy1fmg43j0j3dj227s0yw44s.jpg"></p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a><strong>部署</strong></h3><p>之后直接进入镜像，然后点击右上角 <code>部署</code> ，进去</p><p><img src="http://ww1.sinaimg.cn/large/86c7c947gy1fmg4lr1rrvj21s70uujud.jpg"></p><p>应用名称随便起，主机那里可以点击试用2小时的胶囊主机，然后点击 下一步 进入到配置页</p><p><img src="http://ww1.sinaimg.cn/large/86c7c947gy1fmg4lquq6gj21vy144aeo.jpg"></p><p>在配置页，会有一些参数配置，<strong>Volumes</strong> 直接默认值，<strong>YAML</strong> 是用于复杂多节点部署的配置文件，不理，直接使用默认值，当然还有一些 <strong>高级配置</strong>，什么启动权限，启动命令的，巴拉巴拉，当然如果你不懂，直接默认，<strong>立即部署</strong>。</p><p>然后就会跳转日志页，等候一下下，点击 <strong>应用</strong> 菜单，如果你刚创建的应用显示的是 <strong>运行中</strong>，那就证明你部署成功了。</p><p><img src="http://ww1.sinaimg.cn/large/86c7c947gy1fmg4lq5llij21t6081dha.jpg"></p><p>这时，点击 <code>集群管理</code> –&gt; <code>管理主机</code> 即可看到下面的容器列表</p><p><img src="http://ww1.sinaimg.cn/large/86c7c947gy1fmg4lr0y0nj221c10sjy7.jpg"></p><p>浏览器，输入你当前主机的公网IP和端口就可以正常访问到 <strong>WordPress</strong> 的主页了</p><p><img src="http://ww1.sinaimg.cn/large/86c7c947gy1fmg4lr1p9nj214w13jgph.jpg"></p><p>以上，部署大功告成。</p><h3 id="继续把玩"><a href="#继续把玩" class="headerlink" title="继续把玩"></a><strong>继续把玩</strong></h3><p>是不是感觉太简单了，完全没有技术含量。事实上就是这么简单。只是一个简单的部署任务，目的地不一样而已，当然速度上也比正常的部署快了一个档次。</p><p>当然不会这么简单了。</p><p><strong>部署配置</strong></p><p>在部署时全部选择默认的地方都值得你去研究一下，好的配置方案，让你的应用更轻更快更稳定。</p><p><strong>CI CD</strong></p><p>如果你还要深入，你也可以去试用 利用来docker来做持续集成（CI）和持续交付（CD）。这个功能貌似有使用限度（因为当我想要去截图的时候，我发现我已经没有使用权限了），需要你拉取你自己的私人项目，然后会有一系列的流程定义，可以按键操作，也可以自己写YAML，总之就是很简单的操作啦。</p><p><strong>远程连接主机来玩喽</strong></p><p>同样的点击 点击 <code>集群管理</code> –&gt; <code>管理主机</code> ，进入主机容器列表</p><p><img src="http://ww1.sinaimg.cn/large/86c7c947gy1fmg85won3aj213a0hcwgk.jpg"></p><p>通过主机提供的用户名密码来远程登录，练习你的Linux技能。</p><p>如果你不知道怎么连接，可以参考下面这篇文章。</p><p><a href="https://help.aliyun.com/document_detail/51798.html?spm=5176.doc25429.2.13.s1A6X1">ssh连接远程主机办法</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>以上，相信你可以愉快的玩耍了。</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>还在用虚拟机吗，是时候用Docker了</title>
      <link href="/2017/12/13/"/>
      <url>/2017/12/13/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker是啥？"><a href="#Docker是啥？" class="headerlink" title="Docker是啥？"></a><strong>Docker是啥？</strong></h2><p>如果有人问起了你这个问题，你可以这样回答他：<strong>Docker就是一个轻量型的虚拟机，可以充分利用服务器性能。</strong></p><p>如果你的这个回答被怼了？</p><ul><li><p>爱怼怼用户A：什么轻量型的虚拟机，跟虚拟机本质上是有区别的好吧？虚拟机多了一层guest OS，同时Hypervisor会对硬件资源进行虚拟化，运行在虚拟机上的应用程序在进行数值计算时是运行在Hypervisor虚拟的CPU上的（如果你使用过win10的hyper-v虚拟机工具，你就会发现如果要开启虚拟机就要在bios开启cpu的虚拟化）。而docker直接使用硬件资源虚拟机增加了一层虚拟硬件层，所以资源利用率相对docker低。</p></li><li><p>爱怼怼用户B： Docker其实也是类似于虚拟机的。至少在作用目的上是一致的。用一个“经典”的例子来作对比就是：将部署应用比作鸣人来搓螺旋丸，虚拟机类似于鸣人的影分身之术，每个分身（虚拟机）都拥有同样的身体（OS，环境）,但是在查克拉（CPU）的使用上，每个分身的查克拉会均分自真身（真正的主机），这个行为也可以称之为CPU虚拟化，但是这里浪费了分身，用分身来搓一个小螺旋丸，太浪费了……而对于docker来说，就像是九尾模式的鸣人，我直接利用我体内的九尾查克拉（硬件资源），分成九只爪子，每只爪子相互独立，也可以搓小螺旋丸……</p></li><li><p>爱怼怼用户C： 楼上菜鸡，直接看官方介绍不就行了，<a href="https://www.docker.com/what-docker">Docker官方介绍</a>，<a href="https://www.zhihu.com/question/22871084/answer/88293837">Docker集装箱</a></p></li><li><p>……</p></li></ul><p>对于这些，你只需回答：看来你不是都知道么……</p><p>那么使用Docker有哪些好处呢?</p><h2 id="用Docker有啥好处？"><a href="#用Docker有啥好处？" class="headerlink" title="用Docker有啥好处？"></a><strong>用Docker有啥好处？</strong></h2><ul><li>速度飞快以及优雅的隔离框架： 每个Docker之间互相隔离。</li><li>物美价廉： 服务器一台多贵晓得不，省了不少经费了。</li><li>CPU&#x2F;内存的低消耗：少了大部分虚拟机的没太大作用的硬件资源占用，自然消耗少了。  </li><li>快速开&#x2F;关机： 相对于虚拟机肉鸡开机速度而言。</li><li>跨云计算基础构架： 就是云计算喽。</li></ul><h2 id="简单操作：搭建-Docker-环境"><a href="#简单操作：搭建-Docker-环境" class="headerlink" title="简单操作：搭建 Docker 环境"></a><strong>简单操作：搭建 Docker 环境</strong></h2><p>以下上手基于 <strong>CentOS</strong> ，所以你首先需要一个Linux的系统主机。</p><h4 id="安装与配置-Docker"><a href="#安装与配置-Docker" class="headerlink" title="安装与配置 Docker"></a><strong>安装与配置 Docker</strong></h4><p><strong>安装 Docker</strong></p><p>Docker 软件包已经包括在默认的 CentOS-Extras 软件源里。因此想要安装 docker，只需要运行下面的 yum 命令：</p><pre><code>yum install docker-io -y直接yum安装，安装成功后查看版本docker -v启动dockerservice docker start设置开机启动chkconfig docker on配置 Docker</code></pre><p>因为国内访问 Docker Hub 较慢, 可以使用腾讯云提供的国内镜像源, 加速访问 Docker Hub</p><p>依次执行以下命令</p><pre><code>echo &quot;OPTIONS=&#39;--registry-mirror=https://mirror.ccs.tencentyun.com&#39;&quot; &gt;&gt; /etc/sysconfig/dockersystemctl daemon-reloadservice docker restart</code></pre><h4 id="Docker-上手"><a href="#Docker-上手" class="headerlink" title="Docker 上手"></a><strong>Docker 上手</strong></h4><p><strong>下载镜像</strong></p><pre><code>下载一个官方的 CentOS 镜像到本地docker pull centos下载好的镜像就会出现在镜像列表里docker images运行容器</code></pre><p>这时我们可以在刚才下载的 <strong>CentOS</strong> 镜像生成的容器内操作了。</p><p>生成一个 centos 镜像为模板的容器并使用 bash shell</p><pre><code>docker run -it centos /bin/bash</code></pre><p>这个时候可以看到命令行的前端已经变成了 <code>[root@(一串 hash Id)]</code> 的形式, 这说明我们已经成功进入了 CentOS 容器。</p><p>在容器内执行任意命令, 不会影响到宿主机, 如下</p><pre><code>mkdir -p /data/simple_docker可以看到 /data 目录下已经创建成功了 simple_docker 文件夹ls /data退出容器exit查看宿主机的 /data 目录, 并没有 simple_docker 文件夹, 说明容器内的操作不会影响到宿主机ls /data保存容器查看所有的容器信息， 能获取容器的iddocker ps -a然后执行如下命令[?]，保存镜像：docker commit -m=&quot;备注&quot; 你的CONTAINER_ID 你的IMAGE请自行将 -m 后面的信息改成自己的容器的信息</code></pre><p><strong>Docker容器的基本操作</strong></p><pre><code>docker [命令名] --help 查看命令介绍docker run 创建并启动一个容器，在run后面加上-d参数，则会创建一个守护式容器在后台运行。docker ps -a 查看已经创建的容器docker ps -s 查看已经启动的容器docker start con_name 启动容器名为con_name的容器docker stop con_name 停止容器名为con_name的容器docker rm con_name 删除容器名为con_name的容器docker rename old_name new_name 重命名一个容器docker attach con_name 将终端附着到正在运行的容器名为con_name的容器的终端上面去，前提是创建该容器时指定了相应的sh执行这个命令后，按下回车键，会进入容器的命令行Shell中。docker logs con_name 获取容器名为con_name的容器日志docker inspect 查看容器的详细信息docker top con_name 查看容器名为con_name的容器内部的进程docker exec 可以用来在容器中运行一个进程</code></pre><p><strong>Docker的详细操作</strong></p><p>不造轮子，<a href="http://www.runoob.com/docker/docker-container-usage.html">请戳菜鸟教程。</a></p><p><strong>shell脚本部署到Docker的一个小栗子</strong></p><blockquote><p>参考链接：</p></blockquote><blockquote><ul><li><a href="https://segmentfault.com/a/1190000004491286">docker清理镜像</a></li><li><a href="http://blog.51cto.com/onlyzq/546459">在Linux中让echo命令显示带颜色的字。</a></li></ul></blockquote><ul><li><code>echo -e &quot;\033[40;37m 黑底白字 \033[0m&quot;</code> 此方法是输入带上颜色</li><li>清理镜像的操作是一系列的。具体情况具体分析。例如另一个例子：</li><li><code>$ docker ps --filter &quot;status=exited&quot; | grep &#39;weeks ago&#39; | awk &#39;&#123;print $1&#125;&#39; | xargs --no-run-if-empty docker rm</code>，来自<a href="https://stackoverflow.com/questions/17236796/how-to-remove-old-docker-containers">How to remove old Docker containers</a> </li><li><code>awk</code>是一个文本分析工具，找出文本指定位置的内容并print出来（解释不当）</li></ul><pre><code># 声明变量SERVER_HOST=&quot;root@xx.x.xxx.xx&quot;SERVER_PATH=&quot;/home/test/src&quot;BUILD_TIME=`date &quot;+%Y%m%d%H%M&quot;`IMAGE_NAME=&quot;xxxx(docker镜像)&quot;# 传输之后特殊文件的修改rsync -cavzP --delete-after ./ --exclude-from=&#39;.rsync-exclude&#39; $SERVER_HOST:$SERVER_PATHrsync -cavzP --delete-after ./node_modules/ftp-client $SERVER_HOST:$SERVER_PATH/node_modulesssh $SERVER_HOST &quot;\  cd $SERVER_PATH; \  echo &quot;安装依赖&quot;; \  npm install; \  echo &quot;清理过时的测试镜像&quot;; \  docker images | awk &#39;&#123; print \$3 &#125;&#39; | xargs docker rmi ; \  echo &quot;构建docker镜像 $IMAGE_NAME&quot;; \  docker build -t $MAGE_NAME . ;\  echo &quot;发布docker镜像&quot;; \  docker push $IMAGE_NAME ;\  exit; \  &quot;echo &quot;\033[40;32m\n&quot;echo &quot;Sync to Server: $MARKET_SERVER_HOST&quot;echo &quot;Build source code path: $MARKET_SERVER_PATH&quot;echo &quot;Image: $MARKET_IMAGE_NAME&quot;echo &quot;Image deploy success&quot;echo &quot;\033[0m&quot;</code></pre><h2 id="Docker实践，利用DaoCloud来部署应用"><a href="#Docker实践，利用DaoCloud来部署应用" class="headerlink" title="Docker实践，利用DaoCloud来部署应用"></a><strong>Docker实践，利用DaoCloud来部署应用</strong></h2><p>该部分内容过多，请直接参考我的另一篇博客：<a href="http://blog.csdn.net/u013707249/article/details/78801575">Docker实践，利用DaoCloud来部署应用</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> Linux </tag>
            
            <tag> 持续集成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高性能打包工具：Webpack 对比 Parcel</title>
      <link href="/2017/12/12/"/>
      <url>/2017/12/12/</url>
      
        <content type="html"><![CDATA[<h1 id="Webpack-对比-Parcel"><a href="#Webpack-对比-Parcel" class="headerlink" title="Webpack 对比 Parcel"></a>Webpack 对比 Parcel</h1><blockquote><p>最近火的一塌糊涂的打包工具<code>parcel</code>,5天左右就已经达到了<strong>8K</strong>个star。相对于webpack的蜗牛编译，parcel宣称<strong>Parcel 使用 worker 进程去启用多核编译。同时有文件系统缓存，即使在重启构建后也能快速再编译</strong>。换句话说就是高性能，这也是它最吸引人的地方。</p><p>因为在项目被webpack折磨过，所以今天这里简单用两个小demo来测试一下。</p></blockquote><h2 id="官网地址"><a href="#官网地址" class="headerlink" title="官网地址"></a>官网地址</h2><ul><li><a href="https://parceljs.org/">官方网址</a></li><li><a href="http://www.parceljs.io/">Parcel中文网</a></li><li><a href="https://github.com/parcel-bundler/parcel">Github</a></li><li><a href="https://github.com/justjavac/parcel-example">其他同仁的测试</a></li><li><a href="https://juejin.im/post/5a2b6c0cf265da431523d4e2?utm_source=gold_browser_extension">Parceljs和Webpack在React项目上打包速度对比</a></li></ul><h2 id="初级测试"><a href="#初级测试" class="headerlink" title="初级测试"></a>初级测试</h2><p>这里有两个基于<code>webpack</code>和<code>parcel</code>构建的react小项目。</p><ul><li><a href="https://github.com/Michaelooo/webpackToParcel/tree/master/parcel_demo">parcel_demo</a></li><li><a href="https://github.com/Michaelooo/webpackToParcel/tree/master/webpack_demo">webpack_demo</a></li></ul><p>两个小项目同时引用了 <code>react</code> ,<code>react-demo</code>,以及用于解析的<code>babel-preset-react</code>。对于<code>webapck</code>,还引入了一个解析 es6 的<code>babel-loader</code>。</p><h3 id="速度对比"><a href="#速度对比" class="headerlink" title="速度对比"></a>速度对比</h3><p><strong>parcel初次构建</strong>（2s）</p><p><img src="http://ww1.sinaimg.cn/large/86c7c947gy1fmcnecmt65j20xa05s3zh.jpg"></p><p><strong>parcel已打包的情况下再次构建</strong> (556ms)<br><img src="http://ww1.sinaimg.cn/large/86c7c947gy1fmcnecnk99j20xw05yq3w.jpg"></p><p><strong>webpack初次构建</strong> (4s)<br><img src="http://ww1.sinaimg.cn/large/86c7c947gy1fmcnecmyj6j20ps060gms.jpg"></p><p><strong>webpack已打包的情况下再次构建</strong> (4s)</p><p>这里有些问题，因为未对webpack的配置做优化，比如提取公共模块，分开打包等，所以即使加了<code>cache = true </code>测出的结果和初次构建也差不多，都是 <strong>4s</strong>左右。</p><h2 id="进一步测试"><a href="#进一步测试" class="headerlink" title="进一步测试"></a>进一步测试</h2><p>正在进行中。。。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>不负责任版：</strong> 根据以上情况来看，<code>Parcel</code>在速度上来看确实有不小的优势，但是如果在一个已经用了<code>webpack</code>的项目迁移的话，估计还是会有些麻烦。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
            <tag> webpack </tag>
            
            <tag> parcel.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式笔记</title>
      <link href="/2017/12/11/"/>
      <url>/2017/12/11/</url>
      
        <content type="html"><![CDATA[<p>在学会使用下面的正则之前应该先了解基本的正则语法。可以从下面的链接进行学习。</p><ul><li><a href="http://yanhaijing.com/javascript/2017/08/06/regexp-syntax/">正则表达式教程——语法篇</a></li><li><a href="http://yanhaijing.com/javascript/2017/08/26/regexp-practice/">正则表达式教程——js实践篇</a></li><li><a href="http://deerchao.net/tutorials/regex/regex.htm">正则表达式30分钟入门教程</a></li><li><a href="https://regexper.com/#%5Cbis%5Cb">正则表达式可视化工具</a></li></ul><h2 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h2><p><strong>参考链接：</strong> <a href="http://www.jb51.net/article/77687.htm">常用正则表达式</a></p><p><strong>一、校验数字的表达式</strong></p><pre><code>1 数字：^[0-9]*$2 n位的数字：^\d&#123;n&#125;$3 至少n位的数字：^\d&#123;n,&#125;$4 m-n位的数字：^\d&#123;m,n&#125;$5 零和非零开头的数字：^(0|[1-9][0-9]*)$6 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$7 带1-2位小数的正数或负数：^(\-)?\d+(\.\d&#123;1,2&#125;)?$8 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$9 有两位小数的正实数：^[0-9]+(.[0-9]&#123;2&#125;)?$10 有1~3位小数的正实数：^[0-9]+(.[0-9]&#123;1,3&#125;)?$11 非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\+?[1-9][0-9]*$12 非零的负整数：^\-[1-9][]0-9&quot;*$ 或 ^-[1-9]\d*$13 非负整数：^\d+$ 或 ^[1-9]\d*|0$14 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$15 非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$16 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$17 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$18 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$19 浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$</code></pre><p><strong>二、校验字符的表达式</strong></p><pre><code>1 汉字：^[\u4e00-\u9fa5]&#123;0,&#125;$2 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$3 长度为3-20的所有字符：^.&#123;3,20&#125;$4 由26个英文字母组成的字符串：^[A-Za-z]+$5 由26个大写英文字母组成的字符串：^[A-Z]+$6 由26个小写英文字母组成的字符串：^[a-z]+$7 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$8 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w&#123;3,20&#125;$9 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$10 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]&#123;2,20&#125;$11 可以输入含有^%&amp;&#39;,;=?$\&quot;等字符：[^%&amp;&#39;,;=?$\x22]+12 禁止输入含有~的字符：[^~\x22]+</code></pre><p><strong>三、特殊需求表达式</strong></p><pre><code>1 Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$2 域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?3 InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$4 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d&#123;8&#125;$5 电话号码(&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX)：^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$6 国内电话号码(0511-4405222、021-87888822)：\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;7 身份证号(15位、18位数字)：^\d&#123;15&#125;|\d&#123;18&#125;$8 短身份证号码(数字、字母x结尾)：^([0-9])&#123;7,18&#125;(x|X)?$ 或 ^\d&#123;8,18&#125;|[0-9x]&#123;8,18&#125;|[0-9X]&#123;8,18&#125;?$9 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$10 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w&#123;5,17&#125;$11 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$12 日期格式：^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;13 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$14 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$15 钱的输入格式：    *. 有四种钱的表示形式我们可以接受:&quot;10000.00&quot; 和 &quot;10,000.00&quot;, 和没有 &quot;分&quot; 的 &quot;10000&quot; 和 &quot;10,000&quot;：^[1-9][0-9]*$    *. 这表示任意一个不以0开头的数字,但是,这也意味着一个字符&quot;0&quot;不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$    *. 一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$    *. 这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$    *. 必须说明的是,小数点后面至少应该有1位数,所以&quot;10.&quot;是不通过的,但是 &quot;10&quot; 和 &quot;10.2&quot; 是通过的：^[0-9]+(.[0-9]&#123;2&#125;)?$    *. 这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]&#123;1,2&#125;)?$    *. 这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$    *. 1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$    *. 备注：这就是最终结果了,别忘了&quot;+&quot;可以用&quot;*&quot;替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里16 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$17 中文字符的正则表达式：[\u4e00-\u9fa5]18 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))19 空白行的正则表达式：\n\s*\r (可以用来删除空白行)20 HTML标记的正则表达式：&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;|&lt;.*? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)21 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)22 腾讯QQ号：[1-9][0-9]&#123;4,&#125; (腾讯QQ号从10000开始)23 中国邮政编码：[1-9]\d&#123;5&#125;(?!\d) (中国邮政编码为6位数字)24 IP地址：\d+\.\d+\.\d+\.\d+ (提取IP地址时有用)25 IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))</code></pre>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转载】Linux搭建 Node.js 环境</title>
      <link href="/2017/12/10/"/>
      <url>/2017/12/10/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux搭建-Node-js-环境"><a href="#Linux搭建-Node-js-环境" class="headerlink" title="Linux搭建 Node.js 环境"></a>Linux搭建 Node.js 环境</h1><h2 id="安装-Node-js-环境"><a href="#安装-Node-js-环境" class="headerlink" title="安装 Node.js 环境"></a>安装 Node.js 环境</h2><p>Node.js 是运行在服务端的 JavaScript, 是基于 Chrome JavaScript V8 引擎建立的平台。</p><h3 id="下载并安装-Node-js"><a href="#下载并安装-Node-js" class="headerlink" title="下载并安装 Node.js"></a>下载并安装 Node.js</h3><p>下载最新的稳定版 v6.10.3 到本地</p><pre><code>wget https://nodejs.org/dist/v6.10.3/node-v6.10.3-linux-x64.tar.xz</code></pre><p>下载完成后, 将其解压</p><pre><code>tar xvJf node-v6.10.3-linux-x64.tar.xz</code></pre><p>将解压的 Node.js 目录移动到 &#x2F;usr&#x2F;local 目录下</p><pre><code>mv node-v6.10.3-linux-x64 /usr/local/node-v6</code></pre><p>配置 node 软链接到 &#x2F;bin 目录</p><pre><code>ln -s /usr/local/node-v6/bin/node /bin/node</code></pre><h2 id="配置和使用-npm"><a href="#配置和使用-npm" class="headerlink" title="配置和使用 npm"></a>配置和使用 npm</h2><h3 id="配置-npm"><a href="#配置-npm" class="headerlink" title="配置 npm"></a>配置 npm</h3><p>npm 是 Node.js 的包管理和分发工具。它可以让 Node.js 开发者能够更加轻松的共享代码和共用代码片段</p><p>下载 node 的压缩包中已经包含了 npm , 我们只需要将其软链接到 bin 目录下即可</p><pre><code>ln -s /usr/local/node-v6/bin/npm /bin/npm</code></pre><p>配置环境变量</p><p>将 <code>/usr/local/node-v6/bin</code> 目录添加到 $PATH 环境变量中可以方便地使用通过 npm 全局安装的第三方工具</p><p><code>echo &#39;export PATH=/usr/local/node-v6/bin:$PATH&#39; &gt;&gt; /etc/profile</code><br>生效环境变量</p><pre><code>source /etc/profile</code></pre><h3 id="使用-npm"><a href="#使用-npm" class="headerlink" title="使用 npm"></a>使用 npm</h3><p>通过 npm 安装进程管理模块 forever</p><p>npm install forever -g<br>完成实验</p><p>恭喜！您已经成功完成了搭建 Node.js 环境的实验任务。</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大神的自我修养 co.js 的学习</title>
      <link href="/2017/12/09/"/>
      <url>/2017/12/09/</url>
      
        <content type="html"><![CDATA[<h1 id="大神的自我修养-co-js-的学习"><a href="#大神的自我修养-co-js-的学习" class="headerlink" title="大神的自我修养 co.js 的学习"></a><strong>大神的自我修养 co.js 的学习</strong></h1><p>最近在项目过程中涉及大量异步流程处理，其中有使用各种流程控制库，大家用的最多的 <code>async</code>，号称promise性能超原生的 <code>bluebird</code>，还有tj大神的<code>co.js</code>等。可以说是相当多了，于是空暇期间来整理一下promise的学习。</p><p>今天来看的就是TJ大神的非常精炼的 co.js 。</p><p>具体的介绍就不多说了。要注意的一点就是，<a href="mailto:&#x63;&#x6f;&#x40;&#52;&#x2e;&#48;">&#x63;&#x6f;&#x40;&#52;&#x2e;&#48;</a>之前返回的是一个<code>trunk</code>函数，现在<a href="mailto:&#99;&#x6f;&#x40;&#52;&#x2e;&#48;">&#99;&#x6f;&#x40;&#52;&#x2e;&#48;</a>支持promise，现在co()会返回一个promise。<br><img src="http://ww1.sinaimg.cn/large/86c7c947gy1fm8c112bnwj20g205aglz.jpg"></p><h2 id="先看用法"><a href="#先看用法" class="headerlink" title="先看用法"></a><strong>先看用法</strong></h2><h3 id="yield支持"><a href="#yield支持" class="headerlink" title="yield支持"></a><strong>yield支持</strong></h3><p>co最方便的操作也就是yield的支持，现在支持yield的对象有：</p><ul><li>promises</li><li>thunks (functions)</li><li>array (parallel execution)</li><li>objects (parallel execution)</li><li>generators (delegation)</li><li>generator functions (delegation)</li></ul><p>下文在源码里有体现。</p><h3 id="一个官网的小例子🌰"><a href="#一个官网的小例子🌰" class="headerlink" title="一个官网的小例子🌰"></a><strong>一个官网的小例子🌰</strong></h3><pre><code>var co = require(&#39;co&#39;);co(function *()&#123;  // 执行promise  var result = yield Promise.resolve(true);&#125;).catch(onerror);co(function *()&#123;  // 并行执行多个promise  var a = Promise.resolve(1);  var b = Promise.resolve(2);  var c = Promise.resolve(3);  var res = yield [a, b, c];  console.log(res);  // =&gt; [1, 2, 3]&#125;).catch(onerror);// 错误捕捉co(function *()&#123;  try &#123;    yield Promise.reject(new Error(&#39;boom&#39;));  &#125; catch (err) &#123;    console.error(err.message); // &quot;boom&quot; &#125;&#125;).catch(onerror);function onerror(err) &#123;  console.error(err.stack);&#125;// 将一个generator函数转换成返回一个promise函数的方法var fn = co.wrap(function* (val) &#123;  return yield Promise.resolve(val);&#125;);fn(true).then(function (val) &#123;&#125;);</code></pre><h2 id="看源码"><a href="#看源码" class="headerlink" title="看源码"></a><strong>看源码</strong></h2><h3 id="wrap-函数的实现"><a href="#wrap-函数的实现" class="headerlink" title="wrap 函数的实现"></a><strong>wrap 函数的实现</strong></h3><p>大神写的代码就是十分的精炼，wrap 函数的实现也只是7行代码而已。</p><p><img src="http://ww1.sinaimg.cn/large/86c7c947gy1fm8c92jch2j20cr0460sy.jpg"></p><p>其实有两点需要注意的，就是：</p><ol><li><strong>没有写在原型链上而是作为一个私有方法是为了避免每次执行<code>co()</code>的时候生成一个新的wrap方法，这个方法显然没必要。</strong></li><li><strong>关键在于返回了一个<code>co()</code>,因为<code>co()</code>会 return 一个 promise，即生成一个新的promise。同时利用 call 和 apply 改变了 this 的指向，指向 <code>co</code> 。</strong></li></ol><h3 id="并行多个promise"><a href="#并行多个promise" class="headerlink" title="并行多个promise"></a><strong>并行多个promise</strong></h3><p>其实 co 方法的主体不用细看，基本就是按照 es6 promise 的一种重写。这里需要注意的一点就是并行支持promise。即，当 yield 一个 object 或者 array 的时候，并行执行多个 promise。</p><p>一开始当我听到并行的时候，是有点懵的，但看到源码的时候发现没有想得那么复杂，其实就是 promise 的原生方法的功劳：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all">promise.all()</a>,可以往下看。。。</p><p><img src="http://ww1.sinaimg.cn/large/86c7c947gy1fm8cz6i569j20h204qdgk.jpg"></p><p>这里的 <code>toPromise()</code> 是在 next 方法的实现中执行的，关键的代码就两句：</p><pre><code>var value = toPromise.call(ctx, ret.value);if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected);</code></pre><p>然后，就是 <code>arrayToPromise</code> 和 <code>objectToPromise</code> 两个方法的实现：</p><p><img src="http://ww1.sinaimg.cn/large/86c7c947gy1fm8cz6jak7j20dk0dnq49.jpg"></p><p>就是这么简单……</p><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1512702212168&di=9bc459180689c8af63056bc2c0a9ca2e&imgtype=jpg&src=http://img4.imgtn.bdimg.com/it/u=2105664939,4183524365&fm=214&gp=0.jpg"></p><h3 id="庐山真面目，真正的源码"><a href="#庐山真面目，真正的源码" class="headerlink" title="庐山真面目，真正的源码"></a><strong>庐山真面目，真正的源码</strong></h3><pre><code>var slice = Array.prototype.slice;module.exports = co[&#39;default&#39;] = co.co = co;co.wrap = function (fn) &#123;  createPromise.__generatorFunction__ = fn;  return createPromise;  function createPromise() &#123;    return co.call(this, fn.apply(this, arguments));  &#125;&#125;;function co(gen) &#123;  var ctx = this;  var args = slice.call(arguments, 1);  return new Promise(function(resolve, reject) &#123;    if (typeof gen === &#39;function&#39;) gen = gen.apply(ctx, args);    if (!gen || typeof gen.next !== &#39;function&#39;) return resolve(gen);    onFulfilled();    function onFulfilled(res) &#123;      var ret;      try &#123;        ret = gen.next(res);      &#125; catch (e) &#123;        return reject(e);      &#125;      next(ret);      return null;    &#125;    function onRejected(err) &#123;      var ret;      try &#123;        ret = gen.throw(err);      &#125; catch (e) &#123;        return reject(e);      &#125;      next(ret);    &#125;    function next(ret) &#123;      if (ret.done) return resolve(ret.value);      var value = toPromise.call(ctx, ret.value);      if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected);      return onRejected(new TypeError(&#39;You may only yield a function, promise, generator, array, or object, &#39;        + &#39;but the following object was passed: &quot;&#39; + String(ret.value) + &#39;&quot;&#39;));    &#125;  &#125;);&#125;function toPromise(obj) &#123;  if (!obj) return obj;  if (isPromise(obj)) return obj;  if (isGeneratorFunction(obj) || isGenerator(obj)) return co.call(this, obj);  if (&#39;function&#39; == typeof obj) return thunkToPromise.call(this, obj);  if (Array.isArray(obj)) return arrayToPromise.call(this, obj);  if (isObject(obj)) return objectToPromise.call(this, obj);  return obj;&#125;function thunkToPromise(fn) &#123;  var ctx = this;  return new Promise(function (resolve, reject) &#123;    fn.call(ctx, function (err, res) &#123;      if (err) return reject(err);      if (arguments.length &gt; 2) res = slice.call(arguments, 1);      resolve(res);    &#125;);  &#125;);&#125;function arrayToPromise(obj) &#123;  return Promise.all(obj.map(toPromise, this));&#125;function objectToPromise(obj)&#123;  var results = new obj.constructor();  var keys = Object.keys(obj);  var promises = [];  for (var i = 0; i &lt; keys.length; i++) &#123;    var key = keys[i];    var promise = toPromise.call(this, obj[key]);    if (promise &amp;&amp; isPromise(promise)) defer(promise, key);    else results[key] = obj[key];  &#125;  return Promise.all(promises).then(function () &#123;    return results;  &#125;);  function defer(promise, key) &#123;    // predefine the key in the result    results[key] = undefined;    promises.push(promise.then(function (res) &#123;      results[key] = res;    &#125;));  &#125;&#125;function isPromise(obj) &#123;  return &#39;function&#39; == typeof obj.then;&#125;function isGenerator(obj) &#123;  return &#39;function&#39; == typeof obj.next &amp;&amp; &#39;function&#39; == typeof obj.throw;&#125; function isGeneratorFunction(obj) &#123;  var constructor = obj.constructor;  if (!constructor) return false;  if (&#39;GeneratorFunction&#39; === constructor.name || &#39;GeneratorFunction&#39; === constructor.displayName) return true;  return isGenerator(constructor.prototype);&#125;function isObject(val) &#123;  return Object == val.constructor;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> nodejs </tag>
            
            <tag> promise </tag>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于JS事件队列的一些总结</title>
      <link href="/2017/12/08/"/>
      <url>/2017/12/08/</url>
      
        <content type="html"><![CDATA[<h1 id="关于JS事件队列的一些总结"><a href="#关于JS事件队列的一些总结" class="headerlink" title="关于JS事件队列的一些总结"></a><strong>关于JS事件队列的一些总结</strong></h1><h2 id="关于任务队列"><a href="#关于任务队列" class="headerlink" title="关于任务队列"></a><strong>关于任务队列</strong></h2><p>其实之所以我们要去关心JS的任务队列，主要还是因为JS的单线程的特质决定。</p><h3 id="为什么JavaScript是单线程？"><a href="#为什么JavaScript是单线程？" class="headerlink" title="为什么JavaScript是单线程？"></a><strong>为什么JavaScript是单线程？</strong></h3><p>本段来自阮老师的博客中对JS单线程的介绍。</p><blockquote><p>JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。</p><p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p><p>所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p><p>为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。</p></blockquote><h3 id="任务队列的本质"><a href="#任务队列的本质" class="headerlink" title="任务队列的本质"></a><strong>任务队列的本质</strong></h3><ul><li>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</li><li>主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</li><li>一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li><li>主线程不断重复上面的第三步。</li></ul><h2 id="关于-setTimeOut、setImmediate、process-nextTick-的比较"><a href="#关于-setTimeOut、setImmediate、process-nextTick-的比较" class="headerlink" title="关于 setTimeOut、setImmediate、process.nextTick()的比较"></a><strong>关于 setTimeOut、setImmediate、process.nextTick()的比较</strong></h2><h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout()"></a><strong>setTimeout()</strong></h3><ul><li>将事件插入到了事件队列，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。</li><li>当主线程时间执行过长，无法保证回调会在事件指定的时间执行。</li><li>浏览器端每次<code>setTimeout </code>会有4ms的延迟，当连续执行多个<code>setTimeout </code>，有可能会阻塞进程，造成性能问题。</li></ul><h3 id="setImmediate"><a href="#setImmediate" class="headerlink" title="setImmediate()"></a><strong>setImmediate()</strong></h3><ul><li>事件插入到事件队列尾部，主线程和事件队列的函数执行完成之后立即执行。和setTimeout(fn,0)的效果差不多。</li><li>服务端node提供的方法。浏览器端最新的api也有类似实现:<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setImmediate">window.setImmediate</a>,但支持的浏览器很少。</li></ul><h3 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a><strong>process.nextTick()</strong></h3><ul><li>插入到事件队列尾部，但在下次事件队列之前会执行。也就是说，它指定的任务总是发生在所有异步任务之前，当前主线程的末尾。</li><li>大致流程：当前”执行栈”的尾部–&gt;下一次Event Loop（主线程读取”任务队列”）之前–&gt;触发process指定的回调函数。</li><li>服务器端node提供的办法。用此方法可以用于处于异步延迟的问题。</li><li>可以理解为：此次不行，预约下次优先执行。</li></ul><h2 id="关于消除-setTimeout-延迟的实践：soon-js"><a href="#关于消除-setTimeout-延迟的实践：soon-js" class="headerlink" title="关于消除 setTimeout 延迟的实践：soon.js"></a><strong>关于消除 setTimeout 延迟的实践：soon.js</strong></h2><h3 id="why"><a href="#why" class="headerlink" title="why?"></a><strong>why?</strong></h3><p>如<code>setTimeout</code> 的介绍所言，浏览器端每次<code>setTimeout </code>会有4ms的延迟，当连续执行多个<code>setTimeout </code>，有可能会阻塞进程，造成性能问题。</p><p><code>soon.js</code>就是关于这个问题的一个好的实践。但其实大多数情况我们不必为这4ms的延迟计较，除非你在一次执行中<code>setTimeout</code>的次数足够多。代码很短，可以用来学习下。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h3><p>可以参考<a href="https://jsfiddle.net/0tscgwe6/2/">示例</a></p><h3 id="源码："><a href="#源码：" class="headerlink" title="源码："></a><strong>源码：</strong></h3><pre><code>// See http://www.bluejava.com/4NS/Speed-up-your-Websites-with-a-Faster-setTimeout-using-soon// 使用 soon.js 处理在浏览器端 settimeout（大量调用），4ms * n 的延迟问题var soon = (function() &#123;            var fq = []; // 事件队列;            function callQueue()        &#123;            while(fq.length) // 执行队列中事件            &#123;                var fe = fq[0];                fe.f.apply(fe.m,fe.a) // 执行队列中事件                fq.shift();             &#125;        &#125;            // 异步执行队列事件，最大效率        var cqYield = (function() &#123;                    // 通过 MutationObserver 来监听 Dom 来执行回调，此法最快                if(typeof MutationObserver !== &quot;undefined&quot;)                &#123;                    var dd = document.createElement(&quot;div&quot;);                    var mo = new MutationObserver(callQueue);                    mo.observe(dd, &#123; attributes: true &#125;);                        return function(fn) &#123; dd.setAttribute(&quot;a&quot;,0); &#125; // trigger callback to                &#125;                    // 如果支持 setImmediate ，采取此策略，其实 setImmediate 和 setTimeout(callQueue,0) 差不多                if(typeof setImmediate !== &quot;undefined&quot;)                    return function() &#123; setImmediate(callQueue) &#125;                    // 没办法了，就用 setTimeOut 的办法                return function() &#123; setTimeout(callQueue,0) &#125;            &#125;)();            return function(fn) &#123;                // 队列事件装载进一个数组                fq.push(&#123;f:fn,a:[].slice.apply(arguments).splice(1),m:this&#125;);                    if(fq.length == 1) // 在添加第一个条目时，启动回调函数                    cqYield();            &#125;;        &#125;)();</code></pre><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a><strong>分析</strong></h3><p>其实，值得分析就是一个新的东西–<code>MutationObserver</code>。</p><p><code>MutationObserver</code>给开发者们提供了一种能在某个范围内的DOM树发生变化时作出适当反应的能力.该API设计用来替换掉在DOM3事件规范中引入的<a href="https://developer.mozilla.org/zh-CN/docs/DOM/Mutation_events">Mutation</a>事件.</p><p>简而言之，就是这个东西比<code>setTimeOut</code>，<code>setImmediate</code>快，浏览器支持就用它就行了。</p><p>关于<code>soon.js</code>的更详细的介绍可以查看这篇文章。<a href="http://www.bluejava.com/4NS/Speed-up-your-Websites-with-a-Faster-setTimeout-using-soon">Speed up your Websites with a Faster setTimeout using soon()</a></p><p><code>MutationObserver</code>给开发者们提供了一种能在某个范围内的DOM树发生变化时作出适当反应的能力.该API设计用来替换掉在DOM3事件规范中引入的<a href="https://developer.mozilla.org/zh-CN/docs/DOM/Mutation_events">Mutation</a>事件.</p><h2 id="参考博客："><a href="#参考博客：" class="headerlink" title="参考博客："></a><strong>参考博客：</strong></h2><ul><li><p><a href="http://www.cnblogs.com/cdwp8/p/4065846.html">setTimeout和setImmediate以及process.nextTick的区别</a></p></li><li><p><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html">JavaScript 运行机制详解：再谈Event Loop</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> JS事件队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>轮子：一个简单的node爬虫踩坑之路</title>
      <link href="/2017/12/07/"/>
      <url>/2017/12/07/</url>
      
        <content type="html"><![CDATA[<h1 id="一个简单的node爬虫踩坑之路"><a href="#一个简单的node爬虫踩坑之路" class="headerlink" title="一个简单的node爬虫踩坑之路"></a>一个简单的node爬虫踩坑之路</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>最近在看爬虫相关的文章，偶然想起来尝试一下用node来实现一个简单的爬虫。但是爬别的多没意思，当然是爬美女图片啊。。。</p><p>这大概 node 里面造的最多的轮子了。</p><p>于是，我选取了下面的地址：<a href="http://www.zbjuran.com/mei/">美女图片戳我</a>，简单分析后，我的目标是通过爬取首页的轮播图，然后爬取轮播图的直链后面的详情大图，并按照图片名称存到指定的文件夹中。<br>大致流程是下面这个样子的：</p><p><img src="https://t1.picb.cc/uploads/2017/12/06/px1gr.jpg" alt="爬取的大致流程"></p><p>看起来挺简单的，选用的技术方案是：</p><ul><li><code>superagent</code>: 请求库</li><li><code>mkdirp</code>: 创建文件夹</li><li><code>async</code>: 控制并发请求</li><li><code>cheerio</code>: Dom操作库</li><li><code>fs</code>: 内置核心文件读写库</li></ul><h2 id="最终的效果"><a href="#最终的效果" class="headerlink" title="最终的效果"></a>最终的效果</h2><p><img src="https://t1.picb.cc/uploads/2017/12/06/pxHd1.jpg" alt="哈哈"></p><h2 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h2><pre><code>// 关键在于理清异步流程&#39;use strict&#39;let fs = require(&quot;fs&quot;);let cheerio = require(&#39;cheerio&#39;);let asyncQuene = require(&quot;async&quot;).queue;let request = require(&#39;superagent&#39;);require(&#39;superagent-charset&#39;)(request);const config = &#123;    urlPre: &#39;http://www.zbjuran.com&#39;,    indexUrl: &#39;http://www.zbjuran.com/mei/&#39;,    downloadConcurrent: 2, &#125;;let getHtmlAsync = (url) =&gt; &#123;    return new Promise((resolve,reject) =&gt; &#123;        request.get(url).charset(&#39;gbk&#39;).end((err,res) =&gt; &#123;            err ? reject(err) : resolve(cheerio.load(res.text));        &#125;)    &#125;)&#125;let dowloadImg = (albumList) =&gt; &#123;    console.log(&#39;开始下载图片&#39;);    const folder = &#39;./grils/&#39;;    fs.existsSync(folder, status =&gt; &#123;        status ? &#39;&#39; : fs.mkdirSync(folder);    &#125;)    let downloadCount = 0;    let queue = asyncQuene( (&#123; url: albumUrl, title: albumTitle&#125;,done) =&gt; &#123;        request.get(albumUrl).end(function (err, res) &#123;            if (err) &#123;                console.log(err);                done();            &#125; else &#123;                fs.writeFile(`./$&#123;folder&#125;/$&#123;albumTitle&#125;-$&#123;++downloadCount&#125;.jpg`, res.body, function (err) &#123;                    err ? console.log(err) : console.log(`$&#123;albumTitle&#125;保存一张`);                    done();                &#125;);            &#125;        &#125;);    &#125;,config.downloadConcurrent);    queue.drain = () =&gt; &#123;        console.log(&#39;所有图片已经下载&#39;);    &#125;    let imgListTemp = [];    albumList.forEach(function (&#123; title, imgList &#125;) &#123;        console.log(title,imgList);        imgList.forEach(function (url) &#123;            imgListTemp.push(&#123; title: title, url: url &#125;);        &#125;);    &#125;);    console.log(&#39;sssss&#39;,albumList,imgListTemp);    queue.push(imgListTemp);//将所有任务加入队列&#125;let getIndexAsync = () =&gt; &#123;    return new Promise((resolve, reject) =&gt;&#123;        console.log(&#39;进入主页，开始获取目标url&#39;);        let targetUrl = [];        let queue = asyncQuene(async (url, done) =&gt; &#123;            try &#123;                let $ = await getHtmlAsync(url);                console.log(`成功获取主页$&#123;url&#125;`);                $(&#39;div.changeDiv a&#39;).each( (index,value) =&gt; &#123;                    targetUrl.push(&#123;                        title: value.attribs.title,                        url: `$&#123;config.urlPre&#125;$&#123;value.attribs.href&#125;`,                        imgList: []                    &#125;)                &#125;);            &#125; catch (err) &#123;                console.log(`在访问$&#123;url&#125;出现以下错误：$&#123;err&#125;`);            &#125;            finally &#123;                done();            &#125;        &#125;,config.downloadConcurrent);        queue.drain = () =&gt; &#123;            console.log(&#39;已成功生成目标Url&#39;);            resolve(targetUrl);        &#125;        queue.push(config.indexUrl);    &#125;)&#125;let getTargetAsync = (targetUrl) =&gt; &#123;    return new Promise((resolve, reject) =&gt;&#123;        console.log(&#39;进入目标页，开始获取目标url&#39;);        let queue = asyncQuene(async (&#123; url: url, title: title, imgList &#125;,done) =&gt; &#123;            try &#123;                let $ = await getHtmlAsync(url);                console.log(`成功获取主页$&#123;url&#125;`);                let imgLength = $(&#39;div.page &gt; li&#39;).length - 3;                $(&#39;div.picbox img&#39;).each( (index,value) =&gt; &#123;                    let imgSrcPath = value.attribs.src;                    imgList.push(`$&#123;config.urlPre&#125;$&#123;value.attribs.src&#125;`);                    for (let i = 0,length = imgLength; i &lt; length; i++) &#123;                        if(i &gt;= 1)&#123;                            imgList.push(`$&#123;config.urlPre&#125;$&#123;imgSrcPath.replace(&#39;-0&#39;,&#39;-&#39;+i)&#125;.jpg`);                        &#125;                    &#125;                &#125;);            &#125; catch (err) &#123;                console.log(`在访问$&#123;url&#125;出现以下错误：$&#123;err&#125;`);            &#125;            finally &#123;                done();            &#125;        &#125;,config.downloadConcurrent);        queue.drain = () =&gt; &#123;            console.log(&#39;已成功获取到所有图片的Url&#39;);            resolve(targetUrl);        &#125;        queue.push(targetUrl);    &#125;)&#125;let spider = async () =&gt; &#123;    // let albumList = await getAlbumsAsync();//获取所有画册URL    // albumList = await getImageListAsync(albumList);//根据画册URL获取画册里的所有图片URL    // downloadImg(albumList);//下载画册里面的所有图片    let targetUrl = await getIndexAsync();    targetUrl = await getTargetAsync(targetUrl);    dowloadImg(targetUrl);&#125;spider();</code></pre><h2 id="划重点"><a href="#划重点" class="headerlink" title="划重点"></a>划重点</h2><h3 id="1-当爬取网页编码为-gb2312的网页的时候，爬到的内容中文显示是乱码"><a href="#1-当爬取网页编码为-gb2312的网页的时候，爬到的内容中文显示是乱码" class="headerlink" title="1.当爬取网页编码为 gb2312的网页的时候，爬到的内容中文显示是乱码"></a>1.当爬取网页编码为 <code>gb2312</code>的网页的时候，爬到的内容中文显示是乱码</h3><p>这个问题的原因其实是挺清晰的，就是网页编码与本地编码不一致或不支持引起的。以为只是个小问题，但是在找解决办法的时候却纠结了我很久，查询了网上相关资料，<strong>有说使用 <code>iconv</code> 解码<code>decode</code>一下就可以，然并卵</strong>，<strong>有说使用encoding的，其实也没用</strong>。其实最后查阅资料得出的原因是，<code>superagent</code>只支持utf-8的编码，如果需要支持其他的需要引用一个官方的库：<code>superagent-charset</code>,使用方法如下：</p><pre><code>const request = require(&#39;superagent&#39;);require(&#39;superagent-charset&#39;)(request);//请求request.get(&#39;xxx&#39;).set(&#39;gbk&#39;).end(xxxxx)</code></pre><p>如此，即可正常返回中文</p><h3 id="2-异步操作用-async-来控制"><a href="#2-异步操作用-async-来控制" class="headerlink" title="2. 异步操作用 async 来控制"></a>2. 异步操作用 async 来控制</h3><p>对于下载图片，访问 url 这样存在异步的操作，如果操作对后面程序的执行有影响，最好使用 <a href="http://caolan.github.io/async/"><code>async</code></a> 库来控制异步流程，类似的还有 <a href="https://github.com/JacksonTian/eventproxy"><code>eventproxy</code></a>。</p><p>下面是一个使用来<code>async</code>来控制请求队列的官网示例，</p><pre><code>// create a queue object with concurrency 2var q = async.queue(function(task, callback) &#123;    console.log(&#39;hello &#39; + task.name);    callback();&#125;, 2);// assign a callbackq.drain = function() &#123;    console.log(&#39;all items have been processed&#39;);&#125;;// add some items to the queueq.push(&#123;name: &#39;foo&#39;&#125;, function(err) &#123;    console.log(&#39;finished processing foo&#39;);&#125;);q.push(&#123;name: &#39;bar&#39;&#125;, function (err) &#123;    console.log(&#39;finished processing bar&#39;);&#125;);// add some items to the queue (batch-wise)q.push([&#123;name: &#39;baz&#39;&#125;,&#123;name: &#39;bay&#39;&#125;,&#123;name: &#39;bax&#39;&#125;], function(err) &#123;    console.log(&#39;finished processing item&#39;);&#125;);// add some items to the front of the queueq.unshift(&#123;name: &#39;bar&#39;&#125;, function (err) &#123;    console.log(&#39;finished processing bar&#39;);&#125;);</code></pre><p>其实官网有好多栗子，近期还会抽时间好好研究一下类似异步流程库的具体实现。</p><h3 id="3-404错误。获取不到资源"><a href="#3-404错误。获取不到资源" class="headerlink" title="3. 404错误。获取不到资源"></a>3. 404错误。获取不到资源</h3><p>这个其实还好，主要是网站为了防爬的措施，可以尝试一下方法来试试看：</p><ul><li>设置<code>user-agent</code></li><li>降低请求的并发量</li><li>更换IP</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然只是一个简单的爬虫，但是发现自己对于 <code>promise</code> 这种的异步流程还不是很熟悉，这点需要重点掌握。</p><p>另外，从爬虫的角度来说，node现在的库已经很完善了，还有 <code>phantomjs</code>，<code>node-crawl</code> 这种操作更6的库存在，掌握一门工具很容易，更重要的是要学会制作工具。</p><p>最后，练习爬虫只是出于对技术的热爱，莫要乱爬。</p>]]></content>
      
      
      <categories>
          
          <category> nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建 GIT 服务器教程</title>
      <link href="/2017/12/06/"/>
      <url>/2017/12/06/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建-GIT-服务器教程"><a href="#搭建-GIT-服务器教程" class="headerlink" title="搭建 GIT 服务器教程"></a>搭建 GIT 服务器教程</h1><h2 id="1-下载安装-git"><a href="#1-下载安装-git" class="headerlink" title="1.下载安装 git"></a>1.下载安装 git</h2><p>Git 是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。<br>此实验以 CentOS 7.2 x64 的系统为环境，搭建 git 服务器。</p><h3 id="安装依赖库和编译工具"><a href="#安装依赖库和编译工具" class="headerlink" title="安装依赖库和编译工具"></a>安装依赖库和编译工具</h3><p>为了后续安装能正常进行，我们先来安装一些相关依赖库和编译工具</p><pre><code>yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel</code></pre><p>安装编译工具</p><pre><code>yum install gcc perl-ExtUtils-MakeMaker</code></pre><h3 id="下载-git"><a href="#下载-git" class="headerlink" title="下载 git"></a>下载 git</h3><p>选一个目录，用来放下载下来的安装包，这里将安装包放在 &#x2F;usr&#x2F;local&#x2F;src 目录里</p><pre><code>cd /usr/local/src</code></pre><p>到官网找一个新版稳定的源码包下载到 &#x2F;usr&#x2F;local&#x2F;src 文件夹里</p><pre><code>wget https://www.kernel.org/pub/software/scm/git/git-2.10.0.tar.gz</code></pre><h3 id="解压和编译"><a href="#解压和编译" class="headerlink" title="解压和编译"></a>解压和编译</h3><p>解压下载的源码包</p><pre><code>tar -zvxf git-2.10.0.tar.gz</code></pre><p>解压后进入 git-2.10.0 文件夹</p><pre><code>cd git-2.10.0</code></pre><p>执行编译</p><pre><code>make all prefix=/usr/local/git</code></pre><p>编译完成后, 安装到 &#x2F;usr&#x2F;local&#x2F;git 目录下</p><pre><code>make install prefix=/usr/local/git</code></pre><h2 id="2-配置环境变量"><a href="#2-配置环境变量" class="headerlink" title="2.配置环境变量"></a>2.配置环境变量</h2><p>将 git 目录加入 PATH<br>将原来的 PATH 指向目录修改为现在的目录</p><pre><code>echo &#39;export PATH=$PATH:/usr/local/git/bin&#39; &gt;&gt; /etc/bashrc</code></pre><p>生效环境变量</p><pre><code>source /etc/bashrc</code></pre><p>此时我们能查看 git 版本号，说明我们已经安装成功了。</p><pre><code>git --version</code></pre><h2 id="3-创建-git-账号密码"><a href="#3-创建-git-账号密码" class="headerlink" title="3.创建 git 账号密码"></a>3.创建 git 账号密码</h2><p>创建 git 账号<br>为我们刚刚搭建好的 git 创建一个账号</p><pre><code>useradd -m gituser</code></pre><p>然后为这个账号设置密码</p><pre><code> passwd gituser</code></pre><h2 id="4-初始化-git-仓库并配置用户权限"><a href="#4-初始化-git-仓库并配置用户权限" class="headerlink" title="4.初始化 git 仓库并配置用户权限"></a>4.初始化 git 仓库并配置用户权限</h2><h3 id="创建-git-仓库并初始化"><a href="#创建-git-仓库并初始化" class="headerlink" title="创建 git 仓库并初始化"></a>创建 git 仓库并初始化</h3><p>我们创建 &#x2F;data&#x2F;repositories 目录用于存放 git 仓库</p><pre><code>mkdir -p /data/repositories</code></pre><p>创建好后，初始化这个仓库</p><pre><code>cd /data/repositories/ &amp;&amp; git init --bare test.git</code></pre><h3 id="配置用户权限"><a href="#配置用户权限" class="headerlink" title="配置用户权限"></a>配置用户权限</h3><p>给 git 仓库目录设置用户和用户组并设置权限</p><pre><code>chown -R gituser:gituser /data/repositorieschmod 755 /data/repositories</code></pre><p>查找 git-shell 所在目录<br> , 编辑 &#x2F;etc&#x2F;passwd 文件，将最后一行关于 gituser 的登录 shell 配置改为 git-shell 的目录<br>如下</p><pre><code>root:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinsync:x:5:0:sync:/sbin:/bin/syncshutdown:x:6:0:shutdown:/sbin:/sbin/shutdownhalt:x:7:0:halt:/sbin:/sbin/haltmail:x:8:12:mail:/var/spool/mail:/sbin/nologinoperator:x:11:0:operator:/root:/sbin/nologingames:x:12:100:games:/usr/games:/sbin/nologinftp:x:14:50:FTP User:/var/ftp:/sbin/nologinnobody:x:99:99:Nobody:/:/sbin/nologinavahi-autoipd:x:170:170:Avahi IPv4LL Stack:/var/lib/avahi-autoipd:/sbin/nologinsystemd-bus-proxy:x:999:997:systemd Bus Proxy:/:/sbin/nologinsystemd-network:x:998:996:systemd Network Management:/:/sbin/nologindbus:x:81:81:System message bus:/:/sbin/nologinpolkitd:x:997:995:User for polkitd:/:/sbin/nologinabrt:x:173:173::/etc/abrt:/sbin/nologinlibstoragemgmt:x:996:994:daemon account for libstoragemgmt:/var/run/lsm:/sbin/nologintss:x:59:59:Account used by the trousers package to sandbox the tcsd daemon:/dev/null:/sbin/nologinntp:x:38:38::/etc/ntp:/sbin/nologinpostfix:x:89:89::/var/spool/postfix:/sbin/nologinchrony:x:995:993::/var/lib/chrony:/sbin/nologinsshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologintcpdump:x:72:72::/:/sbin/nologingituser:x:500:500::/home/gituser:/usr/local/git/bin/git-shell</code></pre><h3 id="使用搭建好的-Git-服务"><a href="#使用搭建好的-Git-服务" class="headerlink" title="使用搭建好的 Git 服务"></a>使用搭建好的 Git 服务</h3><p>克隆 test repo 到本地</p><pre><code>cd ~ &amp;&amp; git clone gituser@139.199.223.159:/data/repositories/test.git</code></pre><h2 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h2>]]></content>
      
      
      <categories>
          
          <category> Github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议五层与七层协议</title>
      <link href="/2017/11/25/"/>
      <url>/2017/11/25/</url>
      
        <content type="html"><![CDATA[<h1 id="网络协议五层与OSI七层协议"><a href="#网络协议五层与OSI七层协议" class="headerlink" title="网络协议五层与OSI七层协议"></a>网络协议五层与OSI七层协议</h1><blockquote><p>如果大学的计算机基础不错，这应该都是计算机网络教材里面的内容。之前在面试的时候面试官有问过类似的通信知识，瞬间石乐志。于是在自己原有的理解上重新学习一遍，记下此篇。</p></blockquote><blockquote><p>本文知识总结来源为：图灵丛书《图解http》一书，以及无数网络博客资源。</p></blockquote><h2 id="网络五层协议"><a href="#网络五层协议" class="headerlink" title="网络五层协议"></a>网络五层协议</h2><p>Tcp&#x2F;Ip 如果按照协议族来划分可以分为四层结构（或者五层，有的书籍没有把物理层算在其中）。</p><h3 id="应用层："><a href="#应用层：" class="headerlink" title="应用层："></a>应用层：</h3><p>应用层是决定了向用户提供应用程序通讯时的服务。<br>应用层是我们最多接触的一个，常见的http，smtp,FTP都是属于应用层的实现。所谓应用层，意思就是我们可以使用网络就像一件商品一样直接去使用而不用关注他的实现。</p><h3 id="传输层："><a href="#传输层：" class="headerlink" title="传输层："></a>传输层：</h3><p>传输层所能了解的就是数据的传输协议，比如我们知道http的传输是用过数据包的方式来进行的。在传输层有两个我们耳濡目染的协议就是tcp(transimition control protocal)和udp(user data protocal)。</p><h3 id="网络层："><a href="#网络层：" class="headerlink" title="网络层："></a>网络层：</h3><p>网络主要指的是就是IP，全称是Internet Protocal，意为网络协议。其实就是约定了在一个开发的网络环境里面，不同的两个参与方如何进行通信。我们知道无论是访问网站，还是数据传输，我们的交流都是通过IP来进行，当然这其中还会有DNS的作用。所以，通俗的理解下来就是，</p><h3 id="链路层："><a href="#链路层：" class="headerlink" title="链路层："></a>链路层：</h3><p>这个层叫做数据链路层或者网络接口层都可以。链路层就是一个决定以什么样的方式来传输网络上流动的数据包，比如去控制传输介质或者链路的管理。比如网卡设备，路由器。</p><h3 id="物理层："><a href="#物理层：" class="headerlink" title="物理层："></a>物理层：</h3><p>物理层指的主要是在网络通信中支持网络传输的设备，中继器，双绞线。当然里面也有类似的硬件通信协议。</p><h2 id="OSI-open-system-interconnect-七层划分"><a href="#OSI-open-system-interconnect-七层划分" class="headerlink" title="OSI(open system interconnect)七层划分"></a>OSI(open system interconnect)七层划分</h2><p>七层较之于五层模型。共有七层，分别为应用层、表示层、会话层、传输层、网络层、链路层、物理层。对应于五层模式来说，其中应用层、表示层、会话层属于应用层的部分。其他则一致。下面只介绍多出来的两层。</p><h3 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h3><p>表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。<br>举个例子就是，通信双方约定一种数据格式来接受。比如A和B约定通过火星文来传输，那么加入A发送数据格式如果不是火星文，就会被转换为火星文，然后实现通信。除此之外，还可以对传输的格式作加密处理（一样的意思，换汤不换药）。</p><h3 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h3><p>会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。<br>每次的网络通信都可以称之为一次会话，我们知道http是无状态（stateless）的连接，每次连接不会被记录。但是http1.0出来的规范里，keep-live的出现，可以让每一次的连接不会被过早的中断。这些其实都是在会话层做的处理。</p><hr><p>话不多说，点到即止。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> 五层协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>没有后端基础，怎么入门学习Nginx？</title>
      <link href="/2017/09/02/"/>
      <url>/2017/09/02/</url>
      
        <content type="html"><![CDATA[<h1 id="nginx知识备忘"><a href="#nginx知识备忘" class="headerlink" title="nginx知识备忘"></a>nginx知识备忘</h1><h2 id="Nginx是什么？"><a href="#Nginx是什么？" class="headerlink" title="Nginx是什么？"></a>Nginx是什么？</h2><p>引用百科的话说，<strong>Nginx</strong> (engine x) 是一个高性能的HTTP和反向代理服务器,也可以作为IMAP&#x2F;POP3&#x2F;SMTP邮件服务器。Nginx很轻（占用内存少）、Nginx支持高并发、Nginx足够稳定，当然还有一点，Nginx开源。</p><h2 id="怎么学习Nginx"><a href="#怎么学习Nginx" class="headerlink" title="怎么学习Nginx"></a>怎么学习Nginx</h2><p>任何编程语言的学习都应当是理论加上实践，特别是对于码农来说，你的真知往往来自于你的实践。Nginx作为服务器的一门技术，更偏向于运维知识，而且其中大部分的知识其实需要具有一定的业务场景你才可以实践的到，所以对于<strong>Nginx</strong>的学习，我的想法是理论学习、引经论述、归纳总结、简单实践，具体到深入的业务场景再深入学习。<br>基于以上的学习需求，并结合我英语水平差的现状我选择下面这两个网站：</p><ul><li><a href="http://www.nginx.cn/doc/">Nginx中文网</a><br>Nginx的中文文档，排版和易读性都比官网要好一些，但是要看最新相关还是看英文原版好一些</li><li><a href="http://tengine.taobao.org/">阿里关于Nginx的实践</a><br><strong>Tengine</strong>,官网给的自我介绍是：Tengine(T-engine)是由淘宝网发起的Web服务器项目。它在Nginx的基础上，针对大访问量网站的需求，添加了很多高级功能和特性。Tengine的性能和稳定性已经在大型的网站如淘宝网，天猫商城等得到了很好的检验。它的最终目标是打造一个高效、稳定、安全、易用的Web平台。因为基于Nginx，所以官网也提供了Nginx的中文文档。</li></ul><p>当然还有一种方法是看视频，个人推荐但不支持看视频。推荐是因为对于大部分人（我的名字叫大部分人）来说，服务器的知识就像海底的冰山，看到就会有种莫名的恐惧。看视频可以让你对服务器的知识做一个大致的梳理，帮助你理清思路。不支持的原因也很简单，现在的学习视频价格不菲，而且讲的知识点都比较基础，特别对于Nginx来说，个人觉得更加没必要。</p><h2 id="关于反向代理服务器的几个疑问？"><a href="#关于反向代理服务器的几个疑问？" class="headerlink" title="关于反向代理服务器的几个疑问？"></a>关于反向代理服务器的几个疑问？</h2><h3 id="1-正向代理和反向代理的区别？"><a href="#1-正向代理和反向代理的区别？" class="headerlink" title="1.正向代理和反向代理的区别？"></a>1.正向代理和反向代理的区别？</h3><p><a href="https://www.zhihu.com/question/24723688/answer/128105528">知乎：反向代理为何叫反向代理？</a><br>个人理解来说，可以总结为两点：</p><ul><li><strong>反向代理和正向代理都是代理</strong>，看到这儿你可能要问，为什么需要代理服务器呢？其实原因如下：用代理服务器的一个好处是可以使你的IP地址不被暴露出去，比如下面的去访问百度的host时，会发现返回的是 <a href="http://www.a.shifen.com/">www.a.shifen.com</a> 的结果。同样的，新浪搜狐等一些大型网站都有类似的解决方案。想要了解更多，可以看这里，<a href="https://www.aliyun.com/zixun/content/3_12_81613.html">为什么要使用代理服务器，代理服务器的优势</a><br>图片<br>另外的一个好处就是你常见的 vpn ，这其实也是一种代理的体现。</li><li><strong>反向代理代理的是服务器响应</strong>，即你得到的响应可能是来自一个服务器集群的结果。<strong>正向代理代理的是客户端请求</strong>，减轻服务端压力，代理请求。<br></li></ul><h3 id="2-适合做反向代理服务器的有哪些？"><a href="#2-适合做反向代理服务器的有哪些？" class="headerlink" title="2.适合做反向代理服务器的有哪些？"></a>2.适合做反向代理服务器的有哪些？</h3><p>传统的服务器比如IIS或者Apache用来做反向代理，其实略显臃肿。Nginx常被用来做反向代理服务器的原因是足够稳定，足够轻量，并且支持高并发。<br><a href="http://blog.csdn.net/zhu_tianwei/article/details/19396527">几种反向代理服务器比较。</a></p><h3 id="3-Nginx、Apache和之前用的Tomcat有什么区别？"><a href="#3-Nginx、Apache和之前用的Tomcat有什么区别？" class="headerlink" title="3.Nginx、Apache和之前用的Tomcat有什么区别？"></a>3.Nginx、Apache和之前用的Tomcat有什么区别？</h3><p><a href="https://www.zhihu.com/question/32212996">知乎：tomcat 与 nginx，apache的区别是什么？</a></p><h3 id="4-Nginx的配置文件怎么看？"><a href="#4-Nginx的配置文件怎么看？" class="headerlink" title="4.Nginx的配置文件怎么看？"></a>4.Nginx的配置文件怎么看？</h3><p>先放一个完整的Nginx配置文件</p><pre><code>#user  nobody; 运行的用户，设置配置文件访问权限worker_processes  1; 可以启动的进程，通常设置为与CPU核心数目相同#日志文件记录#error_log  logs/error.log;#error_log  logs/error.log  notice;#error_log  logs/error.log  info;#pid        logs/nginx.pid;# events &#123;    #epoll是多路复用IO(I/O Multiplexing)中的一种方式,    #仅用于linux2.6以上内核,可以大大提高nginx的性能    use   epoll;     worker_connections  1024; # 单个进程的最大并发连接数    #此处参考： http://www.nginx.cn/76.html    # 并发总数是 worker_processes 和 worker_connections 的乘积    # 即 max_clients = worker_processes * worker_connections    # 在设置了反向代理的情况下，max_clients = worker_processes * worker_connections / 4  为什么    # 为什么上面反向代理要除以4，应该说是一个经验值    # 根据以上条件，正常情况下的Nginx Server可以应付的最大连接数为：4 * 8000 = 32000    # worker_connections 值的设置跟物理内存大小有关    # 因为并发受IO约束，max_clients的值须小于系统可以打开的最大文件数    # 而系统可以打开的最大文件数和内存大小成正比，一般1GB内存的机器上可以打开的文件数大约是10万左右    # 我们来看看360M内存的VPS可以打开的文件句柄数是多少：    # $ cat /proc/sys/fs/file-max    # 输出 34336    # 32000 &lt; 34336，即并发连接总数小于系统可以打开的文件句柄总数，这样就在操作系统可以承受的范围之内    # 所以，worker_connections 的值需根据 worker_processes 进程数目和系统可以打开的最大文件总数进行适当地进行设置    # 使得并发总数小于操作系统可以打开的最大文件数目    # 其实质也就是根据主机的物理CPU和内存进行配置    # 当然，理论上的并发总数可能会和实际有所偏差，因为主机还有其他的工作进程需要消耗系统资源。    # ulimit -SHn 65535&#125;http &#123;    include       mime.types;    default_type  application/octet-stream;    #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;    #                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;    #                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;    #access_log  logs/access.log  main;    sendfile        on;    #tcp_nopush     on;    #keepalive_timeout  0;    keepalive_timeout  65;    #gzip  on;    server &#123;        #侦听80端口        listen    80;        #定义使用 www.nginx.cn访问        server_name  www.nginx.cn;         #定义服务器的默认网站根目录位置        root html;         #设定本虚拟主机的访问日志        access_log  logs/nginx.access.log  main;         #默认请求        location / &#123;                        #定义首页索引文件的名称            index index.php index.html index.htm;            &#125;         # 定义错误提示页面        error_page   500 502 503 504 /50x.html;        location = /50x.html &#123;        &#125;         #静态文件，nginx自己处理        location ~ ^/(images|javascript|js|css|flash|media|static)/ &#123;                        #过期30天，静态文件不怎么更新，过期可以设大一点，            #如果频繁更新，则可以设置得小一点。            expires 30d;        &#125;         #禁止访问 .htxxx 文件            location ~ /.ht &#123;            deny all;        &#125;    &#125;</code></pre><h3 id="5-怎么用Nginx做负载均衡？"><a href="#5-怎么用Nginx做负载均衡？" class="headerlink" title="5.怎么用Nginx做负载均衡？"></a>5.怎么用Nginx做负载均衡？</h3><p>一个负载均衡的例子，把<a href="http://www.domain.com均衡到本机不同的端口,也可以改为均衡到不同的地址上/">www.domain.com均衡到本机不同的端口，也可以改为均衡到不同的地址上</a></p><pre><code>http &#123;    upstream myproject &#123;    server 127.0.0.1:8000 weight=3; #weight 表示权重    server 127.0.0.1:8001;    server 127.0.0.1:8002;    server 127.0.0.1:8003;  &#125;  server &#123;    listen 80;    server_name www.domain.com;    location / &#123;        proxy_pass http://myproject; #定向到myproject    &#125;  &#125;&#125;</code></pre><h3 id="6-Nginx虚拟主机？"><a href="#6-Nginx虚拟主机？" class="headerlink" title="6.Nginx虚拟主机？"></a>6.Nginx虚拟主机？</h3><p>要在Nginx里面配置多个虚拟主机，首先需要新建几个虚拟主机。一个虚拟主机其实就可以理解一个虚拟操作系统。通常的，这个虚拟主机可以存在在虚拟机或者docker里面。对于Linux，你也可以通过命令行来创建虚拟主机。可以参考：<a href="http://wodemeng.blog.51cto.com/1384120/1538310">Linux 中http中创建虚拟主机实例</a></p><p>Nginx里面配置虚拟主机</p><pre><code>http &#123;    server &#123;        listen          80;        server_name     www.domain1.com;        access_log      logs/domain1.access.log main;        location / &#123;        index index.html;            root  /var/www/domain1.com/htdocs;        &#125;    &#125;    server &#123;        listen          80;        server_name     www.domain2.com;        access_log      logs/domain2.access.log main;        location / &#123;            index index.html;            root  /var/www/domain2.com/htdocs;        &#125;    &#125;&#125;</code></pre><h3 id="7-Nginx缓存处理？"><a href="#7-Nginx缓存处理？" class="headerlink" title="7.Nginx缓存处理？"></a>7.Nginx缓存处理？</h3><p>这一方面理解不是很深入，看看先人的博客来学习一下</p><ul><li><a href="http://www.cnblogs.com/bokejiayuan/p/4233332.html">如何利用Nginx的缓冲、缓存优化提升性能</a></li><li><a href="http://www.jb51.net/article/77602.htm">nginx缓存cache的5种方案</a></li><li><a href="http://www.cnblogs.com/kevingrace/p/6198287.html">nginx的web缓存服务环境部署记录</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> 运维知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一篇无聊的博客--当我有了我的新电脑，我该怎样去配置？</title>
      <link href="/2017/09/01/"/>
      <url>/2017/09/01/</url>
      
        <content type="html"><![CDATA[<h1 id="当我有了我的新电脑，我该怎样去配置？"><a href="#当我有了我的新电脑，我该怎样去配置？" class="headerlink" title="当我有了我的新电脑，我该怎样去配置？"></a>当我有了我的新电脑，我该怎样去配置？</h1><hr><blockquote><p>这是一篇无聊到让你看了之后会觉得一切索然无味的博客，因为它的目的只有一个，就是帮助我记忆一些的我的个人电脑装机方案。当然，这也是一篇有一点点参考价值的博客，因为或许可以帮助你自定义配置你的电脑，创造不同于别人的freestyle，同时提升你的工作效率。因为平时的工作接触的就只有windows和macOS，所以本文的切入点也就有两个。那么，当我有了我的新电脑，我该怎样去配置的我的新电脑呢？</p></blockquote><blockquote><p>我的职业是一为前端工程师，所以以装X为目的，提升工作效率为情怀。以下软件的配置或者优化均为个人喜好，你要是觉得不喜欢很烂，鄙人也是很无奈啊。</p></blockquote><h2 id="当我有了我的新Windows电脑，我该怎么去配置，优化"><a href="#当我有了我的新Windows电脑，我该怎么去配置，优化" class="headerlink" title="当我有了我的新Windows电脑，我该怎么去配置，优化"></a>当我有了我的新Windows电脑，我该怎么去配置，优化</h2><h3 id="1-系统的选择"><a href="#1-系统的选择" class="headerlink" title="1 系统的选择"></a>1 系统的选择</h3><p>一般我是不喜欢用自带的家庭版系统的，况且我是个想在电脑上跑多个系统的boy。但习惯所致，双系统不是我的选择，所以我选window10专业版或者windows10企业版。Windows10自带的<strong>hyper-v</strong>足够强大，个人感觉比VM好用多了，用来装centos刚刚好。<br>有几点需要注意下：</p><ul><li>win10在<strong>开启hyper服务</strong>之后，若要新建虚拟机，需要开启bios的虚拟化，在BIOS的cpu设置里面启用即可。</li><li>win10有时候会遇到无法进入BIOS的情况，原因有可能是开启了win10的快速启动，所以电脑不会真正的关机。解决办法是将电脑强行断电几分钟，如果是笔记本就拆掉电源，然后按长按开机键清空BIOS的电量。这个时候再重启按命令（F2，ESC等）就可以进入BIOS设置了。</li><li>hyper-v的虚拟机新建设置里面有一个一代或者二代(<a href="https://docs.microsoft.com/en-us/windows-server/virtualization/hyper-v/plan/Should-I-create-a-generation-1-or-2-virtual-machine-in-Hyper-V">WTF is 1 or 2</a>)的设置。开启了虚拟化，当然选择第二代。<br>图片<br>上图是第一代和第二代的区别。</li><li>当你新建虚拟机装centos时有时会出现*** no UEFI system found**的错误，说明你的BIOS没有设置UEFI(<a href="https://baike.baidu.com/item/UEFI/3556240?fr=aladdin">WTF is UEFI</a>)，或者机器太老不支持。退出到第三步中的第一代就行。</li></ul><h3 id="2-网络环境，驱动配置"><a href="#2-网络环境，驱动配置" class="headerlink" title="2 网络环境，驱动配置"></a>2 网络环境，驱动配置</h3><ul><li><strong>更新驱动，修复漏洞</strong>直接使用鲁大师。如果是组装机，顺便可以跑个分，查看电脑使用情况，看有没有被商家套路。</li><li><em>翻墙</em>去GitHub下载（其他地方出现的都是假的）。安装lantern</li></ul><h3 id="3-作为一名coder，我该装些啥"><a href="#3-作为一名coder，我该装些啥" class="headerlink" title="3 作为一名coder，我该装些啥"></a>3 作为一名coder，我该装些啥</h3><ul><li><strong>visual studio code</strong>，用来写代码</li><li><strong>git for windows</strong>，用来抄代码，必要安装<a href="https://www.sourcetreeapp.com/">sourcetree</a></li><li><strong>node</strong>，node 环境必须要装</li><li><strong>sublime</strong>，用来代替记事本使用</li><li><strong>beyondCompare</strong>,比较代码用</li><li><strong><a href="https://babun.github.io/index.html">babun</a></strong>,替换掉原生的命令行工具，与powershell 结合使用</li><li><strong><a href="https://www.cockos.com/licecap/">licecap</a></strong>,用来截Gif图，给别人演示用，很方便</li><li><strong>mongodb</strong>,现在应该叫做studio3T,工作主用mongodb</li><li><strong>[teamviewer(<a href="https://www.teamviewer.com/zhCN/)]">https://www.teamviewer.com/zhCN/)]</a></strong>,远程连接，实际使用强过向日葵太多</li><li>**[markman(<a href="http://www.getmarkman.com/)]**%E7%94%A8%E6%9D%A5%E5%88%87%E5%9B%BE%E9%87%8F%E5%B0%BA%E5%AF%B8%EF%BC%8C%E5%8D%95%E8%BF%99%E4%B8%AA%E5%8A%9F%E8%83%BD%E4%BF%A9%E8%AF%B4%E6%AF%94PS%E5%AE%9E%E5%9C%A8%E5%A5%BD%E5%A4%AA%E5%A4%9A%EF%BC%8C%E4%BD%86%E6%98%AF%E9%9C%80%E8%A6%81%E5%AE%89%E8%A3%85Adobe">http://www.getmarkman.com/)]**用来切图量尺寸，单这个功能俩说比PS实在好太多，但是需要安装Adobe</a> air</li><li><strong><a href="http://www.getwox.com/">Wox</a></strong>,windows下的的spotlight,安装后设置开机自启</li><li><strong><a href="https://www.irolan.com/">rolan</a></strong>,用来做桌面管理，设置开机自启</li><li><strong>cccleaner</strong> 清理电脑垃圾文件和注册表</li><li><strong>FileZila</strong> Ftp连接</li><li><strong>有道云笔记</strong> 用来记笔记，三个终端都有的，很方便。当然印象笔记也是可以的</li></ul><h3 id="4-作为一名文青，我该用些啥"><a href="#4-作为一名文青，我该用些啥" class="headerlink" title="4 作为一名文青，我该用些啥"></a>4 作为一名文青，我该用些啥</h3><p>微信QQ随身装<br><br>知乎B站天天看<br><br>优化电脑鲁大师<br><br>听歌只选网易云</p><h3 id="5-必备的谷歌浏览器，单独用来说，最好的办法创建一个谷歌账户，这样一切方便许多"><a href="#5-必备的谷歌浏览器，单独用来说，最好的办法创建一个谷歌账户，这样一切方便许多" class="headerlink" title="5 必备的谷歌浏览器，单独用来说，最好的办法创建一个谷歌账户，这样一切方便许多"></a>5 必备的谷歌浏览器，单独用来说，最好的办法创建一个谷歌账户，这样一切方便许多</h3><ul><li><strong>Octotree</strong> 以树形菜单的方式查看github上的仓库</li><li><strong>Adblock Plus</strong> 广告，不存在的</li><li><strong>掘金</strong> 程序员一定要看这个，每天学习新知识</li><li><strong>Infinity新标签页</strong> 替换掉丑陋的新标签页，很好用</li><li><strong>Postman</strong>  不解释，测接口</li><li><strong>React Developer Tools</strong> react调试工具</li><li><strong>Redux DevTools</strong> react-redux调试工具</li><li><strong>Vue.js devtools</strong> vue调试工具</li><li><strong>Tampermonkey</strong> 插件之中的插件，超有逼格</li><li><strong>Vimium</strong> 以vim的方式全键盘操控网页</li><li><strong>扩展管理器</strong> 小图标太多，用这个管理</li><li><strong>划词翻译</strong> 对于英文贼差的我来说，真的神器，选中单词就可翻译</li><li><strong>小幺鸡</strong> 写接口文档使用，支持国产</li><li><strong>Listen 1</strong> 听网易云音乐，虾米，QQ音乐的曲库</li></ul><hr><h2 id="当我有了我的新mac，我该怎么去配置，优化"><a href="#当我有了我的新mac，我该怎么去配置，优化" class="headerlink" title="当我有了我的新mac，我该怎么去配置，优化"></a>当我有了我的新mac，我该怎么去配置，优化</h2><p>对于mac来说，学习成本相当低，基本没有一些配置什么的骚操作，收集一下自己的装机列表</p><ul><li><strong>item2</strong> 替代原生的terminal</li><li><strong>homebrew</strong> 安装homebrew</li><li><strong>oh-my-zsh</strong> 配置oh-my-zsh</li><li><strong>CheatSheet</strong> 长按command，显示当前程序的所有快捷键</li></ul><p>以上几个，可以去<a href="http://blog.csdn.net/u013707249/article/details/76094937">这里</a>查看</p><ul><li><strong>visual studio code</strong>，用来写代码</li><li><strong>node</strong>，node 环境必须要装</li><li><strong>sublime</strong>，用来代替记事本使用</li><li><strong>beyondCompare</strong>,比较代码用</li><li><strong><a href="https://www.cockos.com/licecap/">licecap</a></strong>,用来截Gif图，给别人演示用，很方便</li><li><strong>mongodb</strong>,现在应该叫做studio3T,工作主用mongodb</li><li><strong>[teamviewer(<a href="https://www.teamviewer.com/zhCN/)]">https://www.teamviewer.com/zhCN/)]</a></strong>,远程连接，实际使用强过向日葵太多</li><li><strong>[markman(<a href="http://www.getmarkman.com/)]">http://www.getmarkman.com/)]</a></strong> 用来切图量尺寸，单这个功能俩说比PS实在好太多，但是需要安装Adobe air</li><li><strong>截图工具</strong>很好用的一个截图工具，<a href="http://jietu.qq.com/">戳我</a></li><li><strong>Alfred 3</strong> 工作效率神器，另外，可以<a href="http://www.sdifen.com/alfred3.html">破解哦</a></li><li><strong>FileZila</strong> Ftp连接</li><li><strong>webstorm</strong> mac上不是那么卡</li><li><strong>有道云笔记</strong> 做笔记使用，三个终端都有的，很方便</li></ul>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> macos </tag>
            
            <tag> 软件配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一篇文章，从windows10成功移植macOS</title>
      <link href="/2017/07/25/"/>
      <url>/2017/07/25/</url>
      
        <content type="html"><![CDATA[<p>一篇文章，从windows10成功移植macOS</p><p>作为习惯了Windows温暖怀抱的码畜一名，初次使用macOS，总是会有各种的不适应。记不住的快捷键，理不清的bash命令，找不到的文件夹，个个都能让人激动地拔起29米大刀。这篇文章，简单介绍作为一小白从Windows10系统成功移植macOS的过程。在几天的适应时间里，查阅了大量（一点儿）的资料，踩着前人的尸首整理出这篇文章。一方面算作是给自己一个记录，另一方面是最近略忙，无法更新博客，只能写点这些来充数。</p><p>因为我是码农一名，所以对macOS的使用理解可能与大众视角不太一样，所以将就看。</p><p>配置VPN</p><p>首先，刚接触到macOS，我认为应该做的第一件事就是配网络，毕竟在程序界，国外的月亮的确是圆一些。关于vpn，最近国家风头正紧，前阵子，博主一直用的greenvpn已经跑路，所以防止查水表，这里就简单提一下，希望没人看到。</p><p>一般在macOS上使用VPN，会推荐两个，一个是使用shadowsock客户端，然后自己去somewhere找线路，进行配置后访问，这一种略微麻烦下。因为我是小白嘛，所以我用简单的，lantern ，比起使用shadowsock，lantern使用很简单，直接下载打开就可以用。lantern默认会在打开的时候，在你的机器上跑一个服务，免费的也可以用，但是速度稳定性稍微差些，重要的是会限制流量。专业版的就不会做流量限制，而且现在两年套餐才300块左右（我用的就是这个），我不会告诉你在购买的时候填写这个验证码 YY7VYWQ 还可以额外获得是三个月的使用时间。</p><p>对了，最重要的是，下载lantern别去百度搜索下载，搜到的中文官网已经下了，直接去这里下载 下载地址： <a href="https://github.com/getlantern/lantern/releases/tag/latest%EF%BC%8C%E8%80%8C%E4%B8%94%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E6%98%AFlantern%E6%B2%A1%E6%9C%89ios%E7%89%88%E6%9C%AC%E7%9A%84%EF%BC%8C%E6%89%80%E4%BB%A5ios%E4%B8%8A%E7%9A%84lantern%E9%83%BD%E6%98%AF%E7%9B%97%E7%89%88%E3%80%82">https://github.com/getlantern/lantern/releases/tag/latest，而且需要注意的是lantern没有ios版本的，所以ios上的lantern都是盗版。</a></p><p>记住快捷键</p><p>首先MacBook的键位是和普通的键盘不一样的，更重要的是好多快捷键也是很有自己的freestyle，的确是相当难记（当然也不需要全部记住，只需要在工作熟悉常用的即可）。这里推荐一个软件CheatSheet，没别的，就是当你长按住command键的时候，会显示当前电脑的所有常用快捷键方式，好记性不用带小抄。下载地址点这里，CheatSheet <a href="https://www.mediaatelier.com/CheatSheet/">https://www.mediaatelier.com/CheatSheet/</a></p><p>bash命令</p><p>讲道理，不看其他的，macOS上的bash命令我可以玩儿一天。这里直接看了前人的教程来配置自己的terminal。结合美观、使用高效的需求，前人给出的解决方案是iterm2+oh-my-zsh+各种配置,思路很清晰，但是安装会有一点麻烦。<br>整理一下思路大致就是， 先安装iterm2 -&gt; iterm2简单配置，配色方案 -&gt; 安装zsh，mac自带的有zsh，但是可以去更新下 -&gt; 安装oh-my-zsh插件 -&gt; 愉快玩耍</p><p>iterm2的安装<br>直接去iterm2的官网下载就行了，<a href="https://www.iterm2.com/%EF%BC%8C%E5%85%8D%E8%B4%B9%E7%9A%84%E8%BD%AF%E4%BB%B6%E3%80%82">https://www.iterm2.com/，免费的软件。</a></p><p>iterm2简单配置，配色方案<br>网上有很多大神有自己的配色方案，可以 百度 ‘iterm2配色方案’，可以按照教程自己设置。当然我是小白，所以直接用现成的。iterm2有专门的主题网站，可以登录这里<a href="http://iterm2colorschemes.com/%EF%BC%8C%E4%B8%8B%E8%BD%BD%E7%BD%91%E7%AB%99%E4%B8%8A%E7%9A%84%E5%8C%85%EF%BC%8C%E7%84%B6%E5%90%8E%E7%9F%A5%E5%B7%B1%E5%AF%BC%E5%85%A5%E5%B0%B1%E8%A1%8C%E4%BA%86%EF%BC%8C%E4%BD%A0%E8%A6%81%E9%97%AE%E6%80%8E%E4%B9%88%E5%AF%BC%E5%85%A5%EF%BC%9F%E7%9B%B4%E6%8E%A5%E7%9C%8B%E8%BF%99%E9%87%8C%EF%BC%8Citerm2%E5%AF%BC%E5%85%A5%E9%85%8D%E8%89%B2%E6%96%B9%E6%A1%88http://jingyan.baidu.com/article/48a42057029f99a92425048e.html">http://iterm2colorschemes.com/，下载网站上的包，然后知己导入就行了，你要问怎么导入？直接看这里，iterm2导入配色方案http://jingyan.baidu.com/article/48a42057029f99a92425048e.html</a></p><p>安装zsh<br>在安装zsh之前，可以先安装一个homebrew，<a href="https://brew.sh/index_zh-cn.html%EF%BC%8C%E6%9C%89%E4%BA%86%E8%BF%99%E4%B8%AA%E7%8E%A9%E6%84%8F%E5%84%BF%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85%E4%BD%A0%E6%83%B3%E5%AE%89%E8%A3%85%E7%9A%84%E4%B8%9C%E8%A5%BF%E3%80%82%E5%AE%89%E8%A3%85%E5%AE%8C%E6%88%90%E5%90%8E%EF%BC%8C%E7%9B%B4%E6%8E%A5bash%E8%BE%93%E5%85%A5">https://brew.sh/index_zh-cn.html，有了这个玩意儿，可以一键安装你想安装的东西。安装完成后，直接bash输入</a><br>$brew install zsh<br>安装成功后，需要修改为默认的shell，先去确认一下自己zsh的安装目录<br>$ chsh -s &#x2F;bin&#x2F;zsh</p><p>安装oh-my-zsh插件<br>只剩下最后一步,一行命令搞定<br>$ curl -L <a href="https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh">https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh</a> | sh</p><p>以上，就稍微有点逼格了，</p><p>一些我记不住的命令：<br>顺便给自己备忘一下老是记不住的命令：<br>显示隐藏文件&#x2F;目录： $ defaults write com.apple.finder AppleShowAllFiles -bool true<br>隐藏隐藏文件&#x2F;目录： $ defaults write com.apple.finder AppleShowAllFiles -bool false </p>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac移植 </tag>
            
            <tag> mac工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win10下的装逼利器，让你的win10更好用</title>
      <link href="/2017/05/24/"/>
      <url>/2017/05/24/</url>
      
        <content type="html"><![CDATA[<p>这是一篇非技术性博客，是帮住你更好使用win10的辅助软件，亲测十分好用，既能提升效率，又能狠狠地装逼。 </p><p>以下软件都是我正在使用的，后面有新发现的话会继续更新</p><h2 id="rolan2"><a href="#rolan2" class="headerlink" title="rolan2"></a><strong>rolan2</strong></h2><p>rolan2 是一个很不错的桌面管理工具，了解桌面管理工具的肯定都有用过大名鼎鼎的fences,win7下用fences的确不错，整体UI是很搭的，但是win10用fences效果不好，所以选择用了rolan2,风格很贴近win10，可以自定义分组，并且可以快捷键显示隐藏，非常酷炫。不多说，直接上图</p><p><img src="http://img.blog.csdn.net/20170524101005904?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzcwNzI0OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>右上角那个嘿嘿嘿的方块就是rolan2,风格怎样完全可以自定制，另外还有一个小技巧就是，默认的快捷键 ALT + TAB 键控制显示界面隐藏，到时候整个桌面只剩下你的壁纸，即是十分清爽，好看又装逼，实乃居家常备、装逼之利器。</p><p>官网下载地址：<a href="https://www.irolan.com/">https://www.irolan.com/</a> 测试版即可，会提示你升级</p><h2 id="QTtab"><a href="#QTtab" class="headerlink" title="QTtab"></a><strong>QTtab</strong></h2><p>我是经常需要操作多个文件夹的，但是文件夹打开的多了就需要不停的切换，贼烦，这时候就希望如果能够像操作浏览器窗口一样操作文件窗口那就好了，QTtab就是这样的一个工具。上图</p><p><img src="http://img.blog.csdn.net/20170524102400506?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzcwNzI0OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>使用QTab你只需要将你想要看的文件夹拖动到导航栏，或者是按下鼠标滚轮键将选中的文件夹自动添加到导航栏，具体可以自己配置。 </p><p>日常使用起来真的是非常实用的一个软件，另外更重要的是软件的体积很小，1M不到，意不意外，惊不惊喜</p><p>官网下载地址：<a href="http://qttabbar.wikidot.com/">http://qttabbar.wikidot.com/</a></p><h2 id="StarlsBack"><a href="#StarlsBack" class="headerlink" title="StarlsBack"></a><strong>StarlsBack</strong></h2><p>这个软件真的是业界良心，win10软件的必备好不。 </p><p>首先，win10的启动菜单真的很难用，虽然有个小娜娜可以搜索，但是我还是不太喜欢。那就只好找工具了。喏，就是下面这个</p><p><img src="http://img.blog.csdn.net/20170524103226897?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzcwNzI0OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>请忽略掉那手残的马赛克，博主手残</p><p><img src="http://img.blog.csdn.net/20170524103010722?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzcwNzI0OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>StarlsBack可以让你自定制你的启动菜单主题，比如我自己就用的win10的图标 + win8的列表风格，然后透明任务栏，贼酷炫，当然还有其他关于任务栏的优化，都可以自己去定制。另外，还有一个彩蛋是如果你想看一下原版的启动主题，按Ctrl + windows 就可以做到，是不是很棒。</p><p>官网下载地址：<a href="http://www.startisback.com/">http://www.startisback.com/</a></p><hr><p><br/>前端新手，弱鸡一枚，如有错误，请指正，谢谢！</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> win10 </tag>
            
            <tag> 小技能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows常用cmd命令大全</title>
      <link href="/2017/05/08/"/>
      <url>/2017/05/08/</url>
      
        <content type="html"><![CDATA[<h2 id="windows常用cmd命令大全"><a href="#windows常用cmd命令大全" class="headerlink" title="windows常用cmd命令大全"></a><strong>windows常用cmd命令大全</strong></h2><p>收集而来的常用CMD命令</p><p><strong>实用操作类</strong></p><p><span class="hljs-comment">1</span><span class="hljs-string">.</span> <span class="hljs-comment">Nslookup</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">IP地址侦测器</span><br><span class="hljs-comment">2</span><span class="hljs-string">.</span> <span class="hljs-comment">explorer</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">打开资源治理器</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">不推荐，还不如用Windows</span> <span class="hljs-literal">+</span> <span class="hljs-comment">E打开方便</span><br><span class="hljs-comment">3</span><span class="hljs-string">.</span> <span class="hljs-comment">winver</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">检查Windows版本</span><br><span class="hljs-comment">4</span><span class="hljs-string">.</span> <span class="hljs-comment">regsvr32</span> <span class="hljs-comment">&#x2F;u</span> <span class="hljs-comment">*</span><span class="hljs-string">.</span><span class="hljs-comment">dll</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">停止dll文件运行</span><br><span class="hljs-comment">5</span><span class="hljs-string">.</span> <span class="hljs-comment">mstsc</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">远程桌面连接</span><br><span class="hljs-comment">6</span><span class="hljs-string">.</span> <span class="hljs-comment">shrpubw</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">创建共享文件夹</span><br><span class="hljs-comment">7</span><span class="hljs-string">.</span> <span class="hljs-comment">regsvr32</span> <span class="hljs-comment">&#x2F;u</span> <span class="hljs-comment">zipfldr</span><span class="hljs-string">.</span><span class="hljs-comment">dll</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">取消ZIP支持</span><br><span class="hljs-comment">8</span><span class="hljs-string">.</span> <span class="hljs-comment">services</span><span class="hljs-string">.</span><span class="hljs-comment">msc</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">本地服务设置</span><br><span class="hljs-comment">9</span><span class="hljs-string">.</span> <span class="hljs-comment">fsmgmt</span><span class="hljs-string">.</span><span class="hljs-comment">msc</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">共享文件夹治理器</span><br><span class="hljs-comment">10</span><span class="hljs-string">.</span> <span class="hljs-comment">regedit</span><span class="hljs-string">.</span><span class="hljs-comment">exe</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">注册表</span><br><span class="hljs-comment">11</span><span class="hljs-string">.</span> <span class="hljs-comment">regedt32</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">注册表编辑器</span></pre></p><p><strong>系统工具类</strong></p><p><span class="hljs-number">1.</span> sndrec32<span class="hljs-comment">——-录音机</span><br><span class="hljs-number">2.</span> notepad<span class="hljs-comment">——–打开记事本</span><br><span class="hljs-number">3.</span> dvdplay<span class="hljs-comment">——–DVD播放器</span><br><span class="hljs-number">4.</span> calc<span class="hljs-comment">———–启动计算器</span><br><span class="hljs-number">5.</span> drwtsn32<span class="hljs-comment">—— 系统医生</span><br><span class="hljs-number">6.</span> mem.exe<span class="hljs-comment">——–显示内存使用情况</span><br><span class="hljs-number">7.</span> <span class="hljs-built_in">write</span><span class="hljs-comment">———-写字板</span><br><span class="hljs-number">8.</span> mplayer2<span class="hljs-comment">——-简易widnows media player</span><br><span class="hljs-number">9.</span> wiaacmgr<span class="hljs-comment">——-扫描仪和照相机向导</span><br><span class="hljs-number">10.</span> mspaint<span class="hljs-comment">——–画图板</span><br><span class="hljs-number">11.</span> magnify<span class="hljs-comment">——–放大镜实用程序</span><br><span class="hljs-number">12.</span> dfrg.msc<span class="hljs-comment">——-磁盘碎片整理程序</span><br><span class="hljs-number">13.</span> diskmgmt.msc<span class="hljs-comment">—磁盘治理实用程序</span><br><span class="hljs-number">14.</span> osk<span class="hljs-comment">————打开屏幕键盘</span><br><span class="hljs-number">15.</span> narrator<span class="hljs-comment">——-屏幕“讲述人”</span><br><span class="hljs-number">16.</span> Sndvol32<span class="hljs-comment">——-音量控制程序</span></p><p><strong>系统类</strong></p><p><span class="hljs-comment">1</span><span class="hljs-string">.</span> <span class="hljs-comment">gpedit</span><span class="hljs-string">.</span><span class="hljs-comment">msc</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">组策略</span><br><span class="hljs-comment">2</span><span class="hljs-string">.</span> <span class="hljs-comment">rsop</span><span class="hljs-string">.</span><span class="hljs-comment">msc</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">组策略结果集</span><br><span class="hljs-comment">3</span><span class="hljs-string">.</span> <span class="hljs-comment">lusrmgr</span><span class="hljs-string">.</span><span class="hljs-comment">msc</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">本机用户和组</span><br><span class="hljs-comment">4</span><span class="hljs-string">.</span> <span class="hljs-comment">services</span><span class="hljs-string">.</span><span class="hljs-comment">msc</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">本地服务设置</span><br><span class="hljs-comment">5</span><span class="hljs-string">.</span> <span class="hljs-comment">devmgmt</span><span class="hljs-string">.</span><span class="hljs-comment">msc</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span> <span class="hljs-comment">设备治理器</span><br><span class="hljs-comment">6</span><span class="hljs-string">.</span> <span class="hljs-comment">dcomcnfg</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">打开系统组件服务</span><br><span class="hljs-comment">7</span><span class="hljs-string">.</span> <span class="hljs-comment">mmc</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">打开控制台</span><br><span class="hljs-comment">8</span><span class="hljs-string">.</span> <span class="hljs-comment">net</span> <span class="hljs-comment">start</span> <span class="hljs-comment">messenger</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">开始信使服务</span><br><span class="hljs-comment">9</span><span class="hljs-string">.</span> <span class="hljs-comment">net</span> <span class="hljs-comment">stop</span> <span class="hljs-comment">messenger</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">停止信使服务</span><br><span class="hljs-comment">10</span><span class="hljs-string">.</span> <span class="hljs-comment">compmgmt</span><span class="hljs-string">.</span><span class="hljs-comment">msc</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">计算机治理</span><br><span class="hljs-comment">11</span><span class="hljs-string">.</span> <span class="hljs-comment">cleanmgr</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">垃圾整理</span><br><span class="hljs-comment">12</span><span class="hljs-string">.</span> <span class="hljs-comment">regedit</span><span class="hljs-string">.</span><span class="hljs-comment">exe</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">注册表</span><br><span class="hljs-comment">13</span><span class="hljs-string">.</span> <span class="hljs-comment">regedt32</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">注册表编辑器</span><br><span class="hljs-comment">14</span><span class="hljs-string">.</span> <span class="hljs-comment">Msconfig</span><span class="hljs-string">.</span><span class="hljs-comment">exe</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">系统配置实用程序</span><br><span class="hljs-comment">15</span><span class="hljs-string">.</span> <span class="hljs-comment">chkdsk</span><span class="hljs-string">.</span><span class="hljs-comment">exe</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">Chkdsk磁盘检查</span><br><span class="hljs-comment">16</span><span class="hljs-string">.</span> <span class="hljs-comment">charmap</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">启动字符映射表</span><br><span class="hljs-comment">17</span><span class="hljs-string">.</span> <span class="hljs-comment">diskmgmt</span><span class="hljs-string">.</span><span class="hljs-comment">msc</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">磁盘治理实用程序</span><br><span class="hljs-comment">18</span><span class="hljs-string">.</span> <span class="hljs-comment">perfmon</span><span class="hljs-string">.</span><span class="hljs-comment">msc</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">计算机性能监测程序</span><br><span class="hljs-comment">19</span><span class="hljs-string">.</span> <span class="hljs-comment">dxdiag</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">检查DirectX信息</span><br><span class="hljs-comment">20</span><span class="hljs-string">.</span> <span class="hljs-comment">sfc</span> <span class="hljs-comment">&#x2F;scannow</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">扫描错误并复原</span><br><span class="hljs-comment">21</span><span class="hljs-string">.</span> <span class="hljs-comment">taskmgr</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">任务治理器（2000／xp／2003）</span><br><span class="hljs-comment">22</span><span class="hljs-string">.</span> <span class="hljs-comment">winver</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">检查Windows版本</span><br><span class="hljs-comment">23</span><span class="hljs-string">.</span> <span class="hljs-comment">wmimgmt</span><span class="hljs-string">.</span><span class="hljs-comment">msc</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">打开windows治理体系结构(WMI)</span><br><span class="hljs-comment">24</span><span class="hljs-string">.</span> <span class="hljs-comment">wscript</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">windows脚本宿主设置</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">挺有用的</span><br><span class="hljs-comment">25</span><span class="hljs-string">.</span> <span class="hljs-comment">ntmsmgr</span><span class="hljs-string">.</span><span class="hljs-comment">msc</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">移动存储治理器</span><br><span class="hljs-comment">26</span><span class="hljs-string">.</span> <span class="hljs-comment">ntmsoprq</span><span class="hljs-string">.</span><span class="hljs-comment">msc</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">移动存储治理员操纵请求</span><br><span class="hljs-comment">27</span><span class="hljs-string">.</span> <span class="hljs-comment">eventvwr</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">事件查看器</span><br><span class="hljs-comment">28</span><span class="hljs-string">.</span> <span class="hljs-comment">eudcedit</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">造字程序</span><br><span class="hljs-comment">29</span><span class="hljs-string">.</span> <span class="hljs-comment">mobsync</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">同步命令</span><br><span class="hljs-comment">30</span><span class="hljs-string">.</span> <span class="hljs-comment">netstat</span> <span class="hljs-literal">-</span><span class="hljs-comment">an</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">(TC)命令检查接口</span><br><span class="hljs-comment">31</span><span class="hljs-string">.</span> <span class="hljs-comment">syncapp</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">创建一个公文包</span><br><span class="hljs-comment">32</span><span class="hljs-string">.</span> <span class="hljs-comment">sysedit</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">系统配置编辑器</span><br><span class="hljs-comment">33</span><span class="hljs-string">.</span> <span class="hljs-comment">sigverif</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">文件签名验证程序</span><br><span class="hljs-comment">34</span><span class="hljs-string">.</span> <span class="hljs-comment">secpol</span><span class="hljs-string">.</span><span class="hljs-comment">msc</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">本地安全策略</span><br><span class="hljs-comment">35</span><span class="hljs-string">.</span> <span class="hljs-comment">sfc</span><span class="hljs-string">.</span><span class="hljs-comment">exe</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">系统文件检查器</span><br><span class="hljs-comment">36</span><span class="hljs-string">.</span> <span class="hljs-comment">sfc</span> <span class="hljs-comment">&#x2F;scannow</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">windows文件保护</span><br><span class="hljs-comment">37</span><span class="hljs-string">.</span> <span class="hljs-comment">regsvr32</span> <span class="hljs-comment">&#x2F;u</span> <span class="hljs-comment">zipfldr</span><span class="hljs-string">.</span><span class="hljs-comment">dll</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">取消ZIP支持</span><br><span class="hljs-comment">38</span><span class="hljs-string">.</span> <span class="hljs-comment">certmgr</span><span class="hljs-string">.</span><span class="hljs-comment">msc</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">证书治理实用程序</span><br><span class="hljs-comment">39</span><span class="hljs-string">.</span> <span class="hljs-comment">cliconfg</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">SQL</span> <span class="hljs-comment">SERVER</span> <span class="hljs-comment">客户端网络实用程序</span><br><span class="hljs-comment">40</span><span class="hljs-string">.</span> <span class="hljs-comment">ciadv</span><span class="hljs-string">.</span><span class="hljs-comment">msc</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">索引服务程序</span><br><span class="hljs-comment">41</span><span class="hljs-string">.</span> <span class="hljs-comment">odbcad32</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">ODBC数据源治理器</span><br><span class="hljs-comment">42</span><span class="hljs-string">.</span> <span class="hljs-comment">iexpress</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">木马***工具，系统自带</span><br><span class="hljs-comment">43</span><span class="hljs-string">.</span> <span class="hljs-comment">fsmgmt</span><span class="hljs-string">.</span><span class="hljs-comment">msc</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">共享文件夹治理器</span><br><span class="hljs-comment">44</span><span class="hljs-string">.</span> <span class="hljs-comment">utilman</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">辅助工具治理器</span></p><p><strong>闲的蛋疼，没事不要瞎玩类</strong></p><p><span class="hljs-comment">1</span><span class="hljs-string">.</span> <span class="hljs-comment">logoff</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">注销命令</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">别乱用</span><br><span class="hljs-comment">2</span><span class="hljs-string">.</span> <span class="hljs-comment">tsshutdn</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">60秒倒计时关机命令</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">别乱用</span><br><span class="hljs-comment">3</span><span class="hljs-string">.</span> <span class="hljs-comment">rononce</span> <span class="hljs-literal">-</span><span class="hljs-comment">p</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">15秒关机</span><br><span class="hljs-comment">4</span><span class="hljs-string">.</span> <span class="hljs-comment">tsshutdn</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">60秒倒计时关机命令</span><br><span class="hljs-comment">5</span><span class="hljs-string">.</span> <span class="hljs-comment">syskey</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">系统加密，一旦加密就不能解开，保护windows</span> <span class="hljs-comment">xp系统的双重密码</span></p><hr><p><br/>前端新手，弱鸡一枚，如有错误，请指正，谢谢！</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> 必备命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入浅出nodejs学习笔记--第十、十一章 测试 产品化</title>
      <link href="/2017/04/21/"/>
      <url>/2017/04/21/</url>
      
        <content type="html"><![CDATA[<h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a><strong>单元测试</strong></h1><p>我们知道后端都有单元测试，比如学习Java用到的Junit，很好用，那么前端有没有单元测试呢？答案当然是有的。这里就简单总结一下前端单元测试的内容和一些常用的测试框架。</p><h2 id="单元测试编写原则："><a href="#单元测试编写原则：" class="headerlink" title="单元测试编写原则："></a><strong>单元测试编写原则：</strong></h2><p>我们都知道做单元测试可以有很多好处，但是在了解单元测试之前，先来看一下单元测试的编写规则，在编写可测试的代码需要注意以下3个问题：</p><ul><li>单一职责： 尽量细分代码的职责，不要给一段代码附加太多而逻辑从而使代码变得不可控。</li><li>接口抽象： 对于大的项目，业务逻辑比较复杂，要记得写接口，针对接口进行测试。</li><li>层次分离： MVC就是最好的例子。</li></ul><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a><strong>断言</strong></h2><p>单元测试的核心应用就是断言，用一个最简单的例子介绍一下什么是断言：</p><pre><code>var assert = require(&#39;assert&#39;)assert.equal(Math.max(1, 100), 100)</code></pre><p>  equal()是断言模块的内置方法，用于判断实际值与期望值是否相等。类似的方法还有ok()、notEqual()等。上句代码的意思是判断 Math.max(1, 100) 的输出结果是不是100，如果不是，就抛出异常。</p><h2 id="测试框架"><a href="#测试框架" class="headerlink" title="测试框架"></a><strong>测试框架</strong></h2><p>  单元测试很简单，下面介绍两个常用的单元测试库，<strong>jasmine 和 mocha</strong></p><p>  <strong>jasmine</strong></p><p>  Jasmine的开发团队来自PivotalLabs，他们一开始开发的JavaScript测试框架是JsUnit，来源于著名的JAVA测试框架JUnit。JsUnit是xUnit的JavaScript实现。但是JsUnit在2009年后就已经停止维护了，他们推出了一个新的BDD框架Jasmine。Jasmine不依赖于任何框架，所以适用于所有的Javascript代码。</p><p>  下面直接放一个官方的使用案例：</p>  <pre class="prettyprint">describe(<span class="hljs-string">"A spec"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>    <span class="hljs-keyword">var</span> foo;    beforeEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>      foo = <span class="hljs-number">0</span>;      foo += <span class="hljs-number">1</span>;    });    afterEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>      foo = <span class="hljs-number">0</span>;    });    it(<span class="hljs-string">"is just a function, so it can contain any code"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>      expect(foo).toEqual(<span class="hljs-number">1</span>);    });    it(<span class="hljs-string">"can have more than one expectation"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>      expect(foo).toEqual(<span class="hljs-number">1</span>);      expect(<span class="hljs-literal">true</span>).toEqual(<span class="hljs-literal">true</span>);    });    describe(<span class="hljs-string">"nested inside a second describe"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>      <span class="hljs-keyword">var</span> bar;      beforeEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>        bar = <span class="hljs-number">1</span>;      });      it(<span class="hljs-string">"can reference both scopes as needed"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>        expect(foo).toEqual(bar);      });    });  });</pre><p>  jasmine单元测试有二个核心的部分：describe 函数块和it函数块</p><p>  describe和it函数都有二个参数： </p><p>  第一个参数：测试描述； </p><p>  第二个参数：测试用的具体逻辑</p><p>  <strong>mocha</strong></p><p>  mocha的使用和jasmine类似，这里也直接放一个例子：</p>  <pre class="prettyprint">var <span class="hljs-built_in">assert</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'assert'</span>);  describe(<span class="hljs-string">'Array'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> {    describe(<span class="hljs-string">'#indexOf()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> {      it(<span class="hljs-string">'should return -1 when the value is not present'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> {        <span class="hljs-built_in">assert</span>.equal(-<span class="hljs-number">1</span>, [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>].indexOf(<span class="hljs-number">4</span>));      });    });  });</pre><p>describe块称为”测试套件”（test suite），表示一组相关的测试。它是一个函数，第一个参数是测试套件的名称（随便起，能让别人看懂就好），第二个参数是一个实际执行的函数。 </p><p>it块称为”测试用例”（test case），表示一个单独的测试，是测试的最小单位。它也是一个函数，第一个参数是测试用例的名称（随便起，能让别人看懂就好），第二个参数是一个实际执行的函数。</p><p>这里只简单介绍，具体使用可以看阮一峰的mocha实例教程： <a href="http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html">http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html</a></p><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a><strong>性能测试</strong></h2><p>性能测试主要包括基准测试、压力测试、和负载测试：</p><ul><li>基准测试： 基准测试的目的是统计在多少时间内执行了多少方法。</li><li>压力测试：压力测试就是模拟请求测试网络接口，查看吞吐率，响应时间和并发数。常用的工具是ab、siege、http_load,使用很简单，直接看文档就可以使用，这里不多赘述</li><li>负载测试： 负载测试和压力测试很像，主要是测试数据在超负荷环境中运行，程序是否能够承担。</li></ul><h1 id="产品化"><a href="#产品化" class="headerlink" title="产品化"></a><strong>产品化</strong></h1><p>产品化的内容很简单，重点在于实践和工程化中的运用。主要包括以下：</p><h2 id="项目工程化"><a href="#项目工程化" class="headerlink" title="项目工程化"></a><strong>项目工程化</strong></h2><p>目前现有的一些项目工程管理，不如webpack，gulp等，用起来都很方便。</p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a><strong>性能优化</strong></h2><p>以下是几个常见的提升性能的方法：</p><ul><li>动静分离： 动态请求和静态请求分离开来</li><li>启用缓存： 适当利用缓存，但是不可以过分利用缓存</li><li>多线程架构：具体可以参照第九章的笔记</li><li>读写分离：主要针对数据库，因为读写操作速度是不一样的，读的速度是高于写入的速度的，所以对于不同的业务，可以对数据库做读写分离处理，具体可以查看博客：<a href="https://my.oschina.net/candiesyangyang/blog/203425">https://my.oschina.net/candiesyangyang/blog/203425</a></li></ul><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a><strong>日志</strong></h2><p>对于程序来说，写日志是十分重要的，对于异常日志的捕捉都是对日后程序维护的利器，一般情况推荐把日志存为文件，不推荐存入数据库。</p><h2 id="监控报警"><a href="#监控报警" class="headerlink" title="监控报警"></a><strong>监控报警</strong></h2><p>所谓监控主要包括对 日志监控、响应时间、进程监控、磁盘监控、内存监控、CPU占用监控、CPU load监控、I&#x2F;O负载、网络监控、应用状态监控、DNS监控。报警一般都是通过短信或者邮件来执行。</p><h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a><strong>稳定性</strong></h2><p>为保证应用的稳定性，可以采用多机器、多机房、多备份的方式来保证。</p><h2 id="异构共存"><a href="#异构共存" class="headerlink" title="异构共存"></a><strong>异构共存</strong></h2><p>主要是指与其他语言的兼容性，协同作为。</p><hr><p><br/>前端新手，弱鸡一枚，如有错误，请指正，谢谢！</p>]]></content>
      
      
      <categories>
          
          <category> nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入浅出nodejs学习笔记--第九章 玩转进程管理</title>
      <link href="/2017/04/20/"/>
      <url>/2017/04/20/</url>
      
        <content type="html"><![CDATA[<p>node的一个最大特性就是单线程，单线程带来的好处是不用像多线程编程那样去考虑状态的同步问题，也不用去担心出现死锁，也没有线程上下文所带来的性能的开销。但是同时也带来了一些问题，比如无法充分利用的多核CPU，线程会阻塞的问题。</p><p>但是node真的就不能更高效了吗，当然是不会的，如前几篇笔记所说，node对于“多进程”的处理有自己的一套解决方案，今天就来简单了解下。</p><h2 id="服务模型的演变"><a href="#服务模型的演变" class="headerlink" title="服务模型的演变"></a><strong>服务模型的演变</strong></h2><p>在了解node的解决方法之前吗，需要先了解一下Web服务器关于客户端请求的处理方案的一个演变过程，大概如下：</p><p><span class="hljs-comment">同步</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span>&gt; <span class="hljs-comment">复制进程</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span>&gt; <span class="hljs-comment">多线程</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span>&gt; <span class="hljs-comment">事件驱动</span></p><p>一开始，是属于同步的情况，同步的情况，一次只为一个请求服务。到后来，出现了改进，那就是复制进程，通过进程的复制可以服务更多的请求，但是这里的问题是每一个请求都需要一个进程来服务，性能上比较浪费。再后来是多线程，多核CPU的出现，创建多个线程来处理请求，但是这个方案的问题是，在切换现成的同时也需要切换线程的上下文，当线程的数量过多，时间就会被耗费到上下文的切换上。最后的一个就是事件驱动的方案，node和 nginx都是基于事件驱动的方式实现的，采用单线程避免了不必要的内存开销和上下文切换开销。</p><h2 id="node的多进程架构"><a href="#node的多进程架构" class="headerlink" title="node的多进程架构"></a><strong>node的多进程架构</strong></h2><p>node的多进程架构采用了child_process的方式，分为<strong>主进程和工作进程</strong>，主进程不负责具体的业务逻辑，只负责调度和管理工作进程。工作进程负责具体的业务逻辑。</p><p>如下演示如何创建一个子进程，以及一些操作</p><pre class="prettyprint"><span class="hljs-keyword">var</span> child_process = <span class="hljs-built_in">require</span>(<span class="hljs-string">'child_process'</span>) <span class="hljs-comment">//启动一个子进程</span>child_process.spawn(<span class="hljs-string">'node'</span>, [<span class="hljs-string">'test.js'</span>])<span class="hljs-comment">//启动一个子进程，并执行命令</span>child_process.exec(<span class="hljs-string">'node test.js'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err, stdout, stderr)</span> {</span>    <span class="hljs-comment">//回调逻辑</span>})<span class="hljs-comment">//启动一个子进程，并执行可执行文件</span>child_process.execFile(<span class="hljs-string">'test.js'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err, stdout, stderr)</span> {</span>    <span class="hljs-comment">//回调的逻辑</span>})<span class="hljs-comment">//与spawn类似，启动一个子进程，不同的是它创建的进程只需要执行特定的文件模块即可，不参与其他的</span>child_process.fork(<span class="hljs-string">'./test.js'</span>)</pre><p><strong>进程之间的通信</strong></p><p>创建了子进程之后，主进程与子进程之间的通信也是个大问题，进程间通信的目的是为了让不同的进程能够互相访问资源并进行协调工作。node是这样的处理的。</p><p>node通过创建一个管道来解决。父进程在创建子进程之前，会创建管道（IPC通道）来监听，然后才会创建子进程，并且此时子进程可以通过环境变量得到这个管道的文件描述符。子进程在启动的过程中，根据文件描述符去连接这个已存在的IPC通道，从而完成父子进程之间的连接。当然在实际的通信的过程中还会采用句柄传递的方式，说的简单一点就是对一个资源的特殊标识，作用是可以实现多个子进程采用一个句柄来进行通信。</p><p><strong>充分利用多核CPU，node集群</strong></p><p>首先看一下集群的概念，第一眼看到这个名词的时候，有点蒙。</p><p>集群：<br>      在百度百科的解释里，集群（cluster）技术是一种较新的技术，通过集群技术，可以在付出较低成本的情况下获得在性能、可靠性、灵活性方面的相对较高的收益，其任务调度则是集群系统中的核心技术。集群的目的就是提高性能、降低成本、提高可扩展性、增强可靠性。</p><p>用我的理解就是，集群就是指将很多服务器集中起来，一起进行同一种服务,但是对客户端来说，在服务端感觉就是一个的存在。</p><p>关于集群，了解不深，只说两个概念，<strong>负载均衡和状态共享</strong></p><ul><li><strong>负载均衡</strong>：服务器也有负载均衡，但对于node所讨论的，意思就是在多核CPU环境下，始终保证每个CPU都能被使用到从而保证最大效率。node采用的策略是轮叫调度，由主进程接手连接任务，然后依次分发给工作的子进程。</li><li><strong>状态共享</strong>： 也是有两种情况，一种是要第三方存储，利用Redis来实现，一种是主动通知，其实也需要通过轮询来解决。</li></ul><p><strong>一个杀器，cluster模块</strong></p><p>cluster是一个nodejs内置的模块，用于nodejs多核处理。有了这个东西，就基本不用上面的介绍的子进程child_process了。cluster模块可以帮助我们简化多进程并行化程序的开发难度，轻松构建一个用于负载均衡的集群。</p><p>下面看一下官方的示例：</p><pre class="prettyprint"><span class="hljs-keyword">var</span> cluster = <span class="hljs-built_in">require</span>(<span class="hljs-string">'cluster'</span>)<span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>)<span class="hljs-keyword">var</span> numCPUs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'os'</span>).cpus().length  <span class="hljs-comment">//cpu的核心数</span><span class="hljs-keyword">if</span> (cluster.isMaster) {<span class="hljs-comment">//创建多个子进程</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; numCPUs; i++) {    cluster.fork();}cluster.on(<span class="hljs-string">'exit'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(worker, code, signal)</span> {</span>    console.log(<span class="hljs-string">'worker'</span> + worker.process.id + <span class="hljs-string">'died'</span>)})} <span class="hljs-keyword">else</span> {http.createServer(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, res)</span> {</span>    res.writeHead(<span class="hljs-number">200</span>)    res.end(<span class="hljs-string">'hello world'</span>)}).listen(<span class="hljs-number">1234</span>)}</pre><p>顺便解释一下cluster的工作原理：</p><p>cluster模块实际上是<strong>chlid_process和net模块</strong>的组合应用。cluster启动时，会在内部启动一个TCP服务器，在cluster创建一个子进程（fork）时，将这个TCP服务器端socket的文件描述符发送给工作进程。如果进程是复制出来的，并且存在网络端口的调用，那么它就会拿到该文件描述符，并重用，从而实现多个子进程共享端口。</p><p>有关cluster详细的代码实践，可以参考这篇博客：<a href="https://cnodejs.org/topic/56e84480833b7c8a0492e20c">https://cnodejs.org/topic/56e84480833b7c8a0492e20c</a></p><hr><p><br/>前端新手，弱鸡一枚，如有错误，请指正，谢谢！</p>]]></content>
      
      
      <categories>
          
          <category> nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入浅出nodejs学习笔记--第六~八章 理解Buffer 网络编程 构建WEB应用</title>
      <link href="/2017/04/19/"/>
      <url>/2017/04/19/</url>
      
        <content type="html"><![CDATA[<h2 id="第六章-理解Buffer"><a href="#第六章-理解Buffer" class="headerlink" title="第六章 理解Buffer"></a><strong>第六章 理解Buffer</strong></h2><p>这一章要理解的不多，都是一些buffer的常见操作，看API就可以熟悉，如果做过后台的就不会陌生，这里需要注意的几个地方就是</p><ul><li><strong>Buffer所占用的内存</strong>不是通过V8分配的，属于堆外内存，所以意思就是其实在V8启动的时候就会有一个Buffer对象一直常驻内存，无需通过require引入。</li><li><strong>Buffer的内存分配</strong>分为小内存分配和大内存分配，小内存分配一般指的是小于 8kb 的 Buffer 的对象，大内存当然就是大于 8kb的Buffer 对象。</li><li><strong>Buffer的转换</strong>主要体现在字符串转Buffer和Buffer转字符串，字符串转Buffer直接通过构造函数来实现。<br>new Buffer(str, [encording]) &#x2F;&#x2F;encording值编码类型</li></ul><p>Buffer转字符串通过 toString() 可以实现。<br>        buf.toString([encording], [start], [end])</p><ul><li><strong>Buffer的性能</strong>，通过预先转换静态内容为Buffer对象，可以有效减少CPU的重复使用，从而节省服务器资源。</li></ul><h2 id="第七章-网络编程"><a href="#第七章-网络编程" class="headerlink" title="第七章 网络编程"></a><strong>第七章 网络编程</strong></h2><p>这一章也比较简单，主要分为四个，构建TCP服务、构建UDP服务、构建HTTP服务、构建WebSocket服务，前两个不是重点，后两个比较常用。不多说，直接看代码。</p><p><strong>构建TCP服务</strong></p><pre class="prettyprint"><span class="hljs-comment">//示例，创建一个TCP服务器端</span><span class="hljs-keyword">var</span> net = <span class="hljs-built_in">require</span>(<span class="hljs-string">'net'</span>) <span class="hljs-comment">//依赖node自带的net模块</span><span class="hljs-keyword">var</span> server = net.createServer(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(socket)</span> {</span>    <span class="hljs-comment">//新的连接</span>    socket.on(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data)</span> {</span>        console.log(<span class="hljs-string">'连上了'</span>)    })    <span class="hljs-comment">//断开连接</span>    socket.on(<span class="hljs-string">'end'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data)</span> {</span>        console.log(<span class="hljs-string">'连接断开'</span>)    })    socket.write(<span class="hljs-string">'创建一个TCP服务器端'</span>)})<span class="hljs-comment">//监听</span>server.listen(<span class="hljs-number">1234</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>    console.log(<span class="hljs-string">'已绑定1234端口号'</span>)})</pre><p><strong>构建一个UDP服务器端和一个UDP客户端</strong></p><pre class="prettyprint"><span class="hljs-comment">//示例，创建一个UDP服务器端</span><span class="hljs-keyword">var</span> dgram = <span class="hljs-built_in">require</span>(<span class="hljs-string">'dgram'</span>)<span class="hljs-keyword">var</span> server = dgram.createSocket(<span class="hljs-string">'udp4'</span>)server.on(<span class="hljs-string">'message'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(msg, rinfo)</span> {</span>console.log(<span class="hljs-string">'服务器得到了'</span> + msg + <span class="hljs-string">'来自'</span> + rinfo.address + <span class="hljs-string">':'</span> + rinfo.port)})server.on(<span class="hljs-string">'listening'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span><span class="hljs-keyword">var</span> address = server.address()console.log(<span class="hljs-string">'已绑定'</span> + rinfo.address + <span class="hljs-string">':'</span> + rinfo.port)})<span class="hljs-comment">//示例，创建一个UDP客户端，与UDP服务器端对话</span><span class="hljs-keyword">var</span> dgram = <span class="hljs-built_in">require</span>(<span class="hljs-string">'dgram'</span>)<span class="hljs-keyword">var</span> message = <span class="hljs-keyword">new</span> Buffer(<span class="hljs-string">'test.txt'</span>)<span class="hljs-keyword">var</span> client = dgram.createSocket(<span class="hljs-string">'udp4'</span>)<span class="hljs-comment">//通过客户端发送给网络，参数分别对应 要发送的Buffer  Buffer的偏移  Buffer的长度  目标端口 目标地址 完成后的回调</span>client.send(message, <span class="hljs-number">0</span>, message.length, <span class="hljs-number">1234</span>, <span class="hljs-string">'localhost'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err, bytes)</span> {</span> client.close();})</pre><p><strong>构建一个HTTP服务器</strong></p><p>这个真的好熟悉，如下：</p><pre class="prettyprint">//示例，创建一个HTTP服务器, <span class="hljs-keyword">http</span>模块继承于TCP中的net模块var <span class="hljs-keyword">http</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>)<span class="hljs-keyword">http</span>.createServer(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-title">req</span>, <span class="hljs-title">res</span>) {</span>    res.writeHead(<span class="hljs-number">200</span>, {<span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'text/plain'</span>})    res.<span class="hljs-keyword">end</span>(<span class="hljs-string">'雷猴\n'</span>)}).listen(<span class="hljs-number">1234</span>, <span class="hljs-string">'localhost'</span>)console.<span class="hljs-built_in">log</span>(<span class="hljs-string">'已绑定 http://localhost:1234'</span>)</pre><p><strong>构建WebSocket服务</strong></p><p>WebSocket也是一种基于事件的编程模型，所以和Node结合也是相得益彰，同时WebSocket实现了客户端和服务器端之间的长连接，Node事件驱动的方式十分擅长于大量的客户端保持高并发的连接。</p><pre class="prettyprint">//示例，WebSocket在客户端的应用var <span class="hljs-built_in">socket</span> = <span class="hljs-built_in">new</span> WebSocket(<span class="hljs-string">'ws://localhost:1234/update'</span>)<span class="hljs-built_in">socket</span>.onopen = <span class="hljs-function"><span class="hljs-keyword">function</span> () {</span>    setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span> () {</span>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">socket</span>.bufferedAmount === <span class="hljs-number">0</span>) {            <span class="hljs-built_in">socket</span>.<span class="hljs-built_in">send</span>(getUpdateData())        }    }, <span class="hljs-number">50</span>)}<span class="hljs-built_in">socket</span>.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-title">event</span>) {</span>   <span class="hljs-comment"> //todo: event.data 的处理</span>}</pre><p><strong>网络服务与安全</strong></p><p>还有一个关于网络编程的便是网络安全。node在网络安全上提供了3个模块，<strong>crypto</strong>、<strong>tls</strong>、<strong>https</strong>。其中crypto主要用于加密解密，tls模块提供了与net模块类似的功能，区别在于建立在TSL&#x2F;SSL加密的TCP连接之上，https与http基本都是一致的，区别在于前者更安全。</p><h2 id="第八章-构建Web应用"><a href="#第八章-构建Web应用" class="headerlink" title="第八章 构建Web应用"></a><strong>第八章 构建Web应用</strong></h2><p>关于构建Web应用这一章，其实现有其他的框架讲的而且运用的已经很详细，比如KOA，比如Express，试着运用这两个做一个web应用更能加深理解，这里就总结一下构建Web应用的组成</p><p><strong>基础功能</strong></p><ul><li><strong>请求方法</strong>：常见的请求方法有GET、POST、PUT、DELETE，存在于请求报文的第一行的第一个单词，通常为大写。</li><li><strong>路径解析</strong>：浏览器将请求解析成报文，位于请求报文的第二行。</li><li><strong>查询字符串</strong>：即请求传递的参数。</li><li><strong>cookie</strong>：记录服务器和客户端之间的状态。服务器端生成向客户端发送 –&gt; 浏览器保存cookie –&gt;<br>每次浏览器发送请求都会携带cookie，cookie会造成带宽浪费，所以可以减少cookie的大小，为静态的组件使用不同的域名，减少DNS的查询来避免。</li><li><strong>session</strong>：与cookie作用类似，但是session只保留在服务器端，并且常驻内存（利用Redis或者Memcached可以统一转移到集中的数据存储中）。session也会有安全问题，但是相对较小，常见的漏洞就是XSS漏洞（跨站脚本攻击）。</li><li><strong>缓存</strong>：利用浏览器来缓存静态资源，目的是提升加载速度从而提升体验。</li><li><strong>Basic认证</strong>：请求报文头部的Authorization，这种方式有缺陷，因为在网络传输中这些验证接近于明文，所以不可取。</li></ul><p><strong>数据上传</strong></p><ul><li><strong>表单数据</strong>：即常见的form表单提交。</li><li><strong>JSON&#x2F;XML</strong>: 提交的数据是JSON&#x2F;XML格式的，现在大部分的交互都是用的JSON，XML的也有用，比如微信公众号平台的开发的交互就是用的XML，这个真的贼坑。</li><li><strong>附件上传</strong>：利用form-data来实现附件上传。</li><li><strong>数据上传安全</strong>：数据上传的安全性问题主要体现在内存限制和跨站伪造请求的问题上，所以一要对上传做限制，而是在开发中要加hash值做标识，就是加一个随机数。</li></ul><p><strong>路由解析</strong></p><ul><li><strong>文件路径型</strong>：分为静态文件和动态文件，不需要解释。</li><li><strong>MVC</strong>：前端MVC，之前一篇博客有讲，现在前端都是MV*。</li><li><strong>RESTful</strong>: 表述性状态转移，强调所有的资源都是可以通过URL访问到，对URL做文章，与MVC不冲突。可以看下阮一峰的博客：<a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html">http://www.ruanyifeng.com/blog/2014/05/restful_api.html</a></li></ul><p><strong>中间件</strong></p><ul><li><strong>异常处理</strong>：中间件的核心就是尾调用next()，所以对于一些异常，需要在next()添加一个参数,并且把捕获到的异常传递过来。</li><li><strong>性能</strong>：中间件的出现时服务于具体业务的，所以要特殊特用，性能问题并不大。</li></ul><p><strong>页面渲染</strong></p><ul><li><strong>内容响应</strong>：内容的响应主要依赖于报文中的Content-*字段，它决定了客户端会以什么样的方式来作出响应，下载、跳转等。</li><li><strong>视图渲染</strong>：一般是通过模板加数据共同生成出来的。</li><li><strong>模板</strong>：比视图渲染更进一步，模板的使用的对前端页面的一种复用，是对html体的复用。比如javaweb中的jsp，或者PHP，当然这些都相对成熟，对于初出茅庐的node来说，现在常用的模板渲染模块有jade,heredoc,ejs等。</li></ul><hr><p><br/>前端新手，弱鸡一枚，如有错误，请指正，谢谢！</p>]]></content>
      
      
      <categories>
          
          <category> nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入浅出nodejs学习笔记--第五章 内存控制</title>
      <link href="/2017/04/18/"/>
      <url>/2017/04/18/</url>
      
        <content type="html"><![CDATA[<p>首先声明一下，这个内存控制指的是V8引擎的内存控制，听起来很高大上，平时web开发可能不会去考虑浏览器的内存控制机制，但是其实我们在学习js的时候就有多少了解到垃圾回收和内存监控这相关的知识。</p><h2 id="Js的垃圾回收机制和内存控制"><a href="#Js的垃圾回收机制和内存控制" class="headerlink" title="Js的垃圾回收机制和内存控制"></a><strong>Js的垃圾回收机制和内存控制</strong></h2><p>在<strong>《JavaScript高级程序设计》（第三版）</strong>里也有提到了<strong>js的垃圾回收机制和内存回收</strong>问题，这里简单的回想一下：</p><p>我们知道，js和java的一个共同点就是有自己的垃圾回收机制，所以他们不用像C&#x2F;C++程序员一样在编写代码的时候去关心内存的分配与释放的问题。关于js的垃圾回收机制，主要有以下两种：</p><ul><li><strong>标记清除</strong>： 这个很容易理解，就是当你在函数内声明一个变量，那么在函数执行的时候，就将该变量进行标记，标记为进入，函数执行完毕就标记为离开，进入标记的是不可以被回收的</li><li><strong>引用计数</strong>： 更简单的，就是一个变量被使用的次数，用到一次就加一，数目小于多少的就给予清除</li></ul><p><strong>那么如何管理内存呢？</strong></p><p>前面也说了，因为有自动的垃圾回收机制，所以程序员不用去操心内存管理的问题，但是要注意的一点就是，js的可用内存是很小的，或者说是远远小于桌面程序的可使用内存（这个后面再说），所以为了确保占用最少的内存可以让页面获得更好地性能，最佳方式就是为执行中的代码只保存必要的数据，一旦数据不再有用，就将其释放（比如设置其值为null来释放引用），这样做的目的是解除变量的引用从而使垃圾收集机制在下次运行时将其回收（垃圾回收机制是按照固定的时间间隔或者预设的时间进行处理的，所以这个时间的长短也要考虑性能问题）</p><h2 id="V8的内存分配"><a href="#V8的内存分配" class="headerlink" title="V8的内存分配"></a><strong>V8的内存分配</strong></h2><p>那么说完了js中的内存管理，那么就到了我们今天讨论的V8引擎，浏览器内的内存控制。</p><p><strong>内存限制</strong></p><p>首先呢，通过Node使用内存时是只可以使用部分内存的，这个大小大概在（64位系统下是1.4GB，32位系统下是0.7GB），在V8中，所有的js对象都是通过堆来进行分配的，这个可以通过控制台输入 process.memoryUsage() 方法查看。执行此操作需要切换到node命令执行环境。</p><p><strong>V8的内存分配</strong></p><p>在V8中，主要将内存分为新生代和老生代两种，新生代中的对象为存活时间比较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。V8的堆内存的大小就是新生代加上老生代的大小。而V8关于内存限制的算法主要有两种，这里只简单提及一下。</p><p>一种是牺牲空间换时间的算法，叫做<strong>Scavenge</strong>算法，通过该算法来回收新生代中的对象，原理就是讲新生代的内存一分为二，A和B，A和B永远都是一个处于空闲状态，一个处于使用状态，在垃圾回收的时，会检查使用中的A，如果A中存在还使用的对象啥的，就复制给空闲中的B，然后A中没有被使用对象啥的就会被清除，如此往复，达到垃圾清除的目的，但是这个算法有一个问题就是，如果A中存活的还在使用的对象是比较少的，那么在进行复制时，这个效率是很高的，但如果A中存活的对象比较大，效率就不能满足需求了。</p><p>这就牵扯到另外一种算法了，另外一种就是 <strong>Mark-Sweep</strong> 和 <strong>Mark-Compact</strong> ，标记清除方法，这个很简单，就是没有一分为二的概念，直接查找内存中的存活或者死亡的对象，然后添加一个标记，然后等垃圾回收进行清除，需要注意的一点，为了避免标记清除造成的内存碎片化，需要在对象被标记死亡后进行一次整理，将或者的对象往一端靠拢，举个例子就是好人站内存左边，坏人站内存右边，等会收拾坏人。</p><p><strong>如何高效的使用内存</strong> </p><p>这一块儿呢，只需要注意作用域和闭包带来的问题就好，跟js中的优化是一样的，不作介绍。</p><p><strong>内存泄漏</strong></p><p>内存泄漏是程序员在与内存打交道时一定要注意的问题，通常情况下，造成内存泄露的原因主要有三个： <strong>缓存、 队列消费不及时、 作用域未释放</strong>。</p><p>基于此，避免造成内存泄漏的方案也有以下两种：</p><ul><li><strong>不要将内存当做缓存</strong>： 说不要太过了，尽量不要吧；</li><li><strong>关注队列状态</strong>： 队列状态造成的内存泄漏其实不容易发生，因为大多数情况是使用的速度是大于生产的速度的，是不会有库存的。但是二班情况，如果出现了，就很难排查，所以对于队列状态引起的内存泄漏，应监控队列的长度，如果长度超过了一定限制，就给出异常拒绝再使用内存。</li></ul><hr><p><br/>前端新手，弱鸡一枚，如有错误，请指正，谢谢！</p>]]></content>
      
      
      <categories>
          
          <category> nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入浅出nodejs学习笔记--第四章 异步编程</title>
      <link href="/2017/04/17/"/>
      <url>/2017/04/17/</url>
      
        <content type="html"><![CDATA[<p>这一章的知识跨度看起来不广，但是知识深度的还是挺深的，异步编程作为nodejs的核心，个人同时需要一定的深度才可以去理解。</p><p>在这一章提到了函数式编程和异步编程解决方案的两个知识点，首先来了解一下函数式编程</p><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a><strong>函数式编程</strong></h2><p>这里先放一本书，<a href="https://www.gitbook.com/book/llh911001/mostly-adequate-guide-chinese/details">https://www.gitbook.com/book/llh911001/mostly-adequate-guide-chinese/details</a> 觉得讲得不错，因为越到后面越看不懂</p><p>JavaScript其实之前是一直被误解的，因为它一直被当做是命令式式的编程语言，或许js爸爸<strong>Brendan Eich</strong>一开始设计的时候也是这样想的，但是其实js也是可以做函数式的编程。所谓函数式编程，其实不难，不同于后台强类型语言的面向对象式的编程语言，函数式编程是种编程范式，它将电脑运算视为函数的计算，强调计算。</p><p>函数式编程有以下特点：支持闭包和高阶函数，支持惰性计算（lazy evaluation）。使用递归作为控制流程的机制。加强了引用透明性。没有副作用。（这句话是百度的）</p><p>这本书主要介绍了函数式编程的一些规范，我只拿其中的简单几个概念作为例子</p><p><strong>高阶函数</strong>： 高阶函数是可以把函数作为参数（如传递一个方法作为参数），或者说是可以把函数作为返回值的函数（其实就是return一个函数）</p><p><strong>偏函数</strong>： 偏函数是指通过部分参数来产生一个新的定制的函数的方式，这种就叫做偏函数</p><p><strong>纯函数</strong>： 书中的定义是这样的，纯函数是这样一种函数，即相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用。其实最重要的就是这句话，相同的输入总会的得到相同的输出，纯函数的纯就在这一点，不过多的对函数之外的环境产生依赖，保证函数本身的纯粹，从而达到纯的目的</p><p><strong>函数柯里化</strong>：curry无法口述，用一个例子来解释</p><pre><code>    var add = function(x) &#123;        return function(y) &#123;            return x + y;        &#125;;    &#125;;    var increment = add(1);    var addTen = add(10);    increment(2);    // 3    addTen(2);</code></pre><p>这里我们定义了一个 add 函数，它接受一个参数并返回一个新的函数。调用add 之后，返回的函数就通过闭包的方式记住了 add 的第一个参数。一次性地调用它实在是有点繁琐，好在我们可以使用一个特殊的 curry 帮助函数（helperfunction）使这类函数的定义和调用更加容易。</p><h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a><strong>异步编程</strong></h2><p><strong>异步编程的优势和难点</strong></p><p>node的异步编程所带来的最大优势就是基于事件驱动的<strong>非阻塞IO模型</strong>。非阻塞IO可以是CPU和IO操作并不相互依赖等待，让资源得以更好地利用。对于一些网络应用而言，并行还可以带来的优势是分布式和云。</p><p>但同时，node所带来的难点还是很困难的：</p><p><strong>难点1</strong>： 异常处理 异步中的异常都是这个尿性，看下jquery的ajax就知道，所以在编写异步方法时，需要将异常正确的返回给用户的回调方法</p><p><strong>难点2</strong>： 函数嵌套过深 回调地狱，不解释，但是现在有Promise,接下来会说</p><p><strong>难点3</strong>： 阻塞代码 单线程的缺点，谨慎处理</p><p><strong>难点4</strong>： 多线程编程 还是单线程所带来的问题，不过node有自己child_process</p><p><strong>难点5</strong>： 异步转同步 </p><p>  这个就是node用惯了异步，但是没有同步操作的API，所以可能在实现同步的时候要去借助第三方库，不过放心，npm上面的插件肯定很多</p><h2 id="异步编程的解决方案"><a href="#异步编程的解决方案" class="headerlink" title="异步编程的解决方案"></a><strong>异步编程的解决方案</strong></h2><p>关于异步编程的解决方案，书中给出了四种，分别是<strong>事件发布&#x2F;订阅模式、Promise&#x2F;Deferred、流程控制库、异步并发控制</strong></p><p><strong>事件发布&#x2F;订阅模式</strong>： 这个就是设计模式中的一个概念，node中的event模块其实是一个很好地实践</p><p><strong>Promise&#x2F;Deferred</strong>： 强调事件的状态和目标，根据状态来执行，从而避免深度嵌套，这个es6中的Promise也已经有了很好地实现</p><p><strong>流程控制库</strong>：流程控制的一个重要的概念就是尾触发，es6对这个有个比较好的实现，那就是终止函数，在es7的草案中，更是直接使用了await作为流程控制中止函数标识</p><p><strong>异步并发控制</strong>： 考虑到异步操作对内存的影响，为避免cpu挂掉，所以要对异步的并发进行控制</p><p><strong>扩展：</strong></p><p>既然说到了流程控制，就不得不说现在最流行的两个前端框架，<strong>Express</strong>和<strong>koa</strong></p><p>Express是一个老牌的web应用框架了，Express 是一个基于 Node.js 平台的极简、灵活的 web 应用开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。 </p><p>具体移步官网看，官网：<a href="http://www.expressjs.com.cn/">http://www.expressjs.com.cn/</a>。</p><p>koa是新一种的前端框架，koa 是由 Express 原班人马打造的，致力于成为一个更小、更富有表现力、更健壮的 Web 框架。使用 koa 编写 web 应用，通过组合不同的 generator，可以免除重复繁琐的回调函数嵌套，并极大地提升错误处理的效率。koa 不在内核方法中绑定任何中间件，它仅仅提供了一个轻量优雅的函数库，使得编写 Web 应用变得得心应手。koa低层的实现依赖TJ大神的CO，库很小巧，暂时不深入，具体移步官网，官网：<a href="http://koa.bootcss.com/">http://koa.bootcss.com/</a></p><hr><p><br/>前端新手，弱鸡一枚，如有错误，请指正，谢谢！</p>]]></content>
      
      
      <categories>
          
          <category> nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入浅出nodejs学习笔记-前三章 简介、模块机制、异步I/O</title>
      <link href="/2017/04/16/"/>
      <url>/2017/04/16/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-node简介"><a href="#第一章-node简介" class="headerlink" title="第一章 node简介"></a>第一章 node简介</h2><p>在学习这章之前，先提三个问题，node是什么，为什么用node，node可以用来干什么？</p><p><strong>首先是回答第一个问题，node是什么？</strong></p><p>node习惯称为nodejs，听起来类似于js库，但是其实node并不是一个库，node其实是一个可以在后端运行JavaScript的环境。</p><p>js为什么可以在后端运行呢，不是只可以在浏览器运行吗？其实是js之所以可以再浏览器运行是因为在浏览器中集成了js解析引擎，类似Firefox的SpiderMonkey和IE的Chakra，其中最有名的当属于chrome的v8引擎，而node便是利用到了v8引擎，所以才可以在服务器端跑js，当如正如你所想的，因为node并没有渲染引擎，所以node是不处理UI的。</p><p><strong>那为什么要用node？</strong></p><p>作为一个后端js的运行平台，node要好用才会用啊，喏，如下：</p><ol><li><strong>异步IO</strong>：其实就是异步执行的IO操作，不用多说</li><li><strong>单线程</strong>：node是单线程运行的，所以不用考虑多线程地带来的同步啊、死锁之类的问题，但同时会带来一些问题，比如无法充分的利用多核CPU、一旦报错，程序就GG、CPU过载就会出异常等，对于这些问题，node也有一个简单的解决办法就是child_process，这个暂时先不谈</li><li><strong>跨平台</strong>：作为一个后台运行平台，这是JavaScript浩浩荡荡进军后台之势，当然也要像后台爸爸Java一样跨平台才好用哈</li><li><strong>事件与回调函数</strong>：node是基于事件驱动的，基于事件编程有<strong>轻量级、轻耦合、只关注事务点</strong>等优势，其实就是更关注业务逻辑，毕竟是前端</li></ol><p><strong>最后的问题，node可以用来干什么</strong></p><p>如上的node优势所说，一方面，node基于异步IO的特点，node擅长于处理IO密集型业务，另一方面，V8是十分强大的，所以node也很适合CPU密集型业务，而且效率不比java差哈，同时，node也比较适合于做一些游戏开发领域的事情、做分布式应用和一些工具类应用的开发</p><h2 id="第二章-node模块机制"><a href="#第二章-node模块机制" class="headerlink" title="第二章 node模块机制"></a>第二章 node模块机制</h2><p><strong>node模块机制</strong></p><p>关于node的模块机制，首先提一下CommonJS，CommonJS就是为JS的表现来制定规范，因为js没有模块的功能所以CommonJS应运而生，它希望js可以在任何地方运行，不只是浏览器中。CommonJS的模块规范如下</p><pre class="prettyprint"><span class="hljs-comment">//a.js</span>exports.yeah = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>    console.log(<span class="hljs-string">'yeah'</span>)}<span class="hljs-comment">//b.js</span><span class="hljs-keyword">var</span> yeah = <span class="hljs-built_in">require</span>(<span class="hljs-string">'yeah'</span>)</pre><p>在文件a中通过exports暴露出去一个yeah方法，然后在b.js文件中通过require引用，十分方便,但是CommonJS的缺陷还是很明显的，<strong>没有模块系统，标准库很少，没有标准的接口，缺乏包管理系统</strong>等。</p><p>作为站在巨人肩膀上的node，node在实现中并非完全按照CommonJS的模块规范，而是对模块规范进行了一定的取舍，同事也增加了不少自身需要的特性。</p><p>node的模块分为两类，一种是Node提供的模块，叫做<strong>核心模块</strong>;一种是用户自己编写的模块，叫做<strong>文件模块</strong> </p><p>核心模块被编译成二进制执行文件，在node启动时就被直接加载到内存中，所以执行速度最快，文件模块则是运行时加载，按照路径分析 –&gt; 文件定位 –&gt; 编译执行 的步骤加载执行</p><p>node有自己的包规范NPM，npm是什么，npm是一个包管理的神器，这个真的不能多说，每天都用</p><p><strong>前后端共用模块</strong></p><p>前后端共用模块主要有两种，AMD和CMD</p><p>AMD 即Asynchronous Module Definition，中文名是异步模块定义的意思。它是一个在浏览器端模块化开发的规范，由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎RequireJS，实际上AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出</p><p>requireJS主要解决两个问题</p><ol><li><p>多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器</p></li><li><p>js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长</p><p>看一个使用requireJS的例子</p></li></ol><pre class="prettyprint"><span class="hljs-comment">// 定义模块 myModule.js</span>define([<span class="hljs-string">'dependency'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>    <span class="hljs-keyword">var</span> name = <span class="hljs-string">'Byron'</span>;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printName</span><span class="hljs-params">()</span>{</span>        console.log(name);    }    <span class="hljs-keyword">return</span> {        printName: printName    };});<span class="hljs-comment">// 加载模块</span><span class="hljs-built_in">require</span>([<span class="hljs-string">'myModule'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(my)</span>{</span>　 my.printName();});</pre><p>CMD由国内的玉伯提出，CMD模块更接近于Node对CommonJS的实现，CMD和AMD有什么区别，看下<a href="https://www.zhihu.com/people/lifesinger/answers">玉伯</a>是怎么回答的吧<a href="https://www.zhihu.com/question/20351507/answer/14859415">https://www.zhihu.com/question/20351507/answer/14859415</a></p><h2 id="第三章-异步IO"><a href="#第三章-异步IO" class="headerlink" title="第三章 异步IO"></a>第三章 异步IO</h2><p>异步IO真心没啥可提的，需要知道的是异步IO实现的核心是事件循环(过去是轮询技术)，他与浏览器中的执行模型基本保持了一致。</p><hr><p><br/><strong>前端新手，弱鸡一枚，如有错误，请指正，谢谢！</strong></p>]]></content>
      
      
      <categories>
          
          <category> nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[原]有意思的前端面试题-附答案（一）</title>
      <link href="/2017/03/14/"/>
      <url>/2017/03/14/</url>
      
        <content type="html"><![CDATA[<p>超过20家的前端面试题汇总，每天做一点，专挑有意思的做 </p><p>  此面试题题目部分来源： </p><p>  <a href="https://juejin.im/post/58c51b5c44d90400698da686?utm_source=gold_browser_extension">https://juejin.im/post/58c51b5c44d90400698da686?utm_source&#x3D;gold_browser_extension</a></p><p>1：当前一段代码输出结果是什么？</p><pre class="prettyprint"><span class="hljs-keyword">var</span> z = <span class="hljs-number">10</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>{</span>    console.log(z);}(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(funArg)</span>{</span>    <span class="hljs-keyword">var</span> z = <span class="hljs-number">20</span>;    funArg();})(foo);</pre><p><strong>【答案】：10</strong> </p><p><strong>这个其实还是考察函数的作用域和闭包的知识，因为foo函数是在一个自执行匿名函数里调用，在这里面声明的变量其实在函数foo体并不会访问到，所以在去找爸爸，全局声明的z，即输出 10</strong></p><p>2.当前一段代码输出结果是什么？</p><pre class="prettyprint"><span class="hljs-title">var</span> <span class="hljs-typedef"><span class="hljs-keyword">data</span> = [];</span><span class="hljs-title">for</span>(var k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">3</span>; k++){        <span class="hljs-typedef"><span class="hljs-keyword">data</span>[k] = function<span class="hljs-container">()</span><span class="hljs-container">{            <span class="hljs-title">console</span>.<span class="hljs-title">log</span>(<span class="hljs-title">k</span>);        }</span>;</span>}<span class="hljs-typedef"><span class="hljs-keyword">data</span>[0]<span class="hljs-container">()</span>;</span><span class="hljs-typedef"><span class="hljs-keyword">data</span>[1]<span class="hljs-container">()</span>;</span><span class="hljs-typedef"><span class="hljs-keyword">data</span>[2]<span class="hljs-container">()</span>;</span></pre><p><strong>【答案】： 3 3 3</strong>  </p><p><strong>闭包，不多讲，把K的声明换成es6的写法let就可以变成 0 1 2</strong></p><p>3.假设现有一篇文章，var content &#x3D; “…大量文字”， </p><p>文章中触及到一些敏感词汇,如 [“习近平”,”周永康”,”中共”,”6.4”] 等内容。 </p><p>如何在文章中发现这些敏感词，并将背景设置为红色或者改变字体颜色并标示出来。</p><p><strong>【答案】</strong> </p><p><strong>利用正则来做，方便快捷</strong></p><pre class="prettyprint"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filter</span><span class="hljs-params">(content)</span> {</span>    <span class="hljs-keyword">var</span> result = <span class="hljs-string">''</span>;    <span class="hljs-comment">// 预先设置的敏感词</span>    <span class="hljs-keyword">var</span> minWords = [<span class="hljs-string">"习近平"</span>, <span class="hljs-string">"周永康"</span>, <span class="hljs-string">"中共"</span>, <span class="hljs-string">"6.4"</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; content.length; i++) {        <span class="hljs-keyword">var</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(minWords[i], <span class="hljs-string">"ig"</span>);        result = content.replace(reg, <span class="hljs-string">""</span>);    }    <span class="hljs-keyword">return</span> result;}</pre><p>4.<em>JQuery</em> 中 <em>$.fn.extend</em> 函数的实现（实现核心代码即可） </p><p><strong>【答案】</strong> </p><p><strong>先来看一下extend的用法，$.fn.extend 用于合并两个对象或多个对象到第一个对象上，它们的语法如下：</strong></p><pre class="prettyprint">jQuery<span class="hljs-preprocessor">.extend</span>([deep],target,object1,[..<span class="hljs-preprocessor">.objectN</span>])jQuery<span class="hljs-preprocessor">.fn</span><span class="hljs-preprocessor">.extend</span>([deep],target,object1,[..<span class="hljs-preprocessor">.objectN</span>])</pre><p><strong>以下是核心代码（从源码拷过来的）：</strong></p><pre class="prettyprint"><span class="hljs-comment">//关键：修正参数deep、target、源对象的起始下标 =&gt; 逐个遍历源对象    </span>jQuery.extend = jQuery.fn.extend = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>    <span class="hljs-comment">/**      * options: 指向某一个源对象     * name: 代表某个源对象里的某个属性名     * src: 代表某个源对象里的某个属性的原始的值     * copy: 表示某个源对象里的某个属性的值     * copyIsArray: 表示变量copy是否为数组     * clone: 表示进行深度复制时原始值的修正值     * target: 指向目标对象     * deep: 表示是否执行深度复制，默认为false不进行     */</span>    <span class="hljs-keyword">var</span> options, name, src, copy, copyIsArray, clone,        target = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>] || {},        i = <span class="hljs-number">1</span>,        length = <span class="hljs-built_in">arguments</span>.length,        deep = <span class="hljs-literal">false</span>;    <span class="hljs-comment">//如果第一个参数时布尔值，就把第二个参数当做是目标对象</span>    <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> target === <span class="hljs-string">"boolean"</span> ) {        deep = target;        target = <span class="hljs-built_in">arguments</span>[ i ] || {};        i++;    }    <span class="hljs-comment">//如果目标对象不是对象或者一个函数，那就当作 空对象 处理</span>    <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> target !== <span class="hljs-string">"object"</span> &amp;&amp; !jQuery.isFunction(target) ) {        target = {};    }    <span class="hljs-comment">//没有传入源对象的情况（1,只有一个参数 2，第一个参数时deep值，第二个参数是参数）</span>    <span class="hljs-keyword">if</span> ( i === length ) {        target = <span class="hljs-keyword">this</span>;        i--;    }    <span class="hljs-keyword">for</span> ( ; i &lt; length; i++ ) {        <span class="hljs-keyword">if</span> ( (options = <span class="hljs-built_in">arguments</span>[ i ]) != <span class="hljs-literal">null</span> ) {            <span class="hljs-keyword">for</span> ( name <span class="hljs-keyword">in</span> options ) {                src = target[ name ];                copy = options[ name ];                <span class="hljs-keyword">if</span> ( target === copy ) {                    <span class="hljs-keyword">continue</span>;                }                <span class="hljs-comment">//覆盖掉同名属性</span>                <span class="hljs-keyword">if</span> ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {                    <span class="hljs-keyword">if</span> ( copyIsArray ) {                        copyIsArray = <span class="hljs-literal">false</span>;                        clone = src &amp;&amp; jQuery.isArray(src) ? src : [];                    } <span class="hljs-keyword">else</span> {                        clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : {};                    }                    target[ name ] = jQuery.extend( deep, clone, copy );                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( copy !== <span class="hljs-literal">undefined</span> ) {                    target[ name ] = copy;                }            }        }    }    <span class="hljs-keyword">return</span> target;};</pre><p>5.设计基于观察者模式的事件绑定机制 </p><p><strong>【答案】（此答案代码来自网络）</strong> </p><p><strong>首先要明白什么是观察者模式，观察者模式简单的说，就是当一个对象被修改时，则会自动通知它的依赖对象。观察者模式其实就是发布-订阅的过程。</strong> </p><p><strong>举个例子，我来公司面试的时候，完事之后每个面试官都会对我说：“请留下你的联系方式， 有消息我们会通知你”。 在这里“我”是订阅者， 面试官是发布者。所以我不用每天或者每小时都去询问面试结果， 通讯的主动权掌握在了面试官手上。而我只需要提供一个联系方式。</strong> </p><p><strong>以此为例，来编写代码，面试者把简历扔到一个盒子里， 然后面试官在合适的时机拿着盒子里的简历挨个打电话通知结果.</strong></p><pre class="prettyprint">Events = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>    <span class="hljs-keyword">var</span> listen, obj, one, remove, trigger, __this;    obj = {};    __this = <span class="hljs-keyword">this</span>;    listen = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(key, eventfn)</span> {</span> <span class="hljs-comment">//把简历扔盒子, key就是联系方式.</span>        <span class="hljs-keyword">var</span> stack, _ref; <span class="hljs-comment">//stack是盒子</span>        stack = (_ref = obj[key]) != <span class="hljs-literal">null</span> ? _ref : obj[key] = [];        <span class="hljs-keyword">return</span> stack.push(eventfn);    };    one = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(key, eventfn)</span> {</span>        remove(key);        <span class="hljs-keyword">return</span> listen(key, eventfn);    };    remove = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(key)</span> {</span>        <span class="hljs-keyword">var</span> _ref;        <span class="hljs-keyword">return</span> (_ref = obj[key]) != <span class="hljs-literal">null</span> ? _ref.length = <span class="hljs-number">0</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;    };    trigger = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span> <span class="hljs-comment">//面试官打电话通知面试者</span>        <span class="hljs-keyword">var</span> fn, stack, _i, _len, _ref, key;        key = <span class="hljs-built_in">Array</span>.prototype.shift.call(<span class="hljs-built_in">arguments</span>);        stack = (_ref = obj[key]) != <span class="hljs-literal">null</span> ? _ref : obj[key] = [];        <span class="hljs-keyword">for</span> (_i = <span class="hljs-number">0</span>, _len = stack.length; _i &lt; _len; _i++) {            fn = stack[_i];            <span class="hljs-keyword">if</span> (fn.apply(__this, <span class="hljs-built_in">arguments</span>) === <span class="hljs-literal">false</span>) {                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            }        }    };    <span class="hljs-keyword">return</span> {        listen: listen,        one: one,        remove: remove,        trigger: trigger    }}</pre>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[原]简单理解内存中的堆栈与数据结构中的堆栈</title>
      <link href="/2017/03/08/"/>
      <url>/2017/03/08/</url>
      
        <content type="html"><![CDATA[<p>一日中午，平静的办公室忽然发出这样一个声音：什么是堆栈？ </p><p>于是瞬间，办公室开始闹腾起来 </p><p>A：堆栈就是后进后出 </p><p>B：堆就是时间牺牲空间，栈就是空间牺牲时间 </p><p>C：栈更快，堆就略微慢一点 </p><p>D：…… </p><p>作为刚毕业的码畜，听完之后就有些懵逼了（WTF，堆栈还有这么多东西吗？），于是上网搜寻各种资料，发现了一个在大学知识容易混淆的知识点，那就是——数据结构中的堆栈与内存中的堆栈存储是不同的</p><h2 id="数据结构中的堆栈"><a href="#数据结构中的堆栈" class="headerlink" title="数据结构中的堆栈"></a><strong>数据结构中的堆栈</strong></h2><p>先说数据结构中的堆栈，这个就是我们大学课程《数据结构》中所学到的，通俗上的堆栈的理解，堆和栈是数据存储方式的两种数据结构。关于堆栈，其实还有一个比较容易搞混的地方那就是队列，其实这三种都是数据结构中的一种排序数据结构 </p><ul><li><p><strong>堆</strong>：堆的数据机构其实就是一个完全二叉树，具堆属性的数据结构才可被叫做为堆，堆常见的应用就是堆排序与实现优先队列，为什么用？因为快啊 </p></li><li><p><strong>队列</strong>：就是先进先出的存储方式，类似与超市付款，先买的先走，一般与栈作比较 </p></li><li><p><strong>栈</strong>：与队列相反，栈的顺序是后进先出，只可以在栈顶进行操作，类似与只有一个出入口的公交车，先上车的只能后来下车</p></li></ul><p><strong>速度</strong> </p><p> 队列与栈速度相对来说，队列的更快些，因为设计增加删除的操作时，队列不需要改变数据结构，而栈需要，所以遍历速度略低些，这些数据结构一般跟算法有点关系，其实平时敲代码用不到的好不</p><p>以上就是数据结构中的堆栈，接下来说下内存中的堆和栈</p><h2 id="内存中的堆和栈"><a href="#内存中的堆和栈" class="headerlink" title="内存中的堆和栈"></a><strong>内存中的堆和栈</strong></h2><p>在内存中的堆栈，一般指的是数据操作的存在位置，一般来说，栈是存放一些常量字面量一类的东西，这些一般有系统自己控制空间的开辟与释放，而堆是存放一些实例的变量，程序员需要自己去控制何时在内存中分配空间和何时释放（当然，这个也跟语言有关系，java就由虚拟机自行控制，c++就不行了） </p><p><strong>速度</strong> </p><p>关于速度，查阅资料，栈的存储一般位于一级缓存，堆的存储位于二级缓存，所以栈的速度是远远大于堆的。（关于一级缓存二级缓存的速度差异请看这个：<a href="http://www.to8to.com/yezhu/v9652.html%20%E2%80%9C%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E5%8C%BA%E5%88%AB%E2%80%9D">http://www.to8to.com/yezhu/v9652.html</a>） </p><p><strong>什么是堆栈溢出</strong> </p><p>堆栈溢出就是不顾堆栈中分配的局部数据块大小，向该数据块写入了过多的数据，导致数据越界，结果覆盖了别的数据。意思就是，假如你在内存分配了8大小，而传入的值却大于这个长度，那么多余的长度就可能会覆盖内存中的其他元素，所以会得到错误的返回结果。堆栈溢出一般指的是堆溢出，栈溢出的情况比较少。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 堆栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git本地push代码报broken pipe</title>
      <link href="/2017/03/06/"/>
      <url>/2017/03/06/</url>
      
        <content type="html"><![CDATA[<p>以下基于windows开发环境</p><p>最近在本地写了一点代码，于是就想把它放到Github上去，前面的步骤什么的不多说，就是最后在push代码的时候总是跑出异常 </p><p>诺，就是下面的这个样子的</p><p><img src="http://img.blog.csdn.net/20170306223640001?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzcwNzI0OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>搜索了很多资料，先pull再push，删除远程readme文件，甚至想到用gitosis配置权限（都是些什么鬼，我特么又不是要自己搭服务器……），但是还是没有解决。最后考虑是github配置问题，查阅一些先人的遗迹，终于找到解决办法。perfect</p><p>为了防止以后遇到意想不到的错误，建议小白修改一下配置</p><p><strong>第一，设置长久连接</strong></p><p>在git安装目录下，找到&#x2F;etc&#x2F;ssh&#x2F;ssh_config,然后随便用什么编辑器打开，添加</p><p>不知道怎么写看着配置文件上面的格式来写就行了</p><pre><code>Host *  ServerAliveInterval 120 </code></pre><p>这个配置的作用就是保证ssh ServerAliveInterval始终连接，我这次出现错误的原因就是在无线局域网环境下，ssh连接到远程主机后如果一段时间内不操作，就会出现掉线的情况，所以最后加上此配置项</p><p><strong>第二， 修改post缓存大小</strong> </p><p>因为如果缓存不够用，有时候也会发生broken pipe的情况，所以最好的对post的缓存大小作设置 </p><p>这个很简单，直接在git bash 上输入git config http.postBuffer ，value指的就是设置的缓存大小，如下：</p><pre class="prettyprint">git config <span class="hljs-keyword">http</span>.postBuffer <span class="hljs-number">52428800</span>52428800的单位是字节，git默认的是1MB，我们把它设置成50MB以上，就可以在同性网里开心的玩耍了。* * *<br/>前端新手，弱鸡一枚，如有错误，请指正，谢谢！]]></content>
      
      
      <categories>
          
          <category> Github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> 爬坑之路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[原]教你如何用命令行装逼，做一个有逼格的程序员</title>
      <link href="/2016/10/17/"/>
      <url>/2016/10/17/</url>
      
        <content type="html"><![CDATA[<h2 id="教你如何用命令行装逼，做一个有逼格的程序员"><a href="#教你如何用命令行装逼，做一个有逼格的程序员" class="headerlink" title="教你如何用命令行装逼，做一个有逼格的程序员"></a><strong>教你如何用命令行装逼，做一个有逼格的程序员</strong></h2><p>事先声明，如果你不知道打开windows的命令行工具，我是绝对不会告诉你是用 <strong>windows+R</strong> ，然后键入 <strong>cmd</strong> 打开的</p><p>windows 自带的命令行工具很强大，毕竟计算机一开始都是以键入命令的方式来操作的，但现如今计算机的发展，许多在过去需要去记大量命令才能完成的操作，现如今通过傻瓜式的点选都可以完成。作为一名有逼格的程序员，在计算机如今图形界面点选操作的洪流中漂的越来越远，如何保证程序员识货而不脑残、务实而不闷骚的本性呢，那就不妨用回命令行吧。</p><p>本文将介绍几个关于命令行工具的小技巧，全都是工作之后遇到，看到能装逼，不对，看到对工作有很大的帮助所以就都记下了</p><ul><li><strong>1.外观配置篇</strong></li></ul><p>如果你觉得windows黑底白字的命令行面板很漂亮，对不起，我们分手吧。我相信大部分人不愿意用命令行的原因就是他实在是太丑了，所以，第一步，我们需要把命令行配置的好看舒服一些，虽然肯定比不上<strong>sublime</strong>、<strong>atom</strong>那种神级的编辑界面，但也不能比<strong>notePad</strong>差太多吧，好了我自己配置的界面大致就是下面这个样子吧 </p><p><img src="http://img.blog.csdn.net/20161017131431540" alt="图1"></p><p>其实也就是换成了看起来更舒服的白底黑字，改成了我自己更喜欢的新宋体字体。而你所需要做的就是，右键标题选择属性打开，你看到就是这个样子的了 </p><p><img src="http://img.blog.csdn.net/20161017131721718" alt="图2"></p><p>配置是相当简单的，具体看个人喜欢，具体就不多谈了，但是有两个需要get的点是： </p><p> 如果你受够了命令窗口写着写着就看不到之前的了，那么你需要做的是设置缓冲大小，对于我，200 OK;另外一个是记得打开快速编辑功能，为什么要打开这个，后边再说 </p><p><img src="http://img.blog.csdn.net/20161017131903547" alt="图3"></p><p>做到这儿，就差不多了，但还是差点，对于自己的命令窗口怎么可以用文件目录这么low的标识，当然要有自己的个性,键入命令 title + ‘名字’，剩下的就自己体会去吧 </p><p><em>ps：其实网上还有一些美化命令窗口的工具，比如类似雪豹的透明风格，可以自行钻研</em></p><ul><li><strong>2.能不能快点敲命令篇</strong></li></ul><p>命令行另外一个让人抓狂的地方是它对于复制粘贴偏执的理解，曾经的我深受其害，在我还是个菜鸟的时候，为了达到复制粘贴的效果，我需要右键标记，然后复制，粘贴的时候还要记得右键粘贴，你一直喜欢的 ctrl+V 是不可以的，实在让人抓狂。但现在不一样了，你一定见过别人操作命令工具可以有这样的界面  </p><p><img src="http://img.blog.csdn.net/20161017132157626" alt="图4"></p><p>或许见过大神不用键盘，只点一下鼠标就可以复制大段的命令。这些都是因为其实windows已经提供了一些可以快速编辑命令的小技能，我知道你已经想要听了。</p><p>还记得刚刚说过的打开快速编辑的选项吗？你只有打开了勾选了这个选项，你才真正的解放了命令窗口。如果你想复制一段命令，多行的也OK，你所需要做的就是选中你要复制的命令，然后单击右键，命令就已经被复制在剪贴板上了，如果你想粘贴命令，更简单，选择要插入的位置，右键单击，然后你会发现命令已经被复制上了。</p><p>当然这都是初级的，你还可以通过以下的方式来操作</p><ul><li><strong>F3 快速复制上一次的命令</strong><br><em>按下F3，你可以快速复制上一次执行的命令，你同样的可以通过键入上下键来快速选择命令（反正我觉得还没有用上下键方便）</em></li><li><strong>F1 复制上一次命令，但是一个字符一个字符的复制</strong><br><em>按下F3只能复制一行是不是有点坑，如果你想要一个字符一个字符的复制，那么你的做法就是不停的按F1就行了</em></li><li><strong>F2 输入一个字符，然后复制这个字符之前的命令</strong><br><em>*假如你上一个命令是 ‘net help’ ,按下F2，然后键入 h，你会发现net 已经被复制好了，是不是66的感觉</em></li><li><strong>F7 显示所有使用过的命令，按上上下下，BABA可以选择</strong><br><em>这一次，你所用过的命令都会显示出来，你可以上下左右前前后后进行选择，再也没有比这更直观的方式了</em></li><li><strong>Tab 快速补全存在的文件目录名</strong><br><em>虽然不是特别强大，但是用起Tab键补全的感觉是不是有种敲代码的feeling</em></li></ul><p>知道这五个按键命令，差不多就够了，想当初我也是靠这5个命令，从一个菜鸟变成了现如今的更菜的菜鸟</p><ul><li><strong>3.终极命令</strong></li></ul><p>说好了是做有逼格的程序员呢，怎么说的全是跟程序没多大关系的东西。当然喽，我今天压根没想说一些类似 ‘mkdir’ ‘cd xxoo’之类的命令，这种类似的命令你只有自己去搜索然后自己去敲才会发现它的好玩儿。而我想说的是，对于windows来说，命令好玩的地方真的需要你自己去摸索，如果你是地球上最大的同性恋交友网站git上的一员，如果你是node的忠粉，那么我想你一定要学会玩儿命令行工具。同样的对于电脑小白来说，学会一些‘高大上’的命令操作，同样会让你逼格满满</p><blockquote><p><strong>伟大的程序员布什.沃硕德曾说过：程序员最伟大的地方不是创造，而是一份想要不断摸索的偏执</strong></p></blockquote><p>拜了个拜（下次有空玩win10）</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> 命令行 </tag>
            
            <tag> 装逼必备 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[原]如何用 html+css 实现平行四边形，以及气泡框呢？</title>
      <link href="/2016/08/02/"/>
      <url>/2016/08/02/</url>
      
        <content type="html"><![CDATA[<p><strong>【效果图】</strong> </p><p>首先说一下平行四边形，想要做成的效果大致是下面这个样子的 </p><p><img src="http://img.blog.csdn.net/20160801103810284" alt="这里写图片描述"></p><p><strong>【思路】</strong> </p><p>如果考虑用昨天的方法，利用 border 边界值，就可以分解成 一个右三角+矩形+上三角（这里右，上的意思指的是需要加上颜色显示的边界颜色），但这样就挺复杂了，所以要换一种方法来做</p><p><strong>【做法】</strong> </p><p>其实利用上次说的 css3 的属性 transform 属性来设置</p><pre class="prettyprint"><span class="hljs-rules">{    <span class="hljs-rule"><span class="hljs-attribute">display</span>:<span class="hljs-value"> inline-block</span></span>;    <span class="hljs-rule"><span class="hljs-attribute">padding</span>:<span class="hljs-value"> <span class="hljs-number">5</span>px <span class="hljs-number">20</span>px</span></span>;    <span class="hljs-rule"><span class="hljs-attribute">border</span>:<span class="hljs-value"> <span class="hljs-number">1</span>px solid <span class="hljs-hexcolor">#44a5fc</span></span></span>;    <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value"> <span class="hljs-hexcolor">#333</span></span></span>;    <span class="hljs-rule"><span class="hljs-attribute">transform</span>:<span class="hljs-value"> <span class="hljs-function">skew(-<span class="hljs-number">20</span>deg)</span></span></span>; <span class="hljs-comment">/* 定义沿着 X 和 Y 轴的 2D 倾斜转换*/</span><span class="hljs-rule">}</span></span></pre><p><strong>【注意】</strong> </p><p>但是这么做，有个注意的地方就是，如果当前盒子里包裹其他内容，这个其他内容也会跟着旋转，所以为了避免这种效果，需要在内部重新加一个盒子，并对这个盒子进行一个逆向的 transform，这样就实现了平行四边形了，也就是一个属性的事情  </p><p><strong>【思考】</strong> </p><p>要是个梯形，该怎么做呢？</p><p>接下来再说一下怎么制作一个类似 tooltip 的气泡提示框呢？ </p><p><strong>【效果图】</strong> </p><p>先看一下大致的效果 </p><p><img src="http://img.blog.csdn.net/20160801104015487" alt="这里写图片描述"> </p><p><strong>【思路】</strong> </p><p>其实做起来也相当的简单，就是用一个盒子加一个三角形就行，然后控制好定位的问题就可以做到</p><p><strong>【做法】</strong> </p><p>在有一个叫做 rectangle 的盒子，然后在这个盒子里面有一个 trangle 的盒子</p><pre class="prettyprint"><span class="hljs-class">.rectangle</span><span class="hljs-rules">{    <span class="hljs-rule"><span class="hljs-attribute">position</span>:<span class="hljs-value">relative</span></span>;    <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"><span class="hljs-number">150</span>px</span></span>;    <span class="hljs-rule"><span class="hljs-attribute">height</span>:<span class="hljs-value"><span class="hljs-number">35</span>px</span></span>;    <span class="hljs-rule"><span class="hljs-attribute">background</span>:<span class="hljs-value">green</span></span>;    <span class="hljs-rule"><span class="hljs-attribute">border-radius</span>:<span class="hljs-value"><span class="hljs-number">5</span>px</span></span>;    <span class="hljs-rule"><span class="hljs-attribute">margin</span>:<span class="hljs-value"><span class="hljs-number">30</span>px auto <span class="hljs-number">0</span></span></span>;    <span class="hljs-rule"><span class="hljs-attribute">padding</span>:<span class="hljs-value"> <span class="hljs-number">10</span>px</span></span>;    <span class="hljs-rule"><span class="hljs-attribute">color</span>:<span class="hljs-value">white</span></span>; <span class="hljs-rule">}</span></span><span class="hljs-class">.rectangle</span> <span class="hljs-class">.trangle</span><span class="hljs-rules">{    <span class="hljs-rule"><span class="hljs-attribute">position</span>:<span class="hljs-value">absolute</span></span>;    <span class="hljs-rule"><span class="hljs-attribute">top</span>:<span class="hljs-value"><span class="hljs-number">12</span>px</span></span>;    <span class="hljs-rule"><span class="hljs-attribute">right</span>:<span class="hljs-value">-<span class="hljs-number">16</span>px</span></span>;    <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"><span class="hljs-number">0</span></span></span>;    <span class="hljs-rule"><span class="hljs-attribute">height</span>:<span class="hljs-value"><span class="hljs-number">0</span></span></span>;    <span class="hljs-rule"><span class="hljs-attribute">font-size</span>:<span class="hljs-value"><span class="hljs-number">0</span></span></span>;    <span class="hljs-rule"><span class="hljs-attribute">border</span>:<span class="hljs-value">solid <span class="hljs-number">8</span>px</span></span>;    <span class="hljs-rule"><span class="hljs-attribute">border-color</span>:<span class="hljs-value">transparent transparent transparent green</span></span>;<span class="hljs-rule">}</span></span>然后差不多就可以实现了 **【注意】** 有一个注意的地方就是 position 的使用，在外部盒子的是一定要使用相对定位的 **【思考】** 需要做一个不规则的小三角呢？（其实应该是类似的，就是用不同类型的三角形层层的遮罩，或者利用 css3 的2D变换属性来实现）]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重新认识 MVC 和 三层设计模式</title>
      <link href="/2016/08/01/"/>
      <url>/2016/08/01/</url>
      
        <content type="html"><![CDATA[<h1 id="重新认识-MVC-和-三层设计模式"><a href="#重新认识-MVC-和-三层设计模式" class="headerlink" title="重新认识 MVC 和 三层设计模式"></a>重新认识 MVC 和 三层设计模式</h1><p>首先不得不承认，身边有一群8年+工作经验的大牛就是爽，纠正了我一个认知上的错误</p><p>首先来看一下官方的解释：</p><blockquote><p><strong>MVC</strong>： </p><p>  MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。 </p><p>  <img src="http://img.blog.csdn.net/20160801101537117" alt="MVC图"> </p><p>  <strong>三层架构设计模式</strong>： </p><ul><li>表现层（UI）：通俗讲就是展现给用户的界面，即用户在使用一个系统的时候他的所见所得。</li><li>业务逻辑层（BLL）：针对具体问题的操作，也可以说是对数据层的操作，对数据业务逻辑处理。</li><li>数据访问层（DAL）：该层所做事务直接操作数据库，针对数据的增添、删除、修改、更新、查找等。</li></ul></blockquote><p>我想说的是，因为老师夜以继日对我讲，MVC三层模式，从而导致我将这两个东西搞混了。所以现在我来重新理解下。</p><p>简单的说： </p><ul><li><p>MVC 是应用在三层架构模式中表现层里面的一种软件设计规范，它只存在于表现层，它不是一种架构设计规范！在表现层的设计还有 MVVM，MVP等，在这里的model，应该理解为viewModel,view就是web界面，controller则是页面请求的逻辑处理</p></li><li><p>三层架构设计是一种架构设计方案，相对来说理解起来比较简单，但需要注意的是，实体模型并不能算作是一个层</p></li></ul><p>具体的理解画一个图吧</p><p><img src="http://img.blog.csdn.net/20160801101043248" alt="MVC 三层模式图解"></p><p>然后稍微的说一下MVVM和MVP</p><ul><li><p>MVVM： 主要用来做 WPF</p></li><li><p>MVP：   MVP和MVC很像，但是有点区别。在MVP中View并不直接使用Model，它们之间的通信是通过Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部，而在MVC中View会直接从Model中读取数据而不是通过 Controller。</p></li><li><p>MVC: 在MVC里，View是可以直接访问Model的！从而，View里会包含Model信息，不可避免的还要包括一些业务逻辑。 在MVC模型里，更关注的Model的不变，而同时有多个对Model的不同显示，即View。所以，在MVC模型里，Model不依赖于View，但是View是依赖于Model的。不仅如此，因为有一些业务逻辑在View里实现了，导致要更改View也是比较困难的，至少那些业务逻辑是无法重用的。</p></li></ul><p>其实今天还学了下 依赖注入的一些东西，很深奥，有空再说吧！</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构设计 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
