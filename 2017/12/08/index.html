<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>关于JS事件队列的一些总结 | 程鹏飞的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="关于JS事件队列的一些总结关于任务队列其实之所以我们要去关心JS的任务队列，主要还是因为JS的单线程的特质决定。 为什么JavaScript是单线程？本段来自阮老师的博客中对JS单线程的介绍。  JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。 JavaScript的单线程，与它的用途有关。作为浏览">
<meta property="og:type" content="article">
<meta property="og:title" content="关于JS事件队列的一些总结">
<meta property="og:url" content="https://michaelooo.github.io/2017/12/08/index.html">
<meta property="og:site_name" content="程鹏飞的博客">
<meta property="og:description" content="关于JS事件队列的一些总结关于任务队列其实之所以我们要去关心JS的任务队列，主要还是因为JS的单线程的特质决定。 为什么JavaScript是单线程？本段来自阮老师的博客中对JS单线程的介绍。  JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。 JavaScript的单线程，与它的用途有关。作为浏览">
<meta property="og:locale" content="zh_ZN">
<meta property="article:published_time" content="2017-12-08T15:37:00.000Z">
<meta property="article:modified_time" content="2023-03-01T10:50:12.644Z">
<meta property="article:author" content="Michael Cheng">
<meta property="article:tag" content="javascript">
<meta property="article:tag" content="JS事件队列">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="https://ws1.sinaimg.cn/large/86c7c947gy1g4sl65dqrtj20b40b478p.jpg">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap"><form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://michaelooo.github.io"></form></div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
        <a class="main-nav-link" href="/">首页</a>
        
        <a class="main-nav-link" href="/archives">归档</a>
        
        <a class="main-nav-link" href="/resume/">关于</a>
        
      </nav>
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">程鹏飞的博客</a>
      </h1>
      
    </div>
  </div>
  <!-- <script src="https://releases.leanapp.cn/leancloud/javascript-sdk/releases/download/v3.5.0/av-min.js"></script> -->
</header>

      <div class="outer">
        <section id="main"><article id="post-关于JS事件队列的一些总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/08/" class="article-date">
  <time datetime="2017-12-08T15:37:00.000Z" itemprop="datePublished">2017-12-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      关于JS事件队列的一些总结
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="关于JS事件队列的一些总结"><a href="#关于JS事件队列的一些总结" class="headerlink" title="关于JS事件队列的一些总结"></a><strong>关于JS事件队列的一些总结</strong></h1><h2 id="关于任务队列"><a href="#关于任务队列" class="headerlink" title="关于任务队列"></a><strong>关于任务队列</strong></h2><p>其实之所以我们要去关心JS的任务队列，主要还是因为JS的单线程的特质决定。</p>
<h3 id="为什么JavaScript是单线程？"><a href="#为什么JavaScript是单线程？" class="headerlink" title="为什么JavaScript是单线程？"></a><strong>为什么JavaScript是单线程？</strong></h3><p>本段来自阮老师的博客中对JS单线程的介绍。</p>
<blockquote>
<p>JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。</p>
<p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p>
<p>所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p>
<p>为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。</p>
</blockquote>
<h3 id="任务队列的本质"><a href="#任务队列的本质" class="headerlink" title="任务队列的本质"></a><strong>任务队列的本质</strong></h3><ul>
<li>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</li>
<li>主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</li>
<li>一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li>
<li>主线程不断重复上面的第三步。</li>
</ul>
<h2 id="关于-setTimeOut、setImmediate、process-nextTick-的比较"><a href="#关于-setTimeOut、setImmediate、process-nextTick-的比较" class="headerlink" title="关于 setTimeOut、setImmediate、process.nextTick()的比较"></a><strong>关于 setTimeOut、setImmediate、process.nextTick()的比较</strong></h2><h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout()"></a><strong>setTimeout()</strong></h3><ul>
<li>将事件插入到了事件队列，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。</li>
<li>当主线程时间执行过长，无法保证回调会在事件指定的时间执行。</li>
<li>浏览器端每次<code>setTimeout </code>会有4ms的延迟，当连续执行多个<code>setTimeout </code>，有可能会阻塞进程，造成性能问题。</li>
</ul>
<h3 id="setImmediate"><a href="#setImmediate" class="headerlink" title="setImmediate()"></a><strong>setImmediate()</strong></h3><ul>
<li>事件插入到事件队列尾部，主线程和事件队列的函数执行完成之后立即执行。和setTimeout(fn,0)的效果差不多。</li>
<li>服务端node提供的方法。浏览器端最新的api也有类似实现:<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setImmediate">window.setImmediate</a>,但支持的浏览器很少。</li>
</ul>
<h3 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a><strong>process.nextTick()</strong></h3><ul>
<li>插入到事件队列尾部，但在下次事件队列之前会执行。也就是说，它指定的任务总是发生在所有异步任务之前，当前主线程的末尾。</li>
<li>大致流程：当前”执行栈”的尾部–&gt;下一次Event Loop（主线程读取”任务队列”）之前–&gt;触发process指定的回调函数。</li>
<li>服务器端node提供的办法。用此方法可以用于处于异步延迟的问题。</li>
<li>可以理解为：此次不行，预约下次优先执行。</li>
</ul>
<h2 id="关于消除-setTimeout-延迟的实践：soon-js"><a href="#关于消除-setTimeout-延迟的实践：soon-js" class="headerlink" title="关于消除 setTimeout 延迟的实践：soon.js"></a><strong>关于消除 setTimeout 延迟的实践：soon.js</strong></h2><h3 id="why"><a href="#why" class="headerlink" title="why?"></a><strong>why?</strong></h3><p>如<code>setTimeout</code> 的介绍所言，浏览器端每次<code>setTimeout </code>会有4ms的延迟，当连续执行多个<code>setTimeout </code>，有可能会阻塞进程，造成性能问题。</p>
<p><code>soon.js</code>就是关于这个问题的一个好的实践。但其实大多数情况我们不必为这4ms的延迟计较，除非你在一次执行中<code>setTimeout</code>的次数足够多。代码很短，可以用来学习下。</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h3><p>可以参考<a target="_blank" rel="noopener" href="https://jsfiddle.net/0tscgwe6/2/">示例</a></p>
<h3 id="源码："><a href="#源码：" class="headerlink" title="源码："></a><strong>源码：</strong></h3><pre><code>// See http://www.bluejava.com/4NS/Speed-up-your-Websites-with-a-Faster-setTimeout-using-soon
// 使用 soon.js 处理在浏览器端 settimeout（大量调用），4ms * n 的延迟问题


var soon = (function() &#123;
    
        var fq = []; // 事件队列;
    
        function callQueue()
        &#123;
            while(fq.length) // 执行队列中事件
            &#123;
                var fe = fq[0];
                fe.f.apply(fe.m,fe.a) // 执行队列中事件
                fq.shift(); 
            &#125;
        &#125;
    
        // 异步执行队列事件，最大效率
        var cqYield = (function() &#123;
    
                // 通过 MutationObserver 来监听 Dom 来执行回调，此法最快
                if(typeof MutationObserver !== &quot;undefined&quot;)
                &#123;
                    var dd = document.createElement(&quot;div&quot;);
                    var mo = new MutationObserver(callQueue);
                    mo.observe(dd, &#123; attributes: true &#125;);
    
                    return function(fn) &#123; dd.setAttribute(&quot;a&quot;,0); &#125; // trigger callback to
                &#125;
    
                // 如果支持 setImmediate ，采取此策略，其实 setImmediate 和 setTimeout(callQueue,0) 差不多
                if(typeof setImmediate !== &quot;undefined&quot;)
                    return function() &#123; setImmediate(callQueue) &#125;
    
                // 没办法了，就用 setTimeOut 的办法
                return function() &#123; setTimeout(callQueue,0) &#125;
            &#125;)();
    
        return function(fn) &#123;
                // 队列事件装载进一个数组
                fq.push(&#123;f:fn,a:[].slice.apply(arguments).splice(1),m:this&#125;);
    
                if(fq.length == 1) // 在添加第一个条目时，启动回调函数
                    cqYield();
            &#125;;
    
    &#125;)();
</code></pre>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a><strong>分析</strong></h3><p>其实，值得分析就是一个新的东西–<code>MutationObserver</code>。</p>
<p><code>MutationObserver</code>给开发者们提供了一种能在某个范围内的DOM树发生变化时作出适当反应的能力.该API设计用来替换掉在DOM3事件规范中引入的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/DOM/Mutation_events">Mutation</a>事件.</p>
<p>简而言之，就是这个东西比<code>setTimeOut</code>，<code>setImmediate</code>快，浏览器支持就用它就行了。</p>
<p>关于<code>soon.js</code>的更详细的介绍可以查看这篇文章。<a target="_blank" rel="noopener" href="http://www.bluejava.com/4NS/Speed-up-your-Websites-with-a-Faster-setTimeout-using-soon">Speed up your Websites with a Faster setTimeout using soon()</a></p>
<p><code>MutationObserver</code>给开发者们提供了一种能在某个范围内的DOM树发生变化时作出适当反应的能力.该API设计用来替换掉在DOM3事件规范中引入的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/DOM/Mutation_events">Mutation</a>事件.</p>
<h2 id="参考博客："><a href="#参考博客：" class="headerlink" title="参考博客："></a><strong>参考博客：</strong></h2><ul>
<li><p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/cdwp8/p/4065846.html">setTimeout和setImmediate以及process.nextTick的区别</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html">JavaScript 运行机制详解：再谈Event Loop</a></p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://michaelooo.github.io/2017/12/08/" data-id="clepk3zus0018gtnd24mzcnfd" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97/" rel="tag">JS事件队列</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li></ul>

    </footer>
  </div>
  
    
 
<script src="/jquery/jquery.min.js"></script>

  <div id="random_posts">
    <h2>推荐文章</h2>
    <div class="random_posts_ul">
      <script>
          var random_count =4
          var site = {BASE_URI:'/'};
          function load_random_posts(obj) {
              var arr=site.posts;
              if (!obj) return;
              // var count = $(obj).attr('data-count') || 6;
              for (var i, tmp, n = arr.length; n; i = Math.floor(Math.random() * n), tmp = arr[--n], arr[n] = arr[i], arr[i] = tmp);
              arr = arr.slice(0, random_count);
              var html = '<ul>';
            
              for(var j=0;j<arr.length;j++){
                var item=arr[j];
                html += '<li><strong>' + 
                item.date + ':&nbsp;&nbsp;<a href="' + (site.BASE_URI+item.uri) + '">' + 
                (item.title || item.uri) + '</a></strong>';
                if(item.excerpt){
                  html +='<div class="post-excerpt">'+item.excerpt+'</div>';
                }
                html +='</li>';
                
              }
              $(obj).html(html + '</ul>');
          }
          $('.random_posts_ul').each(function () {
              var c = this;
              if (!site.posts || !site.posts.length){
                  $.getJSON(site.BASE_URI + 'js/posts.js',function(json){site.posts = json;load_random_posts(c)});
              } 
               else{
                load_random_posts(c);
              }
          });
      </script>
    </div>
  </div>

    
<nav id="article-nav">
  
    <a href="/2017/12/09/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          大神的自我修养 co.js 的学习
        
      </div>
    </a>
  
  
    <a href="/2017/12/07/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">轮子：一个简单的node爬虫踩坑之路</div>
    </a>
  
</nav>

  
</article>
 
     
<div class="comments" id="comments">
      
</div>


  

</section>
           
    <aside id="sidebar">
  
    

  
    
    <div class="widget-wrap">
    
      <div class="widget" id="toc-widget-fixed">
      
        <strong class="toc-title">文章目录</strong>
        <div class="toc-widget-list">
              <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B3%E4%BA%8EJS%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93"><span class="toc-number">1.</span> <span class="toc-text">关于JS事件队列的一些总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97"><span class="toc-number">1.1.</span> <span class="toc-text">关于任务队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88JavaScript%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.1.1.</span> <span class="toc-text">为什么JavaScript是单线程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">1.1.2.</span> <span class="toc-text">任务队列的本质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-setTimeOut%E3%80%81setImmediate%E3%80%81process-nextTick-%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.2.</span> <span class="toc-text">关于 setTimeOut、setImmediate、process.nextTick()的比较</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#setTimeout"><span class="toc-number">1.2.1.</span> <span class="toc-text">setTimeout()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setImmediate"><span class="toc-number">1.2.2.</span> <span class="toc-text">setImmediate()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#process-nextTick"><span class="toc-number">1.2.3.</span> <span class="toc-text">process.nextTick()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%B6%88%E9%99%A4-setTimeout-%E5%BB%B6%E8%BF%9F%E7%9A%84%E5%AE%9E%E8%B7%B5%EF%BC%9Asoon-js"><span class="toc-number">1.3.</span> <span class="toc-text">关于消除 setTimeout 延迟的实践：soon.js</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#why"><span class="toc-number">1.3.1.</span> <span class="toc-text">why?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.2.</span> <span class="toc-text">使用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%EF%BC%9A"><span class="toc-number">1.3.3.</span> <span class="toc-text">源码：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-number">1.3.4.</span> <span class="toc-text">分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E5%8D%9A%E5%AE%A2%EF%BC%9A"><span class="toc-number">1.4.</span> <span class="toc-text">参考博客：</span></a></li></ol></li></ol>
          </div>
      </div>
    </div>

  
    

  
    
  
    
  
    

  
    
  
    <!--微信公众号二维码-->


  
    <!-- 去掉浏览量统计 -->
<!-- 
    <div class="widget-wrap">
    <h3 class="widget-title">浏览数目</h3>
    <div class="widget">
      <ul class="popularlist">
      </ul>
    </div>
  </div>
 -->
  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2023 Michael Cheng&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
      <a target="_blank" href="http://www.beian.miit.gov.cn/" style="display:inline-block;text-decoration:none;height:20px;line-height:20px;margin-left: 10px;">
          <img style="float: left; width: 20px;" src="//img.alicdn.com/tfs/TB1..50QpXXXXX7XpXXXXXXXXXX-40-40.png">
          <span style="float:left;height:20px;line-height:20px;margin: 0px 0px 0px 5px; color:#939393;">粤ICP备17162335号</span>
      </a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;422208170@qq.com
    </div>
  </div>
</footer>
 
<script src="/jquery/jquery.min.js"></script>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/resume/" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="https://t1.picb.cc/uploads/2021/05/04/ZEnbna.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
     
<script src="/js/is.js"></script>



  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/elevator.js"></script>


<script src="/js/fundebug.1.9.0.min.js"></script>


<!--page counter part-->
<script>
  function addCount (Counter) {
    var curpage_count; 
    url=$('.article-date').attr('href').trim();
    title = $('.article-title').text().trim();
    var query=new AV.Query(Counter);
    //use url as unique idnetfication
    query.equalTo("url",url);
    query.find().then(function(results){
      if(results.length>0) {
          var counter=results[0];
          counter.fetchWhenSave(true); //get recent result
          counter.increment("time");
          counter.save();
          curpage_count = counter.attributes.time + 1;
          $('.article-inner').append('<p style="color:#999;margin-left:20px">（本文已被访问'+curpage_count+'次）</p>');
      } else {
        var newcounter=new Counter();
        newcounter.set("title",title);
        newcounter.set("url",url);
        newcounter.set("time",1);
        newcounter.save(null,{
            success: function(newcounter){
            //alert('New object created');
            },
            error: function(newcounter,error){
            alert('Failed to create');
            }
            });
        curpage_count = 1;
        $('.article-inner').append('<p style="color:#999;margin-left:20px">（本文已被访问'+curpage_count+'次）</p>');
      }
    },function(error){
        //find null is not a error
        alert('Error:'+error.code+" "+error.message);
    });
  }

  $(function(){
      // fundebug INIT
      fundebug.apikey = '311c1dc8f056512d95a8a459b5d14892078dc69e4686b5f704142485c2c04620';

      // init
      var APP_ID = 'P8zI4n1RVVKeFqFoDDcJXtxB-gzGzoHsz';
      var APP_KEY = 'XygRBwRtUGj8XJLClnpGKXQQ';

      AV.init({
        appId: APP_ID,
        appKey: APP_KEY
      });

      var Counter=AV.Object.extend("Counter");
      //only increse visit counting when intering a page
      if ($('.article-title').length == 1)
        addCount(Counter);
      var query=new AV.Query(Counter);
      query.descending("time");
      // the sum of popular posts
      query.limit(10); 
      query.find()
      .then(
        function(results){
          for(var i=0;i<results.length;i++)    
            {
                var counter=results[i];
                title=counter.get("title");
                url=counter.get("url");
                time=counter.get("time");
                // add to the popularlist widget
                showcontent=title+" ("+time+")";
                //notice the "" in href
                $('.popularlist').append('<li><a href="'+url+'">'+showcontent+'</a></li>');
            }
          },
          function(error){
            alert("Error:"+error.code+" "+error.message);
          });
  });
</script>

  </div>
</body>
</html>