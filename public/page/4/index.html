<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>程鹏飞的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="欢迎来到程鹏飞的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="程鹏飞的博客">
<meta property="og:url" content="https://michaelooo.github.io/page/4/index.html">
<meta property="og:site_name" content="程鹏飞的博客">
<meta property="og:description" content="欢迎来到程鹏飞的博客">
<meta property="og:locale" content="zh_ZN">
<meta property="article:author" content="Michael Cheng">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="https://ws1.sinaimg.cn/large/86c7c947gy1g4sl65dqrtj20b40b478p.jpg">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap"><form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://michaelooo.github.io"></form></div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
        <a class="main-nav-link" href="/">首页</a>
        
        <a class="main-nav-link" href="/archives">归档</a>
        
        <a class="main-nav-link" href="/resume/">关于</a>
        
      </nav>
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">程鹏飞的博客</a>
      </h1>
      
    </div>
  </div>
  <!-- <script src="https://releases.leanapp.cn/leancloud/javascript-sdk/releases/download/v3.5.0/av-min.js"></script> -->
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-win10下的装逼利器，让你的win10更好用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/24/" class="article-date">
  <time datetime="2017-05-24T10:38:44.000Z" itemprop="datePublished">2017-05-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9D%82%E8%B0%88/">杂谈</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/24/">win10下的装逼利器，让你的win10更好用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>这是一篇非技术性博客，是帮住你更好使用win10的辅助软件，亲测十分好用，既能提升效率，又能狠狠地装逼。 </p>
<p>以下软件都是我正在使用的，后面有新发现的话会继续更新</p>
<h2 id="rolan2"><a href="#rolan2" class="headerlink" title="rolan2"></a><strong>rolan2</strong></h2><p>rolan2 是一个很不错的桌面管理工具，了解桌面管理工具的肯定都有用过大名鼎鼎的fences,win7下用fences的确不错，整体UI是很搭的，但是win10用fences效果不好，所以选择用了rolan2,风格很贴近win10，可以自定义分组，并且可以快捷键显示隐藏，非常酷炫。不多说，直接上图</p>
<p><img src="http://img.blog.csdn.net/20170524101005904?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzcwNzI0OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>右上角那个嘿嘿嘿的方块就是rolan2,风格怎样完全可以自定制，另外还有一个小技巧就是，默认的快捷键 ALT + TAB 键控制显示界面隐藏，到时候整个桌面只剩下你的壁纸，即是十分清爽，好看又装逼，实乃居家常备、装逼之利器。</p>
<p>官网下载地址：<a href="https://www.irolan.com/" target="_blank" rel="noopener">https://www.irolan.com/</a> 测试版即可，会提示你升级</p>
<h2 id="QTtab"><a href="#QTtab" class="headerlink" title="QTtab"></a><strong>QTtab</strong></h2><p>我是经常需要操作多个文件夹的，但是文件夹打开的多了就需要不停的切换，贼烦，这时候就希望如果能够像操作浏览器窗口一样操作文件窗口那就好了，QTtab就是这样的一个工具。上图</p>
<p><img src="http://img.blog.csdn.net/20170524102400506?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzcwNzI0OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>使用QTab你只需要将你想要看的文件夹拖动到导航栏，或者是按下鼠标滚轮键将选中的文件夹自动添加到导航栏，具体可以自己配置。 </p>
<p>日常使用起来真的是非常实用的一个软件，另外更重要的是软件的体积很小，1M不到，意不意外，惊不惊喜</p>
<p>官网下载地址：<a href="http://qttabbar.wikidot.com/" target="_blank" rel="noopener">http://qttabbar.wikidot.com/</a></p>
<h2 id="StarlsBack"><a href="#StarlsBack" class="headerlink" title="StarlsBack"></a><strong>StarlsBack</strong></h2><p>这个软件真的是业界良心，win10软件的必备好不。 </p>
<p>首先，win10的启动菜单真的很难用，虽然有个小娜娜可以搜索，但是我还是不太喜欢。那就只好找工具了。喏，就是下面这个</p>
<p><img src="http://img.blog.csdn.net/20170524103226897?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzcwNzI0OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>请忽略掉那手残的马赛克，博主手残</p>
<p><img src="http://img.blog.csdn.net/20170524103010722?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzcwNzI0OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>StarlsBack可以让你自定制你的启动菜单主题，比如我自己就用的win10的图标 + win8的列表风格，然后透明任务栏，贼酷炫，当然还有其他关于任务栏的优化，都可以自己去定制。另外，还有一个彩蛋是如果你想看一下原版的启动主题，按Ctrl + windows 就可以做到，是不是很棒。</p>
<p>官网下载地址：<a href="http://www.startisback.com/" target="_blank" rel="noopener">http://www.startisback.com/</a></p>
<hr>
<p><br>前端新手，弱鸡一枚，如有错误，请指正，谢谢！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://michaelooo.github.io/2017/05/24/" data-id="clepflm6z0016fbmnwuxi2ee9" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/win10/" rel="tag">win10</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B0%8F%E6%8A%80%E8%83%BD/" rel="tag">小技能</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-windows常用cmd命令大全" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/08/" class="article-date">
  <time datetime="2017-05-08T11:48:53.000Z" itemprop="datePublished">2017-05-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9D%82%E8%B0%88/">杂谈</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/08/">windows常用cmd命令大全</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="windows常用cmd命令大全"><a href="#windows常用cmd命令大全" class="headerlink" title="windows常用cmd命令大全"></a><strong>windows常用cmd命令大全</strong></h2><p>收集而来的常用CMD命令</p>
<p><strong>实用操作类</strong></p>
<p><span class="hljs-comment">1</span><span class="hljs-string">.</span> <span class="hljs-comment">Nslookup</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">IP地址侦测器</span><br><span class="hljs-comment">2</span><span class="hljs-string">.</span> <span class="hljs-comment">explorer</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">打开资源治理器</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">不推荐，还不如用Windows</span> <span class="hljs-literal">+</span> <span class="hljs-comment">E打开方便</span><br><span class="hljs-comment">3</span><span class="hljs-string">.</span> <span class="hljs-comment">winver</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">检查Windows版本</span><br><span class="hljs-comment">4</span><span class="hljs-string">.</span> <span class="hljs-comment">regsvr32</span> <span class="hljs-comment">/u</span> <span class="hljs-comment">*</span><span class="hljs-string">.</span><span class="hljs-comment">dll</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">停止dll文件运行</span><br><span class="hljs-comment">5</span><span class="hljs-string">.</span> <span class="hljs-comment">mstsc</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">远程桌面连接</span><br><span class="hljs-comment">6</span><span class="hljs-string">.</span> <span class="hljs-comment">shrpubw</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">创建共享文件夹</span><br><span class="hljs-comment">7</span><span class="hljs-string">.</span> <span class="hljs-comment">regsvr32</span> <span class="hljs-comment">/u</span> <span class="hljs-comment">zipfldr</span><span class="hljs-string">.</span><span class="hljs-comment">dll</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">取消ZIP支持</span><br><span class="hljs-comment">8</span><span class="hljs-string">.</span> <span class="hljs-comment">services</span><span class="hljs-string">.</span><span class="hljs-comment">msc</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">本地服务设置</span><br><span class="hljs-comment">9</span><span class="hljs-string">.</span> <span class="hljs-comment">fsmgmt</span><span class="hljs-string">.</span><span class="hljs-comment">msc</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">共享文件夹治理器</span><br><span class="hljs-comment">10</span><span class="hljs-string">.</span> <span class="hljs-comment">regedit</span><span class="hljs-string">.</span><span class="hljs-comment">exe</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">注册表</span><br><span class="hljs-comment">11</span><span class="hljs-string">.</span> <span class="hljs-comment">regedt32</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">注册表编辑器</span></p>
<p><strong>系统工具类</strong></p>
<p><span class="hljs-number">1.</span> sndrec32<span class="hljs-comment">——-录音机</span><br><span class="hljs-number">2.</span> notepad<span class="hljs-comment">——–打开记事本</span><br><span class="hljs-number">3.</span> dvdplay<span class="hljs-comment">——–DVD播放器</span><br><span class="hljs-number">4.</span> calc<span class="hljs-comment">———–启动计算器</span><br><span class="hljs-number">5.</span> drwtsn32<span class="hljs-comment">—— 系统医生</span><br><span class="hljs-number">6.</span> mem.exe<span class="hljs-comment">——–显示内存使用情况</span><br><span class="hljs-number">7.</span> <span class="hljs-built_in">write</span><span class="hljs-comment">———-写字板</span><br><span class="hljs-number">8.</span> mplayer2<span class="hljs-comment">——-简易widnows media player</span><br><span class="hljs-number">9.</span> wiaacmgr<span class="hljs-comment">——-扫描仪和照相机向导</span><br><span class="hljs-number">10.</span> mspaint<span class="hljs-comment">——–画图板</span><br><span class="hljs-number">11.</span> magnify<span class="hljs-comment">——–放大镜实用程序</span><br><span class="hljs-number">12.</span> dfrg.msc<span class="hljs-comment">——-磁盘碎片整理程序</span><br><span class="hljs-number">13.</span> diskmgmt.msc<span class="hljs-comment">—磁盘治理实用程序</span><br><span class="hljs-number">14.</span> osk<span class="hljs-comment">————打开屏幕键盘</span><br><span class="hljs-number">15.</span> narrator<span class="hljs-comment">——-屏幕“讲述人”</span><br><span class="hljs-number">16.</span> Sndvol32<span class="hljs-comment">——-音量控制程序</span></p>
<p><strong>系统类</strong></p>
<p><span class="hljs-comment">1</span><span class="hljs-string">.</span> <span class="hljs-comment">gpedit</span><span class="hljs-string">.</span><span class="hljs-comment">msc</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">组策略</span><br><span class="hljs-comment">2</span><span class="hljs-string">.</span> <span class="hljs-comment">rsop</span><span class="hljs-string">.</span><span class="hljs-comment">msc</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">组策略结果集</span><br><span class="hljs-comment">3</span><span class="hljs-string">.</span> <span class="hljs-comment">lusrmgr</span><span class="hljs-string">.</span><span class="hljs-comment">msc</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">本机用户和组</span><br><span class="hljs-comment">4</span><span class="hljs-string">.</span> <span class="hljs-comment">services</span><span class="hljs-string">.</span><span class="hljs-comment">msc</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">本地服务设置</span><br><span class="hljs-comment">5</span><span class="hljs-string">.</span> <span class="hljs-comment">devmgmt</span><span class="hljs-string">.</span><span class="hljs-comment">msc</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span> <span class="hljs-comment">设备治理器</span><br><span class="hljs-comment">6</span><span class="hljs-string">.</span> <span class="hljs-comment">dcomcnfg</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">打开系统组件服务</span><br><span class="hljs-comment">7</span><span class="hljs-string">.</span> <span class="hljs-comment">mmc</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">打开控制台</span><br><span class="hljs-comment">8</span><span class="hljs-string">.</span> <span class="hljs-comment">net</span> <span class="hljs-comment">start</span> <span class="hljs-comment">messenger</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">开始信使服务</span><br><span class="hljs-comment">9</span><span class="hljs-string">.</span> <span class="hljs-comment">net</span> <span class="hljs-comment">stop</span> <span class="hljs-comment">messenger</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">停止信使服务</span><br><span class="hljs-comment">10</span><span class="hljs-string">.</span> <span class="hljs-comment">compmgmt</span><span class="hljs-string">.</span><span class="hljs-comment">msc</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">计算机治理</span><br><span class="hljs-comment">11</span><span class="hljs-string">.</span> <span class="hljs-comment">cleanmgr</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">垃圾整理</span><br><span class="hljs-comment">12</span><span class="hljs-string">.</span> <span class="hljs-comment">regedit</span><span class="hljs-string">.</span><span class="hljs-comment">exe</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">注册表</span><br><span class="hljs-comment">13</span><span class="hljs-string">.</span> <span class="hljs-comment">regedt32</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">注册表编辑器</span><br><span class="hljs-comment">14</span><span class="hljs-string">.</span> <span class="hljs-comment">Msconfig</span><span class="hljs-string">.</span><span class="hljs-comment">exe</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">系统配置实用程序</span><br><span class="hljs-comment">15</span><span class="hljs-string">.</span> <span class="hljs-comment">chkdsk</span><span class="hljs-string">.</span><span class="hljs-comment">exe</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">Chkdsk磁盘检查</span><br><span class="hljs-comment">16</span><span class="hljs-string">.</span> <span class="hljs-comment">charmap</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">启动字符映射表</span><br><span class="hljs-comment">17</span><span class="hljs-string">.</span> <span class="hljs-comment">diskmgmt</span><span class="hljs-string">.</span><span class="hljs-comment">msc</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">磁盘治理实用程序</span><br><span class="hljs-comment">18</span><span class="hljs-string">.</span> <span class="hljs-comment">perfmon</span><span class="hljs-string">.</span><span class="hljs-comment">msc</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">计算机性能监测程序</span><br><span class="hljs-comment">19</span><span class="hljs-string">.</span> <span class="hljs-comment">dxdiag</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">检查DirectX信息</span><br><span class="hljs-comment">20</span><span class="hljs-string">.</span> <span class="hljs-comment">sfc</span> <span class="hljs-comment">/scannow</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">扫描错误并复原</span><br><span class="hljs-comment">21</span><span class="hljs-string">.</span> <span class="hljs-comment">taskmgr</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">任务治理器（2000／xp／2003）</span><br><span class="hljs-comment">22</span><span class="hljs-string">.</span> <span class="hljs-comment">winver</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">检查Windows版本</span><br><span class="hljs-comment">23</span><span class="hljs-string">.</span> <span class="hljs-comment">wmimgmt</span><span class="hljs-string">.</span><span class="hljs-comment">msc</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">打开windows治理体系结构(WMI)</span><br><span class="hljs-comment">24</span><span class="hljs-string">.</span> <span class="hljs-comment">wscript</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">windows脚本宿主设置</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">挺有用的</span><br><span class="hljs-comment">25</span><span class="hljs-string">.</span> <span class="hljs-comment">ntmsmgr</span><span class="hljs-string">.</span><span class="hljs-comment">msc</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">移动存储治理器</span><br><span class="hljs-comment">26</span><span class="hljs-string">.</span> <span class="hljs-comment">ntmsoprq</span><span class="hljs-string">.</span><span class="hljs-comment">msc</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">移动存储治理员操纵请求</span><br><span class="hljs-comment">27</span><span class="hljs-string">.</span> <span class="hljs-comment">eventvwr</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">事件查看器</span><br><span class="hljs-comment">28</span><span class="hljs-string">.</span> <span class="hljs-comment">eudcedit</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">造字程序</span><br><span class="hljs-comment">29</span><span class="hljs-string">.</span> <span class="hljs-comment">mobsync</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">同步命令</span><br><span class="hljs-comment">30</span><span class="hljs-string">.</span> <span class="hljs-comment">netstat</span> <span class="hljs-literal">-</span><span class="hljs-comment">an</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">(TC)命令检查接口</span><br><span class="hljs-comment">31</span><span class="hljs-string">.</span> <span class="hljs-comment">syncapp</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">创建一个公文包</span><br><span class="hljs-comment">32</span><span class="hljs-string">.</span> <span class="hljs-comment">sysedit</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">系统配置编辑器</span><br><span class="hljs-comment">33</span><span class="hljs-string">.</span> <span class="hljs-comment">sigverif</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">文件签名验证程序</span><br><span class="hljs-comment">34</span><span class="hljs-string">.</span> <span class="hljs-comment">secpol</span><span class="hljs-string">.</span><span class="hljs-comment">msc</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">本地安全策略</span><br><span class="hljs-comment">35</span><span class="hljs-string">.</span> <span class="hljs-comment">sfc</span><span class="hljs-string">.</span><span class="hljs-comment">exe</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">系统文件检查器</span><br><span class="hljs-comment">36</span><span class="hljs-string">.</span> <span class="hljs-comment">sfc</span> <span class="hljs-comment">/scannow</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">windows文件保护</span><br><span class="hljs-comment">37</span><span class="hljs-string">.</span> <span class="hljs-comment">regsvr32</span> <span class="hljs-comment">/u</span> <span class="hljs-comment">zipfldr</span><span class="hljs-string">.</span><span class="hljs-comment">dll</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">取消ZIP支持</span><br><span class="hljs-comment">38</span><span class="hljs-string">.</span> <span class="hljs-comment">certmgr</span><span class="hljs-string">.</span><span class="hljs-comment">msc</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">证书治理实用程序</span><br><span class="hljs-comment">39</span><span class="hljs-string">.</span> <span class="hljs-comment">cliconfg</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">SQL</span> <span class="hljs-comment">SERVER</span> <span class="hljs-comment">客户端网络实用程序</span><br><span class="hljs-comment">40</span><span class="hljs-string">.</span> <span class="hljs-comment">ciadv</span><span class="hljs-string">.</span><span class="hljs-comment">msc</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">索引服务程序</span><br><span class="hljs-comment">41</span><span class="hljs-string">.</span> <span class="hljs-comment">odbcad32</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">ODBC数据源治理器</span><br><span class="hljs-comment">42</span><span class="hljs-string">.</span> <span class="hljs-comment">iexpress</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">木马***工具，系统自带</span><br><span class="hljs-comment">43</span><span class="hljs-string">.</span> <span class="hljs-comment">fsmgmt</span><span class="hljs-string">.</span><span class="hljs-comment">msc</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">共享文件夹治理器</span><br><span class="hljs-comment">44</span><span class="hljs-string">.</span> <span class="hljs-comment">utilman</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">辅助工具治理器</span></p>
<p><strong>闲的蛋疼，没事不要瞎玩类</strong></p>
<p><span class="hljs-comment">1</span><span class="hljs-string">.</span> <span class="hljs-comment">logoff</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">注销命令</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">别乱用</span><br><span class="hljs-comment">2</span><span class="hljs-string">.</span> <span class="hljs-comment">tsshutdn</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">60秒倒计时关机命令</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">别乱用</span><br><span class="hljs-comment">3</span><span class="hljs-string">.</span> <span class="hljs-comment">rononce</span> <span class="hljs-literal">-</span><span class="hljs-comment">p</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">15秒关机</span><br><span class="hljs-comment">4</span><span class="hljs-string">.</span> <span class="hljs-comment">tsshutdn</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">60秒倒计时关机命令</span><br><span class="hljs-comment">5</span><span class="hljs-string">.</span> <span class="hljs-comment">syskey</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">系统加密，一旦加密就不能解开，保护windows</span> <span class="hljs-comment">xp系统的双重密码</span></p>
<hr>
<p><br>前端新手，弱鸡一枚，如有错误，请指正，谢谢！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://michaelooo.github.io/2017/05/08/" data-id="clepflm6y0013fbmn82414v89" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/windows/" rel="tag">windows</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BF%85%E5%A4%87%E5%91%BD%E4%BB%A4/" rel="tag">必备命令</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-深入浅出nodejs学习笔记--第十、十一章 测试 产品化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/21/" class="article-date">
  <time datetime="2017-04-21T14:37:19.000Z" itemprop="datePublished">2017-04-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/nodejs/">nodejs</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/21/">深入浅出nodejs学习笔记--第十、十一章 测试 产品化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a><strong>单元测试</strong></h1><p>我们知道后端都有单元测试，比如学习Java用到的Junit，很好用，那么前端有没有单元测试呢？答案当然是有的。这里就简单总结一下前端单元测试的内容和一些常用的测试框架。</p>
<h2 id="单元测试编写原则："><a href="#单元测试编写原则：" class="headerlink" title="单元测试编写原则："></a><strong>单元测试编写原则：</strong></h2><p>我们都知道做单元测试可以有很多好处，但是在了解单元测试之前，先来看一下单元测试的编写规则，在编写可测试的代码需要注意以下3个问题：</p>
<ul>
<li>单一职责： 尽量细分代码的职责，不要给一段代码附加太多而逻辑从而使代码变得不可控。</li>
<li>接口抽象： 对于大的项目，业务逻辑比较复杂，要记得写接口，针对接口进行测试。</li>
<li>层次分离： MVC就是最好的例子。</li>
</ul>
<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a><strong>断言</strong></h2><p>单元测试的核心应用就是断言，用一个最简单的例子介绍一下什么是断言：</p>
<pre><code>var assert = require(&#39;assert&#39;)
assert.equal(Math.max(1, 100), 100)
</code></pre><p>  equal()是断言模块的内置方法，用于判断实际值与期望值是否相等。类似的方法还有ok()、notEqual()等。上句代码的意思是判断 Math.max(1, 100) 的输出结果是不是100，如果不是，就抛出异常。</p>
<h2 id="测试框架"><a href="#测试框架" class="headerlink" title="测试框架"></a><strong>测试框架</strong></h2><p>  单元测试很简单，下面介绍两个常用的单元测试库，<strong>jasmine 和 mocha</strong></p>
<p>  <strong>jasmine</strong></p>
<p>  Jasmine的开发团队来自PivotalLabs，他们一开始开发的JavaScript测试框架是JsUnit，来源于著名的JAVA测试框架JUnit。JsUnit是xUnit的JavaScript实现。但是JsUnit在2009年后就已经停止维护了，他们推出了一个新的BDD框架Jasmine。Jasmine不依赖于任何框架，所以适用于所有的Javascript代码。</p>
<p>  下面直接放一个官方的使用案例：</p>
  <pre class="prettyprint">describe(<span class="hljs-string">"A spec"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">var</span> foo;
    beforeEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
      foo = <span class="hljs-number">0</span>;
      foo += <span class="hljs-number">1</span>;
    });
    afterEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
      foo = <span class="hljs-number">0</span>;
    });
    it(<span class="hljs-string">"is just a function, so it can contain any code"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
      expect(foo).toEqual(<span class="hljs-number">1</span>);
    });
    it(<span class="hljs-string">"can have more than one expectation"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
      expect(foo).toEqual(<span class="hljs-number">1</span>);
      expect(<span class="hljs-literal">true</span>).toEqual(<span class="hljs-literal">true</span>);
    });
    describe(<span class="hljs-string">"nested inside a second describe"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
      <span class="hljs-keyword">var</span> bar;
      beforeEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
        bar = <span class="hljs-number">1</span>;
      });
      it(<span class="hljs-string">"can reference both scopes as needed"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
        expect(foo).toEqual(bar);
      });
    });
  });</pre>

<p>  jasmine单元测试有二个核心的部分：describe 函数块和it函数块</p>
<p>  describe和it函数都有二个参数： </p>
<p>  第一个参数：测试描述； </p>
<p>  第二个参数：测试用的具体逻辑</p>
<p>  <strong>mocha</strong></p>
<p>  mocha的使用和jasmine类似，这里也直接放一个例子：</p>
  <pre class="prettyprint">var <span class="hljs-built_in">assert</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'assert'</span>);
  describe(<span class="hljs-string">'Array'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> {
    describe(<span class="hljs-string">'#indexOf()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> {
      it(<span class="hljs-string">'should return -1 when the value is not present'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> {
        <span class="hljs-built_in">assert</span>.equal(-<span class="hljs-number">1</span>, [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>].indexOf(<span class="hljs-number">4</span>));
      });
    });
  });</pre>

<p>describe块称为”测试套件”（test suite），表示一组相关的测试。它是一个函数，第一个参数是测试套件的名称（随便起，能让别人看懂就好），第二个参数是一个实际执行的函数。 </p>
<p>it块称为”测试用例”（test case），表示一个单独的测试，是测试的最小单位。它也是一个函数，第一个参数是测试用例的名称（随便起，能让别人看懂就好），第二个参数是一个实际执行的函数。</p>
<p>这里只简单介绍，具体使用可以看阮一峰的mocha实例教程： <a href="http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html</a></p>
<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a><strong>性能测试</strong></h2><p>性能测试主要包括基准测试、压力测试、和负载测试：</p>
<ul>
<li>基准测试： 基准测试的目的是统计在多少时间内执行了多少方法。</li>
<li>压力测试：压力测试就是模拟请求测试网络接口，查看吞吐率，响应时间和并发数。常用的工具是ab、siege、http_load,使用很简单，直接看文档就可以使用，这里不多赘述</li>
<li>负载测试： 负载测试和压力测试很像，主要是测试数据在超负荷环境中运行，程序是否能够承担。</li>
</ul>
<h1 id="产品化"><a href="#产品化" class="headerlink" title="产品化"></a><strong>产品化</strong></h1><p>产品化的内容很简单，重点在于实践和工程化中的运用。主要包括以下：</p>
<h2 id="项目工程化"><a href="#项目工程化" class="headerlink" title="项目工程化"></a><strong>项目工程化</strong></h2><p>目前现有的一些项目工程管理，不如webpack，gulp等，用起来都很方便。</p>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a><strong>性能优化</strong></h2><p>以下是几个常见的提升性能的方法：</p>
<ul>
<li>动静分离： 动态请求和静态请求分离开来</li>
<li>启用缓存： 适当利用缓存，但是不可以过分利用缓存</li>
<li>多线程架构：具体可以参照第九章的笔记</li>
<li>读写分离：主要针对数据库，因为读写操作速度是不一样的，读的速度是高于写入的速度的，所以对于不同的业务，可以对数据库做读写分离处理，具体可以查看博客：<a href="https://my.oschina.net/candiesyangyang/blog/203425" target="_blank" rel="noopener">https://my.oschina.net/candiesyangyang/blog/203425</a></li>
</ul>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a><strong>日志</strong></h2><p>对于程序来说，写日志是十分重要的，对于异常日志的捕捉都是对日后程序维护的利器，一般情况推荐把日志存为文件，不推荐存入数据库。</p>
<h2 id="监控报警"><a href="#监控报警" class="headerlink" title="监控报警"></a><strong>监控报警</strong></h2><p>所谓监控主要包括对 日志监控、响应时间、进程监控、磁盘监控、内存监控、CPU占用监控、CPU load监控、I/O负载、网络监控、应用状态监控、DNS监控。报警一般都是通过短信或者邮件来执行。</p>
<h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a><strong>稳定性</strong></h2><p>为保证应用的稳定性，可以采用多机器、多机房、多备份的方式来保证。</p>
<h2 id="异构共存"><a href="#异构共存" class="headerlink" title="异构共存"></a><strong>异构共存</strong></h2><p>主要是指与其他语言的兼容性，协同作为。</p>
<hr>
<p><br>前端新手，弱鸡一枚，如有错误，请指正，谢谢！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://michaelooo.github.io/2017/04/21/" data-id="clepflm870050fbmn87hncqcl" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nodejs/" rel="tag">nodejs</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-深入浅出nodejs学习笔记--第九章 玩转进程管理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/20/" class="article-date">
  <time datetime="2017-04-20T10:05:41.000Z" itemprop="datePublished">2017-04-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/nodejs/">nodejs</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/20/">深入浅出nodejs学习笔记--第九章 玩转进程管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>node的一个最大特性就是单线程，单线程带来的好处是不用像多线程编程那样去考虑状态的同步问题，也不用去担心出现死锁，也没有线程上下文所带来的性能的开销。但是同时也带来了一些问题，比如无法充分利用的多核CPU，线程会阻塞的问题。</p>
<p>但是node真的就不能更高效了吗，当然是不会的，如前几篇笔记所说，node对于“多进程”的处理有自己的一套解决方案，今天就来简单了解下。</p>
<h2 id="服务模型的演变"><a href="#服务模型的演变" class="headerlink" title="服务模型的演变"></a><strong>服务模型的演变</strong></h2><p>在了解node的解决方法之前吗，需要先了解一下Web服务器关于客户端请求的处理方案的一个演变过程，大概如下：</p>
<p><span class="hljs-comment">同步</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span>&gt; <span class="hljs-comment">复制进程</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span>&gt; <span class="hljs-comment">多线程</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span>&gt; <span class="hljs-comment">事件驱动</span></p>
<p>一开始，是属于同步的情况，同步的情况，一次只为一个请求服务。到后来，出现了改进，那就是复制进程，通过进程的复制可以服务更多的请求，但是这里的问题是每一个请求都需要一个进程来服务，性能上比较浪费。再后来是多线程，多核CPU的出现，创建多个线程来处理请求，但是这个方案的问题是，在切换现成的同时也需要切换线程的上下文，当线程的数量过多，时间就会被耗费到上下文的切换上。最后的一个就是事件驱动的方案，node和 nginx都是基于事件驱动的方式实现的，采用单线程避免了不必要的内存开销和上下文切换开销。</p>
<h2 id="node的多进程架构"><a href="#node的多进程架构" class="headerlink" title="node的多进程架构"></a><strong>node的多进程架构</strong></h2><p>node的多进程架构采用了child_process的方式，分为<strong>主进程和工作进程</strong>，主进程不负责具体的业务逻辑，只负责调度和管理工作进程。工作进程负责具体的业务逻辑。</p>
<p>如下演示如何创建一个子进程，以及一些操作</p>
<pre class="prettyprint"><span class="hljs-keyword">var</span> child_process = <span class="hljs-built_in">require</span>(<span class="hljs-string">'child_process'</span>) 
<span class="hljs-comment">//启动一个子进程</span>
child_process.spawn(<span class="hljs-string">'node'</span>, [<span class="hljs-string">'test.js'</span>])
<span class="hljs-comment">//启动一个子进程，并执行命令</span>
child_process.exec(<span class="hljs-string">'node test.js'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err, stdout, stderr)</span> {</span>
    <span class="hljs-comment">//回调逻辑</span>
})
<span class="hljs-comment">//启动一个子进程，并执行可执行文件</span>
child_process.execFile(<span class="hljs-string">'test.js'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err, stdout, stderr)</span> {</span>
    <span class="hljs-comment">//回调的逻辑</span>
})
<span class="hljs-comment">//与spawn类似，启动一个子进程，不同的是它创建的进程只需要执行特定的文件模块即可，不参与其他的</span>
child_process.fork(<span class="hljs-string">'./test.js'</span>)</pre>


<p><strong>进程之间的通信</strong></p>
<p>创建了子进程之后，主进程与子进程之间的通信也是个大问题，进程间通信的目的是为了让不同的进程能够互相访问资源并进行协调工作。node是这样的处理的。</p>
<p>node通过创建一个管道来解决。父进程在创建子进程之前，会创建管道（IPC通道）来监听，然后才会创建子进程，并且此时子进程可以通过环境变量得到这个管道的文件描述符。子进程在启动的过程中，根据文件描述符去连接这个已存在的IPC通道，从而完成父子进程之间的连接。当然在实际的通信的过程中还会采用句柄传递的方式，说的简单一点就是对一个资源的特殊标识，作用是可以实现多个子进程采用一个句柄来进行通信。</p>
<p><strong>充分利用多核CPU，node集群</strong></p>
<p>首先看一下集群的概念，第一眼看到这个名词的时候，有点蒙。</p>
<p>集群：<br>      在百度百科的解释里，集群（cluster）技术是一种较新的技术，通过集群技术，可以在付出较低成本的情况下获得在性能、可靠性、灵活性方面的相对较高的收益，其任务调度则是集群系统中的核心技术。集群的目的就是提高性能、降低成本、提高可扩展性、增强可靠性。</p>
<p>用我的理解就是，集群就是指将很多服务器集中起来，一起进行同一种服务,但是对客户端来说，在服务端感觉就是一个的存在。</p>
<p>关于集群，了解不深，只说两个概念，<strong>负载均衡和状态共享</strong></p>
<ul>
<li><strong>负载均衡</strong>：服务器也有负载均衡，但对于node所讨论的，意思就是在多核CPU环境下，始终保证每个CPU都能被使用到从而保证最大效率。node采用的策略是轮叫调度，由主进程接手连接任务，然后依次分发给工作的子进程。</li>
<li><strong>状态共享</strong>： 也是有两种情况，一种是要第三方存储，利用Redis来实现，一种是主动通知，其实也需要通过轮询来解决。</li>
</ul>
<p><strong>一个杀器，cluster模块</strong></p>
<p>cluster是一个nodejs内置的模块，用于nodejs多核处理。有了这个东西，就基本不用上面的介绍的子进程child_process了。cluster模块可以帮助我们简化多进程并行化程序的开发难度，轻松构建一个用于负载均衡的集群。</p>
<p>下面看一下官方的示例：</p>
<pre class="prettyprint"><span class="hljs-keyword">var</span> cluster = <span class="hljs-built_in">require</span>(<span class="hljs-string">'cluster'</span>)
<span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>)
<span class="hljs-keyword">var</span> numCPUs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'os'</span>).cpus().length  <span class="hljs-comment">//cpu的核心数</span>
<span class="hljs-keyword">if</span> (cluster.isMaster) {
<span class="hljs-comment">//创建多个子进程</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; numCPUs; i++) {
    cluster.fork();
}
cluster.on(<span class="hljs-string">'exit'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(worker, code, signal)</span> {</span>
    console.log(<span class="hljs-string">'worker'</span> + worker.process.id + <span class="hljs-string">'died'</span>)
})
} <span class="hljs-keyword">else</span> {
http.createServer(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, res)</span> {</span>
    res.writeHead(<span class="hljs-number">200</span>)
    res.end(<span class="hljs-string">'hello world'</span>)
}).listen(<span class="hljs-number">1234</span>)
}</pre>

<p>顺便解释一下cluster的工作原理：</p>
<p>cluster模块实际上是<strong>chlid_process和net模块</strong>的组合应用。cluster启动时，会在内部启动一个TCP服务器，在cluster创建一个子进程（fork）时，将这个TCP服务器端socket的文件描述符发送给工作进程。如果进程是复制出来的，并且存在网络端口的调用，那么它就会拿到该文件描述符，并重用，从而实现多个子进程共享端口。</p>
<p>有关cluster详细的代码实践，可以参考这篇博客：<a href="https://cnodejs.org/topic/56e84480833b7c8a0492e20c" target="_blank" rel="noopener">https://cnodejs.org/topic/56e84480833b7c8a0492e20c</a></p>
<hr>
<p><br>前端新手，弱鸡一枚，如有错误，请指正，谢谢！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://michaelooo.github.io/2017/04/20/" data-id="clepflm880052fbmnvh6w08lu" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nodejs/" rel="tag">nodejs</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-深入浅出nodejs学习笔记--第六~八章 理解Buffer 网络编程 构建WEB应用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/19/" class="article-date">
  <time datetime="2017-04-19T14:34:26.000Z" itemprop="datePublished">2017-04-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/nodejs/">nodejs</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/19/">深入浅出nodejs学习笔记--第六~八章 理解Buffer 网络编程 构建WEB应用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="第六章-理解Buffer"><a href="#第六章-理解Buffer" class="headerlink" title="第六章 理解Buffer"></a><strong>第六章 理解Buffer</strong></h2><p>这一章要理解的不多，都是一些buffer的常见操作，看API就可以熟悉，如果做过后台的就不会陌生，这里需要注意的几个地方就是</p>
<ul>
<li><strong>Buffer所占用的内存</strong>不是通过V8分配的，属于堆外内存，所以意思就是其实在V8启动的时候就会有一个Buffer对象一直常驻内存，无需通过require引入。</li>
<li><strong>Buffer的内存分配</strong>分为小内存分配和大内存分配，小内存分配一般指的是小于 8kb 的 Buffer 的对象，大内存当然就是大于 8kb的Buffer 对象。</li>
<li><p><strong>Buffer的转换</strong>主要体现在字符串转Buffer和Buffer转字符串，字符串转Buffer直接通过构造函数来实现。</p>
<pre><code>new Buffer(str, [encording]) //encording值编码类型
</code></pre><p>Buffer转字符串通过 toString() 可以实现。</p>
<pre><code>buf.toString([encording], [start], [end])
</code></pre></li>
<li><p><strong>Buffer的性能</strong>，通过预先转换静态内容为Buffer对象，可以有效减少CPU的重复使用，从而节省服务器资源。</p>
</li>
</ul>
<h2 id="第七章-网络编程"><a href="#第七章-网络编程" class="headerlink" title="第七章 网络编程"></a><strong>第七章 网络编程</strong></h2><p>这一章也比较简单，主要分为四个，构建TCP服务、构建UDP服务、构建HTTP服务、构建WebSocket服务，前两个不是重点，后两个比较常用。不多说，直接看代码。</p>
<p><strong>构建TCP服务</strong></p>
<pre class="prettyprint"><span class="hljs-comment">//示例，创建一个TCP服务器端</span>
<span class="hljs-keyword">var</span> net = <span class="hljs-built_in">require</span>(<span class="hljs-string">'net'</span>) <span class="hljs-comment">//依赖node自带的net模块</span>

<span class="hljs-keyword">var</span> server = net.createServer(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(socket)</span> {</span>
    <span class="hljs-comment">//新的连接</span>
    socket.on(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data)</span> {</span>
        console.log(<span class="hljs-string">'连上了'</span>)
    })
    <span class="hljs-comment">//断开连接</span>
    socket.on(<span class="hljs-string">'end'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data)</span> {</span>
        console.log(<span class="hljs-string">'连接断开'</span>)
    })
    socket.write(<span class="hljs-string">'创建一个TCP服务器端'</span>)
})

<span class="hljs-comment">//监听</span>
server.listen(<span class="hljs-number">1234</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    console.log(<span class="hljs-string">'已绑定1234端口号'</span>)
})</pre>

<p><strong>构建一个UDP服务器端和一个UDP客户端</strong></p>
<pre class="prettyprint"><span class="hljs-comment">//示例，创建一个UDP服务器端</span>
<span class="hljs-keyword">var</span> dgram = <span class="hljs-built_in">require</span>(<span class="hljs-string">'dgram'</span>)

<span class="hljs-keyword">var</span> server = dgram.createSocket(<span class="hljs-string">'udp4'</span>)

server.on(<span class="hljs-string">'message'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(msg, rinfo)</span> {</span>
console.log(<span class="hljs-string">'服务器得到了'</span> + msg + <span class="hljs-string">'来自'</span> + rinfo.address + <span class="hljs-string">':'</span> + rinfo.port)
})

server.on(<span class="hljs-string">'listening'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
<span class="hljs-keyword">var</span> address = server.address()
console.log(<span class="hljs-string">'已绑定'</span> + rinfo.address + <span class="hljs-string">':'</span> + rinfo.port)
})

<span class="hljs-comment">//示例，创建一个UDP客户端，与UDP服务器端对话</span>
<span class="hljs-keyword">var</span> dgram = <span class="hljs-built_in">require</span>(<span class="hljs-string">'dgram'</span>)

<span class="hljs-keyword">var</span> message = <span class="hljs-keyword">new</span> Buffer(<span class="hljs-string">'test.txt'</span>)
<span class="hljs-keyword">var</span> client = dgram.createSocket(<span class="hljs-string">'udp4'</span>)

<span class="hljs-comment">//通过客户端发送给网络，参数分别对应 要发送的Buffer  Buffer的偏移  Buffer的长度  目标端口 目标地址 完成后的回调</span>
client.send(message, <span class="hljs-number">0</span>, message.length, <span class="hljs-number">1234</span>, <span class="hljs-string">'localhost'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err, bytes)</span> {</span> 
client.close();
})</pre>

<p><strong>构建一个HTTP服务器</strong></p>
<p>这个真的好熟悉，如下：</p>
<pre class="prettyprint">//示例，创建一个HTTP服务器, <span class="hljs-keyword">http</span>模块继承于TCP中的net模块
var <span class="hljs-keyword">http</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>)

<span class="hljs-keyword">http</span>.createServer(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-title">req</span>, <span class="hljs-title">res</span>) {</span>
    res.writeHead(<span class="hljs-number">200</span>, {<span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'text/plain'</span>})
    res.<span class="hljs-keyword">end</span>(<span class="hljs-string">'雷猴\n'</span>)
}).listen(<span class="hljs-number">1234</span>, <span class="hljs-string">'localhost'</span>)

console.<span class="hljs-built_in">log</span>(<span class="hljs-string">'已绑定 http://localhost:1234'</span>)</pre>

<p><strong>构建WebSocket服务</strong></p>
<p>WebSocket也是一种基于事件的编程模型，所以和Node结合也是相得益彰，同时WebSocket实现了客户端和服务器端之间的长连接，Node事件驱动的方式十分擅长于大量的客户端保持高并发的连接。</p>
<pre class="prettyprint">//示例，WebSocket在客户端的应用
var <span class="hljs-built_in">socket</span> = <span class="hljs-built_in">new</span> WebSocket(<span class="hljs-string">'ws://localhost:1234/update'</span>)

<span class="hljs-built_in">socket</span>.onopen = <span class="hljs-function"><span class="hljs-keyword">function</span> () {</span>
    setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span> () {</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">socket</span>.bufferedAmount === <span class="hljs-number">0</span>) {
            <span class="hljs-built_in">socket</span>.<span class="hljs-built_in">send</span>(getUpdateData())
        }
    }, <span class="hljs-number">50</span>)
}

<span class="hljs-built_in">socket</span>.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-title">event</span>) {</span>
   <span class="hljs-comment"> //todo: event.data 的处理</span>
}</pre>

<p><strong>网络服务与安全</strong></p>
<p>还有一个关于网络编程的便是网络安全。node在网络安全上提供了3个模块，<strong>crypto</strong>、<strong>tls</strong>、<strong>https</strong>。其中crypto主要用于加密解密，tls模块提供了与net模块类似的功能，区别在于建立在TSL/SSL加密的TCP连接之上，https与http基本都是一致的，区别在于前者更安全。</p>
<h2 id="第八章-构建Web应用"><a href="#第八章-构建Web应用" class="headerlink" title="第八章 构建Web应用"></a><strong>第八章 构建Web应用</strong></h2><p>关于构建Web应用这一章，其实现有其他的框架讲的而且运用的已经很详细，比如KOA，比如Express，试着运用这两个做一个web应用更能加深理解，这里就总结一下构建Web应用的组成</p>
<p><strong>基础功能</strong></p>
<ul>
<li><strong>请求方法</strong>：常见的请求方法有GET、POST、PUT、DELETE，存在于请求报文的第一行的第一个单词，通常为大写。</li>
<li><strong>路径解析</strong>：浏览器将请求解析成报文，位于请求报文的第二行。</li>
<li><strong>查询字符串</strong>：即请求传递的参数。</li>
<li><strong>cookie</strong>：记录服务器和客户端之间的状态。服务器端生成向客户端发送 –&gt; 浏览器保存cookie –&gt;<br>每次浏览器发送请求都会携带cookie，cookie会造成带宽浪费，所以可以减少cookie的大小，为静态的组件使用不同的域名，减少DNS的查询来避免。</li>
<li><strong>session</strong>：与cookie作用类似，但是session只保留在服务器端，并且常驻内存（利用Redis或者Memcached可以统一转移到集中的数据存储中）。session也会有安全问题，但是相对较小，常见的漏洞就是XSS漏洞（跨站脚本攻击）。</li>
<li><strong>缓存</strong>：利用浏览器来缓存静态资源，目的是提升加载速度从而提升体验。</li>
<li><strong>Basic认证</strong>：请求报文头部的Authorization，这种方式有缺陷，因为在网络传输中这些验证接近于明文，所以不可取。</li>
</ul>
<p><strong>数据上传</strong></p>
<ul>
<li><strong>表单数据</strong>：即常见的form表单提交。</li>
<li><strong>JSON/XML</strong>: 提交的数据是JSON/XML格式的，现在大部分的交互都是用的JSON，XML的也有用，比如微信公众号平台的开发的交互就是用的XML，这个真的贼坑。</li>
<li><strong>附件上传</strong>：利用form-data来实现附件上传。</li>
<li><strong>数据上传安全</strong>：数据上传的安全性问题主要体现在内存限制和跨站伪造请求的问题上，所以一要对上传做限制，而是在开发中要加hash值做标识，就是加一个随机数。</li>
</ul>
<p><strong>路由解析</strong></p>
<ul>
<li><strong>文件路径型</strong>：分为静态文件和动态文件，不需要解释。</li>
<li><strong>MVC</strong>：前端MVC，之前一篇博客有讲，现在前端都是MV*。</li>
<li><strong>RESTful</strong>: 表述性状态转移，强调所有的资源都是可以通过URL访问到，对URL做文章，与MVC不冲突。可以看下阮一峰的博客：<a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/05/restful_api.html</a></li>
</ul>
<p><strong>中间件</strong></p>
<ul>
<li><strong>异常处理</strong>：中间件的核心就是尾调用next()，所以对于一些异常，需要在next()添加一个参数,并且把捕获到的异常传递过来。</li>
<li><strong>性能</strong>：中间件的出现时服务于具体业务的，所以要特殊特用，性能问题并不大。</li>
</ul>
<p><strong>页面渲染</strong></p>
<ul>
<li><strong>内容响应</strong>：内容的响应主要依赖于报文中的Content-*字段，它决定了客户端会以什么样的方式来作出响应，下载、跳转等。</li>
<li><strong>视图渲染</strong>：一般是通过模板加数据共同生成出来的。</li>
<li><strong>模板</strong>：比视图渲染更进一步，模板的使用的对前端页面的一种复用，是对html体的复用。比如javaweb中的jsp，或者PHP，当然这些都相对成熟，对于初出茅庐的node来说，现在常用的模板渲染模块有jade,heredoc,ejs等。</li>
</ul>
<hr>
<p><br>前端新手，弱鸡一枚，如有错误，请指正，谢谢！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://michaelooo.github.io/2017/04/19/" data-id="clepflm86004wfbmnuckx9ant" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nodejs/" rel="tag">nodejs</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-深入浅出nodejs学习笔记--第五章 内存控制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/18/" class="article-date">
  <time datetime="2017-04-18T14:31:37.000Z" itemprop="datePublished">2017-04-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/nodejs/">nodejs</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/18/">深入浅出nodejs学习笔记--第五章 内存控制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>首先声明一下，这个内存控制指的是V8引擎的内存控制，听起来很高大上，平时web开发可能不会去考虑浏览器的内存控制机制，但是其实我们在学习js的时候就有多少了解到垃圾回收和内存监控这相关的知识。</p>
<h2 id="Js的垃圾回收机制和内存控制"><a href="#Js的垃圾回收机制和内存控制" class="headerlink" title="Js的垃圾回收机制和内存控制"></a><strong>Js的垃圾回收机制和内存控制</strong></h2><p>在<strong>《JavaScript高级程序设计》（第三版）</strong>里也有提到了<strong>js的垃圾回收机制和内存回收</strong>问题，这里简单的回想一下：</p>
<p>我们知道，js和java的一个共同点就是有自己的垃圾回收机制，所以他们不用像C/C++程序员一样在编写代码的时候去关心内存的分配与释放的问题。关于js的垃圾回收机制，主要有以下两种：</p>
<ul>
<li><strong>标记清除</strong>： 这个很容易理解，就是当你在函数内声明一个变量，那么在函数执行的时候，就将该变量进行标记，标记为进入，函数执行完毕就标记为离开，进入标记的是不可以被回收的</li>
<li><strong>引用计数</strong>： 更简单的，就是一个变量被使用的次数，用到一次就加一，数目小于多少的就给予清除</li>
</ul>
<p><strong>那么如何管理内存呢？</strong></p>
<p>前面也说了，因为有自动的垃圾回收机制，所以程序员不用去操心内存管理的问题，但是要注意的一点就是，js的可用内存是很小的，或者说是远远小于桌面程序的可使用内存（这个后面再说），所以为了确保占用最少的内存可以让页面获得更好地性能，最佳方式就是为执行中的代码只保存必要的数据，一旦数据不再有用，就将其释放（比如设置其值为null来释放引用），这样做的目的是解除变量的引用从而使垃圾收集机制在下次运行时将其回收（垃圾回收机制是按照固定的时间间隔或者预设的时间进行处理的，所以这个时间的长短也要考虑性能问题）</p>
<h2 id="V8的内存分配"><a href="#V8的内存分配" class="headerlink" title="V8的内存分配"></a><strong>V8的内存分配</strong></h2><p>那么说完了js中的内存管理，那么就到了我们今天讨论的V8引擎，浏览器内的内存控制。</p>
<p><strong>内存限制</strong></p>
<p>首先呢，通过Node使用内存时是只可以使用部分内存的，这个大小大概在（64位系统下是1.4GB，32位系统下是0.7GB），在V8中，所有的js对象都是通过堆来进行分配的，这个可以通过控制台输入 process.memoryUsage() 方法查看。执行此操作需要切换到node命令执行环境。</p>
<p><strong>V8的内存分配</strong></p>
<p>在V8中，主要将内存分为新生代和老生代两种，新生代中的对象为存活时间比较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。V8的堆内存的大小就是新生代加上老生代的大小。而V8关于内存限制的算法主要有两种，这里只简单提及一下。</p>
<p>一种是牺牲空间换时间的算法，叫做<strong>Scavenge</strong>算法，通过该算法来回收新生代中的对象，原理就是讲新生代的内存一分为二，A和B，A和B永远都是一个处于空闲状态，一个处于使用状态，在垃圾回收的时，会检查使用中的A，如果A中存在还使用的对象啥的，就复制给空闲中的B，然后A中没有被使用对象啥的就会被清除，如此往复，达到垃圾清除的目的，但是这个算法有一个问题就是，如果A中存活的还在使用的对象是比较少的，那么在进行复制时，这个效率是很高的，但如果A中存活的对象比较大，效率就不能满足需求了。</p>
<p>这就牵扯到另外一种算法了，另外一种就是 <strong>Mark-Sweep</strong> 和 <strong>Mark-Compact</strong> ，标记清除方法，这个很简单，就是没有一分为二的概念，直接查找内存中的存活或者死亡的对象，然后添加一个标记，然后等垃圾回收进行清除，需要注意的一点，为了避免标记清除造成的内存碎片化，需要在对象被标记死亡后进行一次整理，将或者的对象往一端靠拢，举个例子就是好人站内存左边，坏人站内存右边，等会收拾坏人。</p>
<p><strong>如何高效的使用内存</strong> </p>
<p>这一块儿呢，只需要注意作用域和闭包带来的问题就好，跟js中的优化是一样的，不作介绍。</p>
<p><strong>内存泄漏</strong></p>
<p>内存泄漏是程序员在与内存打交道时一定要注意的问题，通常情况下，造成内存泄露的原因主要有三个： <strong>缓存、 队列消费不及时、 作用域未释放</strong>。</p>
<p>基于此，避免造成内存泄漏的方案也有以下两种：</p>
<ul>
<li><strong>不要将内存当做缓存</strong>： 说不要太过了，尽量不要吧；</li>
<li><strong>关注队列状态</strong>： 队列状态造成的内存泄漏其实不容易发生，因为大多数情况是使用的速度是大于生产的速度的，是不会有库存的。但是二班情况，如果出现了，就很难排查，所以对于队列状态引起的内存泄漏，应监控队列的长度，如果长度超过了一定限制，就给出异常拒绝再使用内存。</li>
</ul>
<hr>
<p><br>前端新手，弱鸡一枚，如有错误，请指正，谢谢！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://michaelooo.github.io/2017/04/18/" data-id="clepflm84004tfbmnzxjblui9" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nodejs/" rel="tag">nodejs</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-深入浅出nodejs学习笔记--第四章 异步编程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/18/" class="article-date">
  <time datetime="2017-04-17T16:09:53.000Z" itemprop="datePublished">2017-04-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/nodejs/">nodejs</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/18/">深入浅出nodejs学习笔记--第四章 异步编程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>这一章的知识跨度看起来不广，但是知识深度的还是挺深的，异步编程作为nodejs的核心，个人同时需要一定的深度才可以去理解。</p>
<p>在这一章提到了函数式编程和异步编程解决方案的两个知识点，首先来了解一下函数式编程</p>
<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a><strong>函数式编程</strong></h2><p>这里先放一本书，<a href="https://www.gitbook.com/book/llh911001/mostly-adequate-guide-chinese/details" target="_blank" rel="noopener">https://www.gitbook.com/book/llh911001/mostly-adequate-guide-chinese/details</a> 觉得讲得不错，因为越到后面越看不懂</p>
<p>JavaScript其实之前是一直被误解的，因为它一直被当做是命令式式的编程语言，或许js爸爸<strong>Brendan Eich</strong>一开始设计的时候也是这样想的，但是其实js也是可以做函数式的编程。所谓函数式编程，其实不难，不同于后台强类型语言的面向对象式的编程语言，函数式编程是种编程范式，它将电脑运算视为函数的计算，强调计算。</p>
<p>函数式编程有以下特点：支持闭包和高阶函数，支持惰性计算（lazy evaluation）。使用递归作为控制流程的机制。加强了引用透明性。没有副作用。（这句话是百度的）</p>
<p>这本书主要介绍了函数式编程的一些规范，我只拿其中的简单几个概念作为例子</p>
<p><strong>高阶函数</strong>： 高阶函数是可以把函数作为参数（如传递一个方法作为参数），或者说是可以把函数作为返回值的函数（其实就是return一个函数）</p>
<p><strong>偏函数</strong>： 偏函数是指通过部分参数来产生一个新的定制的函数的方式，这种就叫做偏函数</p>
<p><strong>纯函数</strong>： 书中的定义是这样的，纯函数是这样一种函数，即相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用。其实最重要的就是这句话，相同的输入总会的得到相同的输出，纯函数的纯就在这一点，不过多的对函数之外的环境产生依赖，保证函数本身的纯粹，从而达到纯的目的</p>
<p><strong>函数柯里化</strong>：curry无法口述，用一个例子来解释</p>
<pre><code>    var add = function(x) {
        return function(y) {
            return x + y;
        };
    };
    var increment = add(1);
    var addTen = add(10);
    increment(2);
    // 3
    addTen(2);

</code></pre><p>这里我们定义了一个 add 函数，它接受一个参数并返回一个新的函数。调用add 之后，返回的函数就通过闭包的方式记住了 add 的第一个参数。一次性地调用它实在是有点繁琐，好在我们可以使用一个特殊的 curry 帮助函数（helperfunction）使这类函数的定义和调用更加容易。</p>
<h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a><strong>异步编程</strong></h2><p><strong>异步编程的优势和难点</strong></p>
<p>node的异步编程所带来的最大优势就是基于事件驱动的<strong>非阻塞IO模型</strong>。非阻塞IO可以是CPU和IO操作并不相互依赖等待，让资源得以更好地利用。对于一些网络应用而言，并行还可以带来的优势是分布式和云。</p>
<p>但同时，node所带来的难点还是很困难的：</p>
<p><strong>难点1</strong>： 异常处理 异步中的异常都是这个尿性，看下jquery的ajax就知道，所以在编写异步方法时，需要将异常正确的返回给用户的回调方法</p>
<p><strong>难点2</strong>： 函数嵌套过深 回调地狱，不解释，但是现在有Promise,接下来会说</p>
<p><strong>难点3</strong>： 阻塞代码 单线程的缺点，谨慎处理</p>
<p><strong>难点4</strong>： 多线程编程 还是单线程所带来的问题，不过node有自己child_process</p>
<p><strong>难点5</strong>： 异步转同步 </p>
<p>  这个就是node用惯了异步，但是没有同步操作的API，所以可能在实现同步的时候要去借助第三方库，不过放心，npm上面的插件肯定很多</p>
<h2 id="异步编程的解决方案"><a href="#异步编程的解决方案" class="headerlink" title="异步编程的解决方案"></a><strong>异步编程的解决方案</strong></h2><p>关于异步编程的解决方案，书中给出了四种，分别是<strong>事件发布/订阅模式、Promise/Deferred、流程控制库、异步并发控制</strong></p>
<p><strong>事件发布/订阅模式</strong>： 这个就是设计模式中的一个概念，node中的event模块其实是一个很好地实践</p>
<p><strong>Promise/Deferred</strong>： 强调事件的状态和目标，根据状态来执行，从而避免深度嵌套，这个es6中的Promise也已经有了很好地实现</p>
<p><strong>流程控制库</strong>：流程控制的一个重要的概念就是尾触发，es6对这个有个比较好的实现，那就是终止函数，在es7的草案中，更是直接使用了await作为流程控制中止函数标识</p>
<p><strong>异步并发控制</strong>： 考虑到异步操作对内存的影响，为避免cpu挂掉，所以要对异步的并发进行控制</p>
<p><strong>扩展：</strong></p>
<p>既然说到了流程控制，就不得不说现在最流行的两个前端框架，<strong>Express</strong>和<strong>koa</strong></p>
<p>Express是一个老牌的web应用框架了，Express 是一个基于 Node.js 平台的极简、灵活的 web 应用开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。 </p>
<p>具体移步官网看，官网：<a href="http://www.expressjs.com.cn/" target="_blank" rel="noopener">http://www.expressjs.com.cn/</a>。</p>
<p>koa是新一种的前端框架，koa 是由 Express 原班人马打造的，致力于成为一个更小、更富有表现力、更健壮的 Web 框架。使用 koa 编写 web 应用，通过组合不同的 generator，可以免除重复繁琐的回调函数嵌套，并极大地提升错误处理的效率。koa 不在内核方法中绑定任何中间件，它仅仅提供了一个轻量优雅的函数库，使得编写 Web 应用变得得心应手。koa低层的实现依赖TJ大神的CO，库很小巧，暂时不深入，具体移步官网，官网：<a href="http://koa.bootcss.com/" target="_blank" rel="noopener">http://koa.bootcss.com/</a></p>
<hr>
<p><br>前端新手，弱鸡一枚，如有错误，请指正，谢谢！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://michaelooo.github.io/2017/04/18/" data-id="clepflm8b0057fbmnvvfmxxri" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nodejs/" rel="tag">nodejs</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-深入浅出nodejs学习笔记-异步IO" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/" class="article-date">
  <time datetime="2017-04-16T11:47:48.000Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/nodejs/">nodejs</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/16/">深入浅出nodejs学习笔记-前三章 简介、模块机制、异步I/O</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="第一章-node简介"><a href="#第一章-node简介" class="headerlink" title="第一章 node简介"></a>第一章 node简介</h2><p>在学习这章之前，先提三个问题，node是什么，为什么用node，node可以用来干什么？</p>
<p><strong>首先是回答第一个问题，node是什么？</strong></p>
<p>node习惯称为nodejs，听起来类似于js库，但是其实node并不是一个库，node其实是一个可以在后端运行JavaScript的环境。</p>
<p>js为什么可以在后端运行呢，不是只可以在浏览器运行吗？其实是js之所以可以再浏览器运行是因为在浏览器中集成了js解析引擎，类似Firefox的SpiderMonkey和IE的Chakra，其中最有名的当属于chrome的v8引擎，而node便是利用到了v8引擎，所以才可以在服务器端跑js，当如正如你所想的，因为node并没有渲染引擎，所以node是不处理UI的。</p>
<p><strong>那为什么要用node？</strong></p>
<p>作为一个后端js的运行平台，node要好用才会用啊，喏，如下：</p>
<ol>
<li><strong>异步IO</strong>：其实就是异步执行的IO操作，不用多说</li>
<li><strong>单线程</strong>：node是单线程运行的，所以不用考虑多线程地带来的同步啊、死锁之类的问题，但同时会带来一些问题，比如无法充分的利用多核CPU、一旦报错，程序就GG、CPU过载就会出异常等，对于这些问题，node也有一个简单的解决办法就是child_process，这个暂时先不谈</li>
<li><strong>跨平台</strong>：作为一个后台运行平台，这是JavaScript浩浩荡荡进军后台之势，当然也要像后台爸爸Java一样跨平台才好用哈</li>
<li><strong>事件与回调函数</strong>：node是基于事件驱动的，基于事件编程有<strong>轻量级、轻耦合、只关注事务点</strong>等优势，其实就是更关注业务逻辑，毕竟是前端</li>
</ol>
<p><strong>最后的问题，node可以用来干什么</strong></p>
<p>如上的node优势所说，一方面，node基于异步IO的特点，node擅长于处理IO密集型业务，另一方面，V8是十分强大的，所以node也很适合CPU密集型业务，而且效率不比java差哈，同时，node也比较适合于做一些游戏开发领域的事情、做分布式应用和一些工具类应用的开发</p>
<h2 id="第二章-node模块机制"><a href="#第二章-node模块机制" class="headerlink" title="第二章 node模块机制"></a>第二章 node模块机制</h2><p><strong>node模块机制</strong></p>
<p>关于node的模块机制，首先提一下CommonJS，CommonJS就是为JS的表现来制定规范，因为js没有模块的功能所以CommonJS应运而生，它希望js可以在任何地方运行，不只是浏览器中。CommonJS的模块规范如下</p>
<pre class="prettyprint"><span class="hljs-comment">//a.js</span>
exports.yeah = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    console.log(<span class="hljs-string">'yeah'</span>)
}

<span class="hljs-comment">//b.js</span>
<span class="hljs-keyword">var</span> yeah = <span class="hljs-built_in">require</span>(<span class="hljs-string">'yeah'</span>)</pre>

<p>在文件a中通过exports暴露出去一个yeah方法，然后在b.js文件中通过require引用，十分方便,但是CommonJS的缺陷还是很明显的，<strong>没有模块系统，标准库很少，没有标准的接口，缺乏包管理系统</strong>等。</p>
<p>作为站在巨人肩膀上的node，node在实现中并非完全按照CommonJS的模块规范，而是对模块规范进行了一定的取舍，同事也增加了不少自身需要的特性。</p>
<p>node的模块分为两类，一种是Node提供的模块，叫做<strong>核心模块</strong>;一种是用户自己编写的模块，叫做<strong>文件模块</strong> </p>
<p>核心模块被编译成二进制执行文件，在node启动时就被直接加载到内存中，所以执行速度最快，文件模块则是运行时加载，按照路径分析 –&gt; 文件定位 –&gt; 编译执行 的步骤加载执行</p>
<p>node有自己的包规范NPM，npm是什么，npm是一个包管理的神器，这个真的不能多说，每天都用</p>
<p><strong>前后端共用模块</strong></p>
<p>前后端共用模块主要有两种，AMD和CMD</p>
<p>AMD 即Asynchronous Module Definition，中文名是异步模块定义的意思。它是一个在浏览器端模块化开发的规范，由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎RequireJS，实际上AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出</p>
<p>requireJS主要解决两个问题</p>
<ol>
<li>多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器</li>
<li><p>js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长</p>
<p>看一个使用requireJS的例子</p>
</li>
</ol>
<pre class="prettyprint"><span class="hljs-comment">// 定义模块 myModule.js</span>
define([<span class="hljs-string">'dependency'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
    <span class="hljs-keyword">var</span> name = <span class="hljs-string">'Byron'</span>;
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printName</span><span class="hljs-params">()</span>{</span>
        console.log(name);
    }

    <span class="hljs-keyword">return</span> {
        printName: printName
    };
});

<span class="hljs-comment">// 加载模块</span>
<span class="hljs-built_in">require</span>([<span class="hljs-string">'myModule'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(my)</span>{</span>
　 my.printName();
});</pre>

<p>CMD由国内的玉伯提出，CMD模块更接近于Node对CommonJS的实现，CMD和AMD有什么区别，看下<a href="https://www.zhihu.com/people/lifesinger/answers" target="_blank" rel="noopener">玉伯</a>是怎么回答的吧<a href="https://www.zhihu.com/question/20351507/answer/14859415" target="_blank" rel="noopener">https://www.zhihu.com/question/20351507/answer/14859415</a></p>
<h2 id="第三章-异步IO"><a href="#第三章-异步IO" class="headerlink" title="第三章 异步IO"></a>第三章 异步IO</h2><p>异步IO真心没啥可提的，需要知道的是异步IO实现的核心是事件循环(过去是轮询技术)，他与浏览器中的执行模型基本保持了一致。</p>
<hr>
<p><br><strong>前端新手，弱鸡一枚，如有错误，请指正，谢谢！</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://michaelooo.github.io/2017/04/16/" data-id="clepflm8c005afbmncte5dbh3" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nodejs/" rel="tag">nodejs</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-有意思的前端面试题-附答案（一" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/15/" class="article-date">
  <time datetime="2017-03-14T16:01:49.000Z" itemprop="datePublished">2017-03-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9D%82%E8%B0%88/">杂谈</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/15/">[原]有意思的前端面试题-附答案（一）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>超过20家的前端面试题汇总，每天做一点，专挑有意思的做 </p>
<p>  此面试题题目部分来源： </p>
<p>  <a href="https://juejin.im/post/58c51b5c44d90400698da686?utm_source=gold_browser_extension" target="_blank" rel="noopener">https://juejin.im/post/58c51b5c44d90400698da686?utm_source=gold_browser_extension</a></p>
<p>1：当前一段代码输出结果是什么？</p>
<pre class="prettyprint"><span class="hljs-keyword">var</span> z = <span class="hljs-number">10</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>{</span>
    console.log(z);
}
(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(funArg)</span>{</span>
    <span class="hljs-keyword">var</span> z = <span class="hljs-number">20</span>;
    funArg();
})(foo);</pre>

<p><strong>【答案】：10</strong> </p>
<p><strong>这个其实还是考察函数的作用域和闭包的知识，因为foo函数是在一个自执行匿名函数里调用，在这里面声明的变量其实在函数foo体并不会访问到，所以在去找爸爸，全局声明的z，即输出 10</strong></p>
<p>2.当前一段代码输出结果是什么？</p>
<pre class="prettyprint"><span class="hljs-title">var</span> <span class="hljs-typedef"><span class="hljs-keyword">data</span> = [];</span>
<span class="hljs-title">for</span>(var k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">3</span>; k++){
        <span class="hljs-typedef"><span class="hljs-keyword">data</span>[k] = function<span class="hljs-container">()</span><span class="hljs-container">{
            <span class="hljs-title">console</span>.<span class="hljs-title">log</span>(<span class="hljs-title">k</span>);
        }</span>;</span>
}
<span class="hljs-typedef"><span class="hljs-keyword">data</span>[0]<span class="hljs-container">()</span>;</span>
<span class="hljs-typedef"><span class="hljs-keyword">data</span>[1]<span class="hljs-container">()</span>;</span>
<span class="hljs-typedef"><span class="hljs-keyword">data</span>[2]<span class="hljs-container">()</span>;</span></pre>

<p><strong>【答案】： 3 3 3</strong>  </p>
<p><strong>闭包，不多讲，把K的声明换成es6的写法let就可以变成 0 1 2</strong></p>
<p>3.假设现有一篇文章，var content = “…大量文字”， </p>
<p>文章中触及到一些敏感词汇,如 [“习近平”,”周永康”,”中共”,”6.4”] 等内容。 </p>
<p>如何在文章中发现这些敏感词，并将背景设置为红色或者改变字体颜色并标示出来。</p>
<p><strong>【答案】</strong> </p>
<p><strong>利用正则来做，方便快捷</strong></p>
<pre class="prettyprint"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filter</span><span class="hljs-params">(content)</span> {</span>
    <span class="hljs-keyword">var</span> result = <span class="hljs-string">''</span>;
    <span class="hljs-comment">// 预先设置的敏感词</span>
    <span class="hljs-keyword">var</span> minWords = [<span class="hljs-string">"习近平"</span>, <span class="hljs-string">"周永康"</span>, <span class="hljs-string">"中共"</span>, <span class="hljs-string">"6.4"</span>];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; content.length; i++) {
        <span class="hljs-keyword">var</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(minWords[i], <span class="hljs-string">"ig"</span>);
        result = content.replace(reg, <span class="hljs-string">""</span>);
    }
    <span class="hljs-keyword">return</span> result;
}</pre>



<p>4.<em>JQuery</em> 中 <em>$.fn.extend</em> 函数的实现（实现核心代码即可） </p>
<p><strong>【答案】</strong> </p>
<p><strong>先来看一下extend的用法，$.fn.extend 用于合并两个对象或多个对象到第一个对象上，它们的语法如下：</strong></p>
<pre class="prettyprint">jQuery<span class="hljs-preprocessor">.extend</span>([deep],target,object1,[..<span class="hljs-preprocessor">.objectN</span>])
jQuery<span class="hljs-preprocessor">.fn</span><span class="hljs-preprocessor">.extend</span>([deep],target,object1,[..<span class="hljs-preprocessor">.objectN</span>])</pre>

<p><strong>以下是核心代码（从源码拷过来的）：</strong></p>
<pre class="prettyprint"><span class="hljs-comment">//关键：修正参数deep、target、源对象的起始下标 =&gt; 逐个遍历源对象    </span>
jQuery.extend = jQuery.fn.extend = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-comment">/** 
     * options: 指向某一个源对象
     * name: 代表某个源对象里的某个属性名
     * src: 代表某个源对象里的某个属性的原始的值
     * copy: 表示某个源对象里的某个属性的值
     * copyIsArray: 表示变量copy是否为数组
     * clone: 表示进行深度复制时原始值的修正值
     * target: 指向目标对象
     * deep: 表示是否执行深度复制，默认为false不进行
     */</span>
    <span class="hljs-keyword">var</span> options, name, src, copy, copyIsArray, clone,
        target = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>] || {},
        i = <span class="hljs-number">1</span>,
        length = <span class="hljs-built_in">arguments</span>.length,
        deep = <span class="hljs-literal">false</span>;

    <span class="hljs-comment">//如果第一个参数时布尔值，就把第二个参数当做是目标对象</span>
    <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> target === <span class="hljs-string">"boolean"</span> ) {
        deep = target;
        target = <span class="hljs-built_in">arguments</span>[ i ] || {};
        i++;
    }
    <span class="hljs-comment">//如果目标对象不是对象或者一个函数，那就当作 空对象 处理</span>
    <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> target !== <span class="hljs-string">"object"</span> &amp;&amp; !jQuery.isFunction(target) ) {
        target = {};
    }
    <span class="hljs-comment">//没有传入源对象的情况（1,只有一个参数 2，第一个参数时deep值，第二个参数是参数）</span>
    <span class="hljs-keyword">if</span> ( i === length ) {
        target = <span class="hljs-keyword">this</span>;
        i--;
    }

    <span class="hljs-keyword">for</span> ( ; i &lt; length; i++ ) {
        <span class="hljs-keyword">if</span> ( (options = <span class="hljs-built_in">arguments</span>[ i ]) != <span class="hljs-literal">null</span> ) {
            <span class="hljs-keyword">for</span> ( name <span class="hljs-keyword">in</span> options ) {
                src = target[ name ];
                copy = options[ name ];

                <span class="hljs-keyword">if</span> ( target === copy ) {
                    <span class="hljs-keyword">continue</span>;
                }
                <span class="hljs-comment">//覆盖掉同名属性</span>
                <span class="hljs-keyword">if</span> ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
                    <span class="hljs-keyword">if</span> ( copyIsArray ) {
                        copyIsArray = <span class="hljs-literal">false</span>;
                        clone = src &amp;&amp; jQuery.isArray(src) ? src : [];

                    } <span class="hljs-keyword">else</span> {
                        clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : {};
                    }

                    target[ name ] = jQuery.extend( deep, clone, copy );

                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( copy !== <span class="hljs-literal">undefined</span> ) {
                    target[ name ] = copy;
                }
            }
        }
    }
    <span class="hljs-keyword">return</span> target;
};</pre>



<p>5.设计基于观察者模式的事件绑定机制 </p>
<p><strong>【答案】（此答案代码来自网络）</strong> </p>
<p><strong>首先要明白什么是观察者模式，观察者模式简单的说，就是当一个对象被修改时，则会自动通知它的依赖对象。观察者模式其实就是发布-订阅的过程。</strong> </p>
<p><strong>举个例子，我来公司面试的时候，完事之后每个面试官都会对我说：“请留下你的联系方式， 有消息我们会通知你”。 在这里“我”是订阅者， 面试官是发布者。所以我不用每天或者每小时都去询问面试结果， 通讯的主动权掌握在了面试官手上。而我只需要提供一个联系方式。</strong> </p>
<p><strong>以此为例，来编写代码，面试者把简历扔到一个盒子里， 然后面试官在合适的时机拿着盒子里的简历挨个打电话通知结果.</strong></p>
<pre class="prettyprint">Events = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">var</span> listen, obj, one, remove, trigger, __this;
    obj = {};
    __this = <span class="hljs-keyword">this</span>;
    listen = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(key, eventfn)</span> {</span> <span class="hljs-comment">//把简历扔盒子, key就是联系方式.</span>
        <span class="hljs-keyword">var</span> stack, _ref; <span class="hljs-comment">//stack是盒子</span>
        stack = (_ref = obj[key]) != <span class="hljs-literal">null</span> ? _ref : obj[key] = [];
        <span class="hljs-keyword">return</span> stack.push(eventfn);
    };
    one = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(key, eventfn)</span> {</span>
        remove(key);
        <span class="hljs-keyword">return</span> listen(key, eventfn);
    };
    remove = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(key)</span> {</span>
        <span class="hljs-keyword">var</span> _ref;
        <span class="hljs-keyword">return</span> (_ref = obj[key]) != <span class="hljs-literal">null</span> ? _ref.length = <span class="hljs-number">0</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
    };
    trigger = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span> <span class="hljs-comment">//面试官打电话通知面试者</span>
        <span class="hljs-keyword">var</span> fn, stack, _i, _len, _ref, key;
        key = <span class="hljs-built_in">Array</span>.prototype.shift.call(<span class="hljs-built_in">arguments</span>);
        stack = (_ref = obj[key]) != <span class="hljs-literal">null</span> ? _ref : obj[key] = [];
        <span class="hljs-keyword">for</span> (_i = <span class="hljs-number">0</span>, _len = stack.length; _i &lt; _len; _i++) {
            fn = stack[_i];
            <span class="hljs-keyword">if</span> (fn.apply(__this, <span class="hljs-built_in">arguments</span>) === <span class="hljs-literal">false</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
        }
    };
    <span class="hljs-keyword">return</span> {
        listen: listen,
        one: one,
        remove: remove,
        trigger: trigger
    }
}</pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://michaelooo.github.io/2017/03/15/" data-id="clepflm82004qfbmnho76hibr" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-简单理解内存中的堆栈与数据结构中的堆栈" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/08/" class="article-date">
  <time datetime="2017-03-08T15:13:11.000Z" itemprop="datePublished">2017-03-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9D%82%E8%B0%88/">杂谈</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/08/">[原]简单理解内存中的堆栈与数据结构中的堆栈</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>一日中午，平静的办公室忽然发出这样一个声音：什么是堆栈？ </p>
<p>于是瞬间，办公室开始闹腾起来 </p>
<p>A：堆栈就是后进后出 </p>
<p>B：堆就是时间牺牲空间，栈就是空间牺牲时间 </p>
<p>C：栈更快，堆就略微慢一点 </p>
<p>D：…… </p>
<p>作为刚毕业的码畜，听完之后就有些懵逼了（WTF，堆栈还有这么多东西吗？），于是上网搜寻各种资料，发现了一个在大学知识容易混淆的知识点，那就是——数据结构中的堆栈与内存中的堆栈存储是不同的</p>
<h2 id="数据结构中的堆栈"><a href="#数据结构中的堆栈" class="headerlink" title="数据结构中的堆栈"></a><strong>数据结构中的堆栈</strong></h2><p>先说数据结构中的堆栈，这个就是我们大学课程《数据结构》中所学到的，通俗上的堆栈的理解，堆和栈是数据存储方式的两种数据结构。关于堆栈，其实还有一个比较容易搞混的地方那就是队列，其实这三种都是数据结构中的一种排序数据结构 </p>
<ul>
<li><p><strong>堆</strong>：堆的数据机构其实就是一个完全二叉树，具堆属性的数据结构才可被叫做为堆，堆常见的应用就是堆排序与实现优先队列，为什么用？因为快啊 </p>
</li>
<li><p><strong>队列</strong>：就是先进先出的存储方式，类似与超市付款，先买的先走，一般与栈作比较 </p>
</li>
<li><p><strong>栈</strong>：与队列相反，栈的顺序是后进先出，只可以在栈顶进行操作，类似与只有一个出入口的公交车，先上车的只能后来下车 </p>
</li>
</ul>
<p><strong>速度</strong> </p>
<p> 队列与栈速度相对来说，队列的更快些，因为设计增加删除的操作时，队列不需要改变数据结构，而栈需要，所以遍历速度略低些，这些数据结构一般跟算法有点关系，其实平时敲代码用不到的好不</p>
<p>以上就是数据结构中的堆栈，接下来说下内存中的堆和栈</p>
<h2 id="内存中的堆和栈"><a href="#内存中的堆和栈" class="headerlink" title="内存中的堆和栈"></a><strong>内存中的堆和栈</strong></h2><p>在内存中的堆栈，一般指的是数据操作的存在位置，一般来说，栈是存放一些常量字面量一类的东西，这些一般有系统自己控制空间的开辟与释放，而堆是存放一些实例的变量，程序员需要自己去控制何时在内存中分配空间和何时释放（当然，这个也跟语言有关系，java就由虚拟机自行控制，c++就不行了） </p>
<p><strong>速度</strong> </p>
<p>关于速度，查阅资料，栈的存储一般位于一级缓存，堆的存储位于二级缓存，所以栈的速度是远远大于堆的。（关于一级缓存二级缓存的速度差异请看这个：<a href="http://www.to8to.com/yezhu/v9652.html%20%E2%80%9C%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E5%8C%BA%E5%88%AB%E2%80%9D" target="_blank" rel="noopener">http://www.to8to.com/yezhu/v9652.html</a>） </p>
<p><strong>什么是堆栈溢出</strong> </p>
<p>堆栈溢出就是不顾堆栈中分配的局部数据块大小，向该数据块写入了过多的数据，导致数据越界，结果覆盖了别的数据。意思就是，假如你在内存分配了8大小，而传入的值却大于这个长度，那么多余的长度就可能会覆盖内存中的其他元素，所以会得到错误的返回结果。堆栈溢出一般指的是堆溢出，栈溢出的情况比较少。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://michaelooo.github.io/2017/03/08/" data-id="clepflm8a0055fbmn68ebmxem" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A0%86%E6%A0%88/" rel="tag">堆栈</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>
 


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/3/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/">下一页&amp;raquo;</a>
  </nav>
</section>
           
    <aside id="sidebar">
  
    

  
    
  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/09/09/">如何将博客升级http2</a>
          </li>
        
          <li>
            <a href="/2018/08/27/">换新电脑不用慌-轻松搞定vscode配置</a>
          </li>
        
          <li>
            <a href="/2018/08/15/">git开发规范</a>
          </li>
        
          <li>
            <a href="/2018/08/09/">go入门踩坑及环境配置问题相关</a>
          </li>
        
          <li>
            <a href="/2018/07/18/">如何用node去搭建一个项目发布系统</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
    
  
    <!--微信公众号二维码-->


  
    <!-- 去掉浏览量统计 -->
<!-- 
    <div class="widget-wrap">
    <h3 class="widget-title">浏览数目</h3>
    <div class="widget">
      <ul class="popularlist">
      </ul>
    </div>
  </div>
 -->
  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2023 Michael Cheng&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
      <a target="_blank" href="http://www.beian.miit.gov.cn/" style="display:inline-block;text-decoration:none;height:20px;line-height:20px;margin-left: 10px;">
          <img style="float: left; width: 20px;" src="//img.alicdn.com/tfs/TB1..50QpXXXXX7XpXXXXXXXXXX-40-40.png">
          <span style="float:left;height:20px;line-height:20px;margin: 0px 0px 0px 5px; color:#939393;">粤ICP备17162335号</span>
      </a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;422208170@qq.com
    </div>
  </div>
</footer>
 
<script src="/jquery/jquery.min.js"></script>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/resume/" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="https://t1.picb.cc/uploads/2021/05/04/ZEnbna.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
     
<script src="/js/is.js"></script>



  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/elevator.js"></script>


<script src="/js/fundebug.1.9.0.min.js"></script>


<!--page counter part-->
<script>
  function addCount (Counter) {
    var curpage_count; 
    url=$('.article-date').attr('href').trim();
    title = $('.article-title').text().trim();
    var query=new AV.Query(Counter);
    //use url as unique idnetfication
    query.equalTo("url",url);
    query.find().then(function(results){
      if(results.length>0) {
          var counter=results[0];
          counter.fetchWhenSave(true); //get recent result
          counter.increment("time");
          counter.save();
          curpage_count = counter.attributes.time + 1;
          $('.article-inner').append('<p style="color:#999;margin-left:20px">（本文已被访问'+curpage_count+'次）</p>');
      } else {
        var newcounter=new Counter();
        newcounter.set("title",title);
        newcounter.set("url",url);
        newcounter.set("time",1);
        newcounter.save(null,{
            success: function(newcounter){
            //alert('New object created');
            },
            error: function(newcounter,error){
            alert('Failed to create');
            }
            });
        curpage_count = 1;
        $('.article-inner').append('<p style="color:#999;margin-left:20px">（本文已被访问'+curpage_count+'次）</p>');
      }
    },function(error){
        //find null is not a error
        alert('Error:'+error.code+" "+error.message);
    });
  }

  $(function(){
      // fundebug INIT
      fundebug.apikey = '311c1dc8f056512d95a8a459b5d14892078dc69e4686b5f704142485c2c04620';

      // init
      var APP_ID = 'P8zI4n1RVVKeFqFoDDcJXtxB-gzGzoHsz';
      var APP_KEY = 'XygRBwRtUGj8XJLClnpGKXQQ';

      AV.init({
        appId: APP_ID,
        appKey: APP_KEY
      });

      var Counter=AV.Object.extend("Counter");
      //only increse visit counting when intering a page
      if ($('.article-title').length == 1)
        addCount(Counter);
      var query=new AV.Query(Counter);
      query.descending("time");
      // the sum of popular posts
      query.limit(10); 
      query.find()
      .then(
        function(results){
          for(var i=0;i<results.length;i++)    
            {
                var counter=results[i];
                title=counter.get("title");
                url=counter.get("url");
                time=counter.get("time");
                // add to the popularlist widget
                showcontent=title+" ("+time+")";
                //notice the "" in href
                $('.popularlist').append('<li><a href="'+url+'">'+showcontent+'</a></li>');
            }
          },
          function(error){
            alert("Error:"+error.code+" "+error.message);
          });
  });
</script>

  </div>
</body>
</html>